This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-03T22:32:41.228Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
src/constants/anilist.ts
src/constants/utils.ts
src/hooks/use-debounce.ts
src/hooks/use-local-storage.ts
src/hooks/use-toast.ts
src/hooks/use-watch-progress.ts
src/hooks/use-watchlist.ts
src/hooks/useAuth.ts
src/lib/actions.ts
src/lib/anilist.ts
src/lib/auth.ts
src/lib/cache-service.ts
src/lib/cache.ts
src/lib/prisma.ts
src/lib/redis.ts
src/lib/utils.ts
src/modules/anilist/anilistsAPI.ts
src/modules/animeCustomTitles.ts
src/modules/aniskip.ts
src/modules/clientData.ts
src/modules/history.ts
src/modules/providers/animedrive.ts
src/modules/providers/animesaturn.ts
src/modules/providers/animeunity.ts
src/modules/providers/api.ts
src/modules/providers/cache.ts
src/modules/providers/gogoanime.ts
src/modules/providers/hianime.ts
src/modules/providers/monoschinos.ts
src/modules/requests.ts
src/modules/utils.ts
src/pages/api/anime/[provider]/[...params].ts
src/pages/api/anime/proxy.ts
src/services/auth.ts
src/types/auth.ts
src/types/search.ts
src/types/watchlist.ts

================================================================
Repository Files
================================================================

================
File: src/constants/anilist.ts
================
export const GENRES = [
    { value: '', label: 'Any' },
    { value: 'Action', label: 'Action' },
    { value: 'Adventure', label: 'Adventure' },
    { value: 'Comedy', label: 'Comedy' },
    { value: 'Drama', label: 'Drama' },
    { value: 'Ecchi', label: 'Ecchi' }, // Note: Consider filtering based on user preferences due to mature content
    { value: 'Fantasy', label: 'Fantasy' },
    { value: 'Horror', label: 'Horror' },
    { value: 'Mahou Shoujo', label: 'Mahou Shoujo' }, // Magical Girl
    { value: 'Mecha', label: 'Mecha' }, // Giant robots
    { value: 'Music', label: 'Music' },
    { value: 'Mystery', label: 'Mystery' }, // Misspelled in previous response
    { value: 'Psychological', label: 'Psychological' },
    { value: 'Romance', label: 'Romance' },
    { value: 'Sci-Fi', label: 'Sci-Fi' },
    { value: 'Slice of Life', label: 'Slice of Life' },
    { value: 'Sports', label: 'Sports' },
    { value: 'Supernatural', label: 'Supernatural' },
    { value: 'Thriller', label: 'Thriller' },
  ];
  
  export const SEASONS = [
    { value: '', label: 'Any' },
    { value: 'WINTER', label: 'Winter' },
    { value: 'SPRING', label: 'Spring' },
    { value: 'SUMMER', label: 'Summer' },
    { value: 'FALL', label: 'Fall' },
  ];
  
  export const FORMATS = [
    { value: '', label: 'Any' },
    { value: 'TV', label: 'TV Show' },
    { value: 'TV_SHORT', label: 'TV Short' },
    { value: 'MOVIE', label: 'Movie' },
    { value: 'SPECIAL', label: 'Special' },
    { value: 'OVA', label: 'OVA' },
    { value: 'ONA', label: 'ONA' },
    { value: 'MUSIC', label: 'Music' },
  ];
  
  export const SORTS = [
    { value: '', label: 'Any' },
    { value: 'START_DATE_DESC', label: 'Release Date' },
    { value: 'SCORE_DESC', label: 'Score' },
    { value: 'POPULARITY_DESC', label: 'Popularity' },
    { value: 'TRENDING_DESC', label: 'Trending' },
  ];

================
File: src/constants/utils.ts
================
export const SPONSOR_URL = '';
export const OPEN_NEW_ISSUE_URL = '';
export const EPISODES_INFO_URL = 'https://api.ani.zip/mappings?anilist_id=';

================
File: src/hooks/use-debounce.ts
================
import { useState, useEffect } from "react";

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

================
File: src/hooks/use-local-storage.ts
================
"use client";

import { useState, useEffect } from "react";


export function useLocalStorage<T>(key: string, initialValue: T) {
  // Initialize state with a function to ensure it only runs once
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Only update localStorage when storedValue changes
  useEffect(() => {
    if (typeof window !== "undefined") {
      try {
        window.localStorage.setItem(key, JSON.stringify(storedValue));
      } catch (error) {
        console.warn(`Error setting localStorage key "${key}":`, error);
      }
    }
  }, [key, storedValue]);


  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
    } catch (error) {
      console.warn(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue] as const;
}

================
File: src/hooks/use-toast.ts
================
'use client';

// Inspired by react-hot-toast library
import * as React from 'react';

import type { ToastActionElement, ToastProps } from '@/components/ui/toast';

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType['ADD_TOAST'];
      toast: ToasterToast;
    }
  | {
      type: ActionType['UPDATE_TOAST'];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType['DISMISS_TOAST'];
      toastId?: ToasterToast['id'];
    }
  | {
      type: ActionType['REMOVE_TOAST'];
      toastId?: ToasterToast['id'];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: 'REMOVE_TOAST',
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      };

    case 'DISMISS_TOAST': {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      };
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, 'id'>;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id });

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  };
}

export { useToast, toast };

================
File: src/hooks/use-watch-progress.ts
================
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/hooks/useAuth";
import { useLocalStorage } from "@/hooks/use-local-storage";
import { updateAnimeProgress } from "@/modules/anilist/anilistsAPI";

interface WatchProgress {
  animeId: number;
  episodeNumber: number;
  timestamp: number;
  progress: number;
  duration: number;
  title: string;
  coverImage: string;
  totalEpisodes?: number;
}

export function useWatchProgress() {
  const { isAuthenticated, lists, updateLists } = useAuth();
  const [localProgress, setLocalProgress] = useLocalStorage<Record<string, WatchProgress>>("watch-progress", {});
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (isAuthenticated && lists) {
      // Convert AniList progress to local format
      const progress: Record<string, WatchProgress> = {};
      lists.forEach(item => {
        if (item.progress) {
          progress[item.media.id] = {
            animeId: item.media.id,
            episodeNumber: item.progress,
            timestamp: Date.now(),
            progress: 100,
            duration: 24 * 60,
            title: item.media.title?.english || item.media.title?.romaji || '',
            coverImage: item.media.coverImage?.large || '',
            totalEpisodes: item.media.episodes
          };
        }
      });
      setLocalProgress(progress);
    }
    setIsLoading(false);
  }, [isAuthenticated, lists]);

  const updateProgress = async (
    animeId: number,
    episodeNumber: number,
    progress: number,
    duration: number,
    title: string,
    coverImage: string,
    totalEpisodes?: number
  ) => {
    // Update local storage
    const key = animeId.toString();
    setLocalProgress(prev => ({
      ...prev,
      [key]: {
        animeId,
        episodeNumber,
        timestamp: Date.now(),
        progress,
        duration,
        title,
        coverImage,
        totalEpisodes
      }
    }));

    // Update AniList if authenticated
    if (isAuthenticated) {
      await updateAnimeProgress(animeId, episodeNumber);
      
      // Update local state
      const updatedLists = lists?.map(item =>
        item.media.id === animeId ? { ...item, progress: episodeNumber } : item
      ) || [];
      updateLists(updatedLists);
    }
  };

  const getProgress = (animeId: number): number | null => {
    if (isAuthenticated) {
      const entry = lists?.find(item => item.media.id === animeId);
      return entry?.progress || null;
    } else {
      return localProgress[animeId]?.episodeNumber || null;
    }
  };

  return {
    updateProgress,
    getProgress,
    isLoading,
  };
}

================
File: src/hooks/use-watchlist.ts
================
"use client";

import { useState, useEffect, useRef } from "react";
import { useAuth } from "@/hooks/useAuth";
import { useLocalStorage } from "@/hooks/use-local-storage";
import { WatchlistEntry, WatchStatus } from "@/types/watchlist";
import { updateAnimeFromList, deleteAnimeFromList } from "@/modules/anilist/anilistsAPI";

export function useWatchlist() {
  const { isAuthenticated, lists, updateLists } = useAuth();
  const [localWatchlist, setLocalWatchlist] = useLocalStorage<WatchlistEntry[]>("watchlist", []);
  const [isLoading, setIsLoading] = useState(true);
  const initialLoadDone = useRef(false);

  useEffect(() => {
    if (!initialLoadDone.current) {
      if (isAuthenticated && lists) {
        const syncedList = lists.map(item => ({
          id: item.mediaId || item.media.id,
          status: (item.status?.toLowerCase() || "watching") as WatchStatus,
          progress: item.progress || 0,
          media: {
            id: item.media.id,
            title: item.media.title,
            coverImage: item.media.coverImage,
            episodes: item.media.episodes,
            genres: item.media.genres,
          },
          updatedAt: Date.now(),
        }));
        setLocalWatchlist(syncedList);
      }
      initialLoadDone.current = true;
      setIsLoading(false);
    }
  }, [isAuthenticated, lists, setLocalWatchlist]);

  const addToWatchlist = async (entry: WatchlistEntry) => {
    if (isAuthenticated) {
      const mediaListId = await updateAnimeFromList(
        entry.id,
        entry.status.toUpperCase(),
        undefined,
        entry.progress
      );
      
      if (mediaListId) {
        const updatedLists = lists?.map(item => 
          item.mediaId === entry.id ? { ...item, status: entry.status.toUpperCase() } : item
        ) || [];
        updateLists(updatedLists);
      }
    } else {
      const existingIndex = localWatchlist.findIndex(item => item.id === entry.id);
      if (existingIndex >= 0) {
        const newList = [...localWatchlist];
        newList[existingIndex] = entry;
        setLocalWatchlist(newList);
      } else {
        setLocalWatchlist([...localWatchlist, entry]);
      }
    }
  };

  const removeFromWatchlist = async (animeId: number) => {
    if (isAuthenticated) {
      const success = await deleteAnimeFromList(animeId);
      if (success) {
        const updatedLists = lists?.filter(item => item.mediaId !== animeId) || [];
        updateLists(updatedLists);
      }
    } else {
      setLocalWatchlist(localWatchlist.filter(item => item.id !== animeId));
    }
  };

  const getStatus = (animeId: number): WatchStatus | null => {
    if (isAuthenticated) {
      const entry = lists?.find(item => item.mediaId === animeId);
      return entry ? (entry.status?.toLowerCase() as WatchStatus) : null;
    } else {
      const entry = localWatchlist.find(item => item.id === animeId);
      return entry ? entry.status : null;
    }
  };

  return {
    watchlist: isAuthenticated ? lists : localWatchlist,
    addToWatchlist,
    removeFromWatchlist,
    getStatus,
    isLoading,
  };
}

================
File: src/hooks/useAuth.ts
================
import { useState, useEffect } from "react";
import { authenticateUser, clearAuthSession, loadPersistedAuth } from "@/lib/auth";
import type { AuthState, UserProfile, AnimeListEntry } from "@/types/auth";

const initialState: AuthState = {
  isAuthenticated: false,
  user: null,
  lists: [],
  isLoading: true,
  error: null
};

export function useAuth() {
  const [state, setState] = useState<AuthState>(initialState);

  useEffect(() => {
    const loadAuth = async () => {
      // Check both access token and user data
      const accessToken = sessionStorage.getItem("access_token");
      const userData = sessionStorage.getItem("user_data");
      const listsData = sessionStorage.getItem("anime_lists");

      if (accessToken && userData) {
        setState({
          isAuthenticated: true,
          user: JSON.parse(userData),
          lists: listsData ? JSON.parse(listsData) : [],
          isLoading: false,
          error: null
        });
      } else {
        setState(prev => ({ ...prev, isLoading: false }));
      }
    };

    loadAuth();
  }, []);

  const login = async (token: string) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    
    try {
      const response = await authenticateUser(token);
      
      if (response.success && response.user && response.lists) {
        setState({
          isAuthenticated: true,
          user: response.user,
          lists: response.lists,
          isLoading: false,
          error: null
        });
        return true;
      } else {
        setState(prev => ({
          ...prev,
          isLoading: false,
          error: response.error || "Authentication failed"
        }));
        return false;
      }
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: "An unexpected error occurred"
      }));
      return false;
    }
  };

  const logout = () => {
    clearAuthSession();
    setState({
      isAuthenticated: false,
      user: null,
      lists: [],
      isLoading: false,
      error: null
    });
  };

  const updateLists = (newLists: AnimeListEntry[]) => {
    setState(prev => ({
      ...prev,
      lists: newLists
    }));
    sessionStorage.setItem("anime_lists", JSON.stringify(newLists));
  };

  return {
    ...state,
    login,
    logout,
    updateLists
  };
}

================
File: src/lib/actions.ts
================
export async function searchAnime(query: string) {
  const response = await fetch("https://graphql.anilist.co", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      query: `
        query ($search: String) {
          Page(page: 1, perPage: 10) {
            media(type: ANIME, search: $search) {
              id
              title {
                romaji
                english
              }
              coverImage {
                large
                medium
              }
              bannerImage
              description
              episodes
              status
              genres
              averageScore
              popularity
              season
              seasonYear
              format
              duration
              studios {
                nodes {
                  id
                  name
                }
              }
            }
          }
        }
      `,
      variables: { search: query },
    }),
  });

  const { data } = await response.json();
  return data?.Page?.media || [];
}

================
File: src/lib/anilist.ts
================
const ANILIST_API = 'https://graphql.anilist.co';

export type Anime = {
  id: number;
  title: {
    romaji: string;
    english: string;
  };
  coverImage: {
    large: string;
    medium: string;
  };
  bannerImage: string;
  description: string;
  episodes: number;
  status: string;
  genres: string[];
  averageScore: number;
  popularity: number;
  season?: string;
  seasonYear?: number;
  format?: string;
  duration?: number;
  studios?: {
    nodes: {
      id: number;
      name: string;
    }[];
  };
};

const fetchAnimeData = async (query: string, variables = {}) => {
  try {
    const response = await fetch(ANILIST_API, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ query, variables }),
    });

    const { data } = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching anime data:', error);
    return null;
  }
};

export async function getTrendingAnime(): Promise<Anime[]> {
  const query = `
    query {
      Page(page: 1, perPage: 16) {
        media(type: ANIME, sort: TRENDING_DESC) {
          id
          title {
            romaji
            english
          }
          coverImage {
            large
            medium
          }
          bannerImage
          description
          episodes
          status
          genres
          averageScore
          popularity
        }
      }
    }
  `;

  const data = await fetchAnimeData(query);
  return data?.Page?.media || [];
}

export async function getPopularThisSeason(): Promise<Anime[]> {
  const query = `
    query {
      Page(page: 1, perPage: 12) {
        media(type: ANIME, sort: POPULARITY_DESC, season: FALL, seasonYear: 2024, status: RELEASING) {
          id
          title {
            romaji
            english
          }
          coverImage {
            large
            medium
          }
          bannerImage
          description
          episodes
          status
          genres
          averageScore
          popularity
          season
          seasonYear
        }
      }
    }
  `;

  const data = await fetchAnimeData(query);
  return data?.Page?.media || [];
}

export async function getUpcomingNextSeason(): Promise<Anime[]> {
  const query = `
    query {
      Page(page: 1, perPage: 12) {
        media(type: ANIME, sort: POPULARITY_DESC, season: WINTER, seasonYear: 2025, status: NOT_YET_RELEASED) {
          id
          title {
            romaji
            english
          }
          coverImage {
            large
            medium
          }
          bannerImage
          description
          episodes
          status
          genres
          averageScore
          popularity
          season
          seasonYear
        }
      }
    }
  `;

  const data = await fetchAnimeData(query);
  return data?.Page?.media || [];
}

export async function getTopRatedAnime(): Promise<Anime[]> {
  const query = `
    query {
      Page(page: 1, perPage: 12) {
        media(type: ANIME, sort: POPULARITY_DESC) {
          id
          title {
            romaji
            english
          }
          coverImage {
            large
            medium
          }
          bannerImage
          description
          episodes
          status
          genres
          averageScore
          popularity
        }
      }
    }
  `;

  const data = await fetchAnimeData(query);
  return data?.Page?.media || [];
}

export async function getAnimeById(id: number): Promise<Anime | null> {
  const query = `
    query ($id: Int) {
      Media(id: $id, type: ANIME) {
        id
        title {
          romaji
          english
        }
        coverImage {
          large
          medium
        }
        bannerImage
        description
        episodes
        status
        genres
        averageScore
        popularity
        season
        seasonYear
        format
        duration
        streamingEpisodes {
          thumbnail
          title
          url
        }
        studios {
          nodes {
            id
            name
          }
        }
      }
    }
  `;

  const data = await fetchAnimeData(query, { id });
  return data?.Media || null;
}


export async function getAllAnimeIds(): Promise<number[]> {
  const [trending, popular, upcoming, topRated] = await Promise.all([
    getTrendingAnime(),
    getPopularThisSeason(),
    getUpcomingNextSeason(),
    getTopRatedAnime(),
  ]);

  const allAnime = [...trending, ...popular, ...upcoming, ...topRated];
  return Array.from(new Set(allAnime.map(anime => anime.id)));
}

================
File: src/lib/auth.ts
================
import { getAccessToken, getViewerId, getViewerInfo, getViewerLists } from "@/modules/anilist/anilistsAPI";
import type { AuthResponse, AnimeListEntry } from "@/types/auth";
import type { MediaListStatus } from "@/types/anilistGraphQLTypes";
import { clientData } from "@/modules/clientData";

export async function authenticateUser(token: string): Promise<AuthResponse> {
  try {
    const accessToken = await getAccessToken(token);
    if (!accessToken) {
      return { success: false, error: "Failed to obtain access token" };
    }

    sessionStorage.setItem("access_token", accessToken);

    const viewerId = await getViewerId();
    if (!viewerId) {
      return { success: false, error: "Failed to obtain user ID" };
    }

    const userData = await getViewerInfo(viewerId);
    if (!userData) {
      return { success: false, error: "Failed to fetch user data" };
    }

    // Store complete user data including avatar
    const userProfile = {
      id: userData.id,
      name: userData.name,
      avatar: {
        medium: userData.avatar?.medium
      }
    };
    
    sessionStorage.setItem("user_data", JSON.stringify(userProfile));
    sessionStorage.setItem("viewer_id", viewerId.toString());

    return {
      success: true,
      user: userProfile,
      lists: []
    };
  } catch (error) {
    console.error('Authentication error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Authentication failed"
    };
  }
}

export function clearAuthSession(): void {
  sessionStorage.removeItem("access_token");
  sessionStorage.removeItem("viewer_id");
  sessionStorage.removeItem("anime_lists");
}

export function loadPersistedAuth(): AuthResponse {
  try {
    const accessToken = sessionStorage.getItem("access_token");
    const viewerId = sessionStorage.getItem("viewer_id");
    const listsData = sessionStorage.getItem("anime_lists");

    if (!accessToken || !viewerId) {
      return { success: false };
    }

    const lists = listsData ? JSON.parse(listsData) : [];

    return {
      success: true,
      lists
    };
  } catch (error) {
    console.error("Error loading persisted auth:", error);
    return { success: false, error: "Failed to load saved session" };
  }
}

export function getAuthUrl() {

  return `https://anilist.co/api/v2/oauth/authorize?client_id=${clientData.clientId}&redirect_uri=${clientData.redirectUri}&response_type=code`;
}

================
File: src/lib/cache-service.ts
================
import { PrismaClient } from '@prisma/client'
import { IVideo, IAnimeEpisode } from '@consumet/extensions'

const prisma = new PrismaClient()

export class CacheService {
    private readonly API_ENDPOINT = `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/cache`;


    async cacheImage(url: string, animeId: number, type: 'cover' | 'banner') {
        try {
            const response = await fetch(this.API_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    url, 
                    animeId, 
                    type, 
                    action: 'cacheImage' 
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error caching image:', error);
            return null;
        }
    }

    async cacheAnimeImages(animeId: number, coverImage?: string, bannerImage?: string) {
        const response = await fetch(this.API_ENDPOINT, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                animeId, 
                coverImage, 
                bannerImage, 
                action: 'cacheAnimeImages' 
            })
        });
        return response.json();
    }

    async cacheEpisode(animeId: number, episode: number, sources: IVideo[]) {
        const response = await fetch(this.API_ENDPOINT, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                animeId, 
                episode, 
                sources, 
                action: 'cacheEpisode' 
            })
        });
        return response.json();
    }

    async getEpisodeCache(animeId: number, episode: number) {
        const response = await fetch(this.API_ENDPOINT, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                animeId, 
                episode, 
                action: 'getEpisodeCache' 
            })
        });
        return response.json();
    }
    async getImageCache(url: string) {
        try {
            const response = await fetch(this.API_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    url, 
                    action: 'getImageCache' 
                })
            });
            
            if (!response.ok) {
                return { error: true };
            }
            
            return response.json();
        } catch (error) {
            console.error('Error getting image cache:', error);
            return { error: true };
        }
    }
}

export const cacheService = new CacheService();

================
File: src/lib/cache.ts
================
import { NextApiRequest, NextApiResponse } from 'next';
import { prisma } from '@/lib/prisma';
import { IAnimeEpisode, IVideo } from '@consumet/extensions';
import { cacheService } from './cache-service';

export default class ProviderCache {
    search: { [key: string]:  IVideo[] | null};
    animeIds: { [key: string]: string | null};
    episodes: { [key: string]: IAnimeEpisode[] | undefined };
  
    constructor() {
        // Initialize all cache objects
        this.search = Object.create(null);
        this.animeIds = Object.create(null);
        this.episodes = Object.create(null);
    }
  }

// Create singleton instance
const globalCache = new ProviderCache();


const handler = async (req: NextApiRequest, res: NextApiResponse) => {
    if (req.method !== 'POST') {
      return res.status(405).json({ message: 'Method not allowed' });
    }
  
    const { action } = req.body;
  
    switch (action) {
      case 'cacheImage':
        return handleCacheImage(req, res);
      case 'cacheAnimeImages':
        return handleCacheAnimeImages(req, res);
      case 'cacheEpisode':
        return handleCacheEpisode(req, res);
      case 'getEpisodeCache':
        return handleGetEpisodeCache(req, res);
      case 'getImageCache':
        return handleGetImageCache(req, res);
      default:
        return res.status(400).json({ message: 'Invalid action' });
    }

  };
  const handleCacheImage = async (url: string, animeId: number, type: 'cover' | 'banner') => {
    try {
      const response = await cacheService.getImageCache(url);
      if (!response || response.error) {
        const cacheResponse = await cacheService.cacheImage(url, animeId, type);
        if (cacheResponse) {
          console.log(`Successfully cached image for anime ${animeId}`);
        }
      }
    } catch (error) {
      console.log('Image cache handling:', error);
    }
  };
  

async function handleCacheAnimeImages(req: NextApiRequest, res: NextApiResponse) {
  const { animeId, coverImage, bannerImage } = req.body;
  try {
    const promises = [];
    if (coverImage) {
      promises.push(prisma.imageCache.upsert({
        where: { url: coverImage },
        update: { updatedAt: new Date() },
        create: { url: coverImage, animeId, type: 'cover' }
      }));
    }
    if (bannerImage) {
      promises.push(prisma.imageCache.upsert({
        where: { url: bannerImage },
        update: { updatedAt: new Date() },
        create: { url: bannerImage, animeId, type: 'banner' }
      }));
    }
    const results = await Promise.all(promises);
    return res.status(200).json(results);
  } catch (error) {
    console.error('Cache anime images error:', error);
    return res.status(500).json({ message: 'Failed to cache anime images' });
  }
}

async function handleCacheEpisode(req: NextApiRequest, res: NextApiResponse) {
  const { animeId, episode, sources } = req.body;
  try {
    const cached = await prisma.episodeCache.upsert({
      where: { 
        animeId_episode: { animeId, episode }
      },
      update: { 
        sources,
        updatedAt: new Date()
      },
      create: {
        animeId,
        episode,
        sources,
        quality: sources.map((s: IVideo) => s.quality)
      }
    });
    return res.status(200).json(cached);
  } catch (error) {
    console.error('Cache episode error:', error);
    return res.status(500).json({ message: 'Failed to cache episode' });
  }
}

async function handleGetEpisodeCache(req: NextApiRequest, res: NextApiResponse) {
  const { animeId, episode } = req.body;
  try {
    const cached = await prisma.episodeCache.findUnique({
      where: {
        animeId_episode: { animeId, episode }
      }
    });
    return res.status(200).json(cached);
  } catch (error) {
    console.error('Get episode cache error:', error);
    return res.status(500).json({ message: 'Failed to get episode cache' });
  }
}

async function handleGetImageCache(req: NextApiRequest, res: NextApiResponse) {
  const { url } = req.body;
  try {
    const cached = await prisma.imageCache.findUnique({
      where: { url }
    });
    return res.status(200).json(cached);
  } catch (error) {
    console.error('Get image cache error:', error);
    return res.status(500).json({ message: 'Failed to get image cache' });
  }
}

================
File: src/lib/prisma.ts
================
import { PrismaClient } from "@prisma/client";

declare global {
  var prisma: PrismaClient | undefined;
}

export const prisma = global.prisma || new PrismaClient();

if (process.env.NODE_ENV !== "production") global.prisma = prisma;

================
File: src/lib/redis.ts
================
import { Redis } from "ioredis";
import { RateLimiterRedis } from "rate-limiter-flexible";

const REDIS_URL: string | undefined = process.env.REDIS_URL;

let redis: Redis;
let rateLimiterRedis: RateLimiterRedis;
let rateLimitStrict: RateLimiterRedis;
let rateSuperStrict: RateLimiterRedis;

if (REDIS_URL) {
  redis = new Redis(REDIS_URL);
  redis.on("error", (err: Error) => {
    console.error("Redis error: ", err);
  });

  const opt = {
    storeClient: redis,
    keyPrefix: "rateLimit",
    points: 50,
    duration: 1,
  };

  const optStrict = {
    storeClient: redis,
    keyPrefix: "rateLimitStrict",
    points: 20,
    duration: 1,
  };

  const optSuperStrict = {
    storeClient: redis,
    keyPrefix: "rateLimitSuperStrict",
    points: 3,
    // duration 10 minutes
    duration: 10 * 60,
    blockDuration: 10 * 60,
  };

  rateLimiterRedis = new RateLimiterRedis(opt);
  rateLimitStrict = new RateLimiterRedis(optStrict);
  rateSuperStrict = new RateLimiterRedis(optSuperStrict);
} else {
  console.warn("REDIS_URL is not defined. Redis caching will be disabled.");
}

export { redis, rateLimiterRedis, rateLimitStrict, rateSuperStrict };

================
File: src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatTime(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const remainingSeconds = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
  }
  return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
}

export function formatDate(date: string | number): string {
  return new Date(date).toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
}

export function formatNumber(num: number): string {
  return new Intl.NumberFormat("en-US", {
    notation: "compact",
    maximumFractionDigits: 1,
  }).format(num);
}

export interface AuthResponse {
  success: boolean;
  user?: any;
  lists?: any;
}

export function loadPersistedAuth(): AuthResponse {
  try {
    const accessToken = sessionStorage.getItem('access_token');
    const viewerId = sessionStorage.getItem('viewer_id');
    const userData = sessionStorage.getItem('user_data');
    const listsData = sessionStorage.getItem('anime_lists');

    if (!accessToken || !viewerId || !userData || !listsData) {
      return { success: false };
    }

    return {
      success: true,
      user: JSON.parse(userData),
      lists: JSON.parse(listsData)
    };
  } catch (error) {
    console.error("Error loading persisted auth:", error);
    return { success: false };
  }
}

================
File: src/modules/anilist/anilistsAPI.ts
================
import {
  AnimeData,
  CurrentListAnime,
  ListAnimeData,
  MostPopularAnime,
  TrendingAnime,
} from '../../types/anilistAPITypes';
import { AiringPage, AiringSchedule, Media, MediaListStatus} from '../../types/anilistGraphQLTypes';
import { ClientData } from '../../types/types';
import { clientData } from '../clientData';

import { getOptions, makeRequest } from '../requests';
import { proxyRequest } from '../utils';


const CLIENT_DATA: ClientData = {
  clientId: clientData.clientId,
  redirectUri: clientData.redirectUri,
  clientSecret: clientData.clientSecret || ''
};
const PAGES: number = 20;
const METHOD: string = 'POST';
const GRAPH_QL_URL: string = 'https://graphql.anilist.co';
const HEADERS: Object = {
  'Content-Type': 'application/json',
  Accept: 'application/json',
};
const RECOMMEND_DATA: string = `
        recommendations(sort:RATING_DESC) {
          nodes {
            id
            rating
            mediaRecommendation {
              id
              idMal
              type
              title {
                  romaji
                  english
                  native
                  userPreferred
              }
              format
              status
              description
              startDate {
                  year
                  month
                  day
              }
              endDate {
                  year
                  month
                  day
              }
              season
              seasonYear
              episodes
              duration
              coverImage {
                  large
                  extraLarge
                  color
              }
              bannerImage
              genres
              synonyms
              averageScore
              meanScore
              popularity
              favourites
              isAdult
              nextAiringEpisode {
                  id
                  timeUntilAiring
                  episode
                  airingAt
              }
              mediaListEntry {
                  id
                  mediaId
                  status
                  score(format:POINT_10)
                  progress
              }
              siteUrl
              trailer {
                  id
                  site
                  thumbnail
              }
            }
          }
        }`
const MEDIA_DATA: string = `
        id
        idMal
        type
        title {
            romaji
            english
            native
            userPreferred
        }
        format
        status
        description
        startDate {
            year
            month
            day
        }
        endDate {
            year
            month
            day
        }
        season
        seasonYear
        episodes
        duration
        coverImage {
            large
            extraLarge
            color
        }
        bannerImage
        genres
        synonyms
        averageScore
        meanScore
        popularity
        favourites
        isAdult
        nextAiringEpisode {
            id
            timeUntilAiring
            episode
            airingAt
        }
        airingSchedule {
          edges {
            node {
              episode
            }
          }
        }
        mediaListEntry {
            id
            mediaId
            status
            score(format:POINT_10)
            progress
        }
        siteUrl
        trailer {
            id
            site
            thumbnail
        }
        relations {
          edges {
            id
            relationType(version: 2)
            node {
              id
              idMal
              type
              title {
                  romaji
                  english
                  native
                  userPreferred
              }
              format
              status
              description
              startDate {
                  year
                  month
                  day
              }
              endDate {
                  year
                  month
                  day
              }
              season
              seasonYear
              episodes
              duration
              coverImage {
                  large
                  extraLarge
                  color
              }
              bannerImage
              genres
              synonyms
              averageScore
              meanScore
              popularity
              favourites
              isAdult
              nextAiringEpisode {
                  id
                  timeUntilAiring
                  episode
              }
              airingSchedule {
                edges {
                  node {
                    episode
                  }
                }
              }
              mediaListEntry {
                  id
                  mediaId
                  status
                  score(format:POINT_10)
                  progress
              }
              siteUrl
              trailer {
                  id
                  site
                  thumbnail
              }
            }
          }
        }
        ${RECOMMEND_DATA}
    `;

const filterAdultMedia = (media?: Media) =>
  media && !media.isAdult;

/**
 * Retrieves the access token for the api
 *
 * @param {*} code
 * @returns access token
 */
export const getAccessToken = async (code: string): Promise<string> => {
  const url = 'https://anilist.co/api/v2/oauth/token';

  const data = {
    grant_type: 'authorization_code',
    client_id: CLIENT_DATA.clientId,
    client_secret: CLIENT_DATA.clientSecret,
    redirect_uri: CLIENT_DATA.redirectUri,
    code: code,
  };

  console.log('Auth request data:', {
    ...data,
     // Don't log the secret
  });

  const respData = await proxyRequest(url, 'POST', {
    'Content-Type': 'application/json',
    Accept: 'application/json',
  }, data);

  return respData.access_token;
};

/**
 * Gets the anilist viewer (user) id
 *
 * @returns viewer id
 */
export const getViewerId = async (): Promise<number> => {
var query = `
        query {
            Viewer {
                id
            }
        }
    `;

var headers = {
  Authorization: 'Bearer ' + sessionStorage.getItem("access_token"),
  'Content-Type': 'application/json',
  Accept: 'application/json',
};

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Viewer.id;
};

/**
 * Gets the viewer (user) info
 *
 * @param {*} viewerId
 * @returns object with viewer info
 */
export const getViewerInfo = async (viewerId: number | null) => {
  var query = `
          query($userId : Int) {
              User(id: $userId, sort: ID) {
                  id
                  name
                  avatar {
                      medium
                  }
                  options {
                    displayAdultContent
                  }
              }
          }
      `;

  var headers = {
    Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  var variables = {
    userId: viewerId,
  };

  const options = getOptions(query, variables);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.User;
};

/**
 * Gets viewer lists (current, completed...)
 *
 * @param {*} viewerId
 * @param {*} statuses
 * @returns object with anime entries
 */
export const getViewerLists = async (
  viewerId: number,
  ...statuses: MediaListStatus[]
): Promise<CurrentListAnime> => {
  var query = `
          query($userId : Int, $statuses: [MediaListStatus]) {
              MediaListCollection(userId : $userId, type: ANIME, status_in: $statuses, sort: UPDATED_TIME_DESC) {
                  lists {
                      isCustomList
                      name
                      status
                      entries {
                          id
                          mediaId
                          progress
                          media {
                              ${MEDIA_DATA}
                          }
                      }
                  }
              }
          }
      `;

  var headers = {
    Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  var variables = {
    userId: viewerId,
    statuses: statuses
  };

  const options = getOptions(query, variables);

  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  const lists = respData.data.MediaListCollection.lists.length === 0
  ? []
  : (respData.data.MediaListCollection.lists as Array<any>);

  return lists.map(value => value.entries).flat();
};

/**
 * Gets a viewer list (current, completed...)
 *
 * @param {*} viewerId
 * @param {*} status
 * @returns object with anime entries
 */
export const getViewerList = async (
  viewerId: number,
  status: MediaListStatus,
): Promise<CurrentListAnime> => {
  var query = `
          query($userId : Int) {
              MediaListCollection(userId : $userId, type: ANIME, status : ${status}, sort: UPDATED_TIME_DESC) {
                  lists {
                      isCustomList
                      name
                      entries {
                          id
                          mediaId
                          progress
                          media {
                              ${MEDIA_DATA}
                          }
                      }
                  }
              }
          }
      `;

  var headers = {
    Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  var variables = {
    userId: viewerId,
  };

  const options = getOptions(query, variables);

  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.MediaListCollection.lists.length === 0
    ? []
    : respData.data.MediaListCollection.lists[0].entries;
};

// NOT WORKING
export const getFollowingUsers = async (viewerId: any) => {
  var query = `
          query($userId : Int) {
              User(id: $userId, sort: ID) {
                  id
                  name
                  avatar {
                      large
                  }
              }
          }
      `;

  var headers = {
    Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  var variables = {
    userId: viewerId,
  };

  const options = getOptions(query, variables);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);
};

const sanitizeString = (input: string) => JSON.stringify(input).slice(1, -1).replace(/[{};`\\"'\!]/g, '');

/**
 * Gets a list of anime from a list of titles.
 *
 * @param titles
 * @returns anime list
 */
export const getAnimesFromTitles = async (titles: string[]) => {
  let query_variables: string[] = [];
  let variables: { [key: string]: string } = {};
  let search_text: string[] = [];

  const results: ListAnimeData[] = [];
  const headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
  };

  for (let index = 0; index < titles.length; index++) {
      const value = titles[index];
      const id: string = `anime${query_variables.length}`;

      query_variables.push(`$${id}: String`);
      search_text.push(`    ${id}: Media(search: $${id}, type: ANIME) { ${MEDIA_DATA} }`);
      variables[id] = sanitizeString(value).replaceAll('Part', '');

      if (query_variables.length > 2 || index === titles.length - 1) {
          const query = `
              query(${query_variables.join(", ")}) {
              ${search_text.join("\n")}
              }
          `;
          try {
            const options = getOptions(query, variables);
            const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

            for (let i = 0; i < query_variables.length; i++) {
                const id = `anime${i}`;
                results.push({
                    id: null,
                    mediaId: null,
                    progress: null,
                    media: respData.data[id],
                });
            }
          } catch (error) {
            console.log('Batch search error:', error);
          }

          query_variables = [];
          variables = {};
          search_text = [];
      }
  }

  return results;
};


/**
 * Gets the info from an anime
 *
 * @param {*} animeId
 * @returns object with anime info
 */
// Update the getAnimeInfo function to handle server-side and client-side auth
export const getAnimeInfo = async (animeId: number): Promise<Media> => {
  const query = `
    query($id: Int) {
      Media(id: $id, type: ANIME) {
        ${MEDIA_DATA}
      }
    }
  `;

  const headers: {[key: string]: string} = {
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  // Only add auth header if we're on the client and have a token
  if (typeof window !== 'undefined' && sessionStorage.getItem('access_token')) {
    headers.Authorization = `Bearer ${sessionStorage.getItem('access_token')}`;
  }

  const variables = {
    id: animeId,
  };

  const options = getOptions(query, variables);
  // console.log('Making request with:', {
  //   method: METHOD,
  //   url: GRAPH_QL_URL,
  //   headers,
  //   options
  // });
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Media as Media;
};

/**
 * get aired anime
 *
 * @param viewerId
 * @param airingAt
 * @returns a list of aired anime
 */

export const getAiredAnime = async (
  viewerId: number | null,
  amount: number = PAGES,
  timeOffset: number = 43200,
  airingAt: number = Date.now() / 1000,
  page: number = 1,
) => {
  airingAt = Math.floor(airingAt);
  const airingAfter = Math.floor(airingAt - timeOffset);

  const query = `
  query {
    Page(page: ${page}, perPage: ${amount}) {
      pageInfo {
        hasNextPage
      },
      airingSchedules(airingAt_greater: ${airingAfter}, airingAt_lesser: ${airingAt}) {
        episode,
        timeUntilAiring,
        airingAt,
        media {
          ${MEDIA_DATA}
        }
      }
    }
  }`;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);
  const pageData = respData.data.Page as AiringPage;

  pageData.airingSchedules = pageData.airingSchedules.reverse();

  const adultContent = sessionStorage.getItem('adult_content') as unknown as boolean;
  if (!adultContent)
    pageData.airingSchedules = pageData.airingSchedules.filter((value) => filterAdultMedia(value.media));

  return pageData
};

/**
 * gets airing schedule
 *
 * @param viewerId
 * @returns
 */

export const getAiringSchedule = async (
  viewerId: number | null,
  airingAt: number = Math.floor(Date.now() / 1000)
) => {
  const query = `
  query {
    Page(page: 1, perPage: ${PAGES}) {
      pageInfo {
        hasNextPage
      },
      airingSchedules(airingAt_greater: ${airingAt}) {
        episode,
        timeUntilAiring,
        airingAt,
        media {
          ${MEDIA_DATA}
        }
      }
    }
  }`;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);
  const pageData = respData.data.Page as AiringPage;

  const adultContent = sessionStorage.getItem('adult_content') as unknown as boolean;
  if (!adultContent)
    pageData.airingSchedules = pageData.airingSchedules.filter((value) => filterAdultMedia(value.media));

  return pageData.airingSchedules as AiringSchedule[];
};

/**
 * Gets the current trending animes on anilist
 * pass viewerId to make an authenticated request
 *
 * @param {*} viewerId
 * @returns object with trending animes
 */
export const getTrendingAnime = async (
  viewerId: number | null,
): Promise<TrendingAnime> => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(sort: TRENDING_DESC, type: ANIME) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);
  return respData.data.Page;
};

/**
 * Gets the current most popular animes on anilist
 * pass viewerId to make an authenticated request
 *
 * @param {*} viewerId
 * @returns object with most popular animes
 */
export const getMostPopularAnime = async (
  viewerId: number | null,
): Promise<MostPopularAnime> => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(sort: POPULARITY_DESC, type: ANIME) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Page;
};

/**
 * Gets the next anime releases
 *
 * @returns object with next anime releases
 */
export const getNextReleases = async (viewerId: number | null) => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(status: NOT_YET_RELEASED, sort: POPULARITY_DESC, type: ANIME) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Page;
};

/**
 * Gets searched anime with filters
 *
 * @param {*} args
 * @returns object with the searched filtered anime
 */
export const searchFilteredAnime = async (
  args: string,
  viewerId: number | null,
  page: number = 1
): Promise<AnimeData> => {
  var query = `
      {
          Page(page: ${page}, perPage: 50) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(${args}) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Page;
};

/**
 * Gets the next anime releases
 *
 * @returns object with next anime releases
 */
export const releasingAnimes = async () => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(status: RELEASING, sort: POPULARITY_DESC, type: ANIME) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, HEADERS, options);

  return respData.data.Page;
};

/**
 * Gets the current trending animes filtered by a genre
 * pass viewerId to make an authenticated request
 *
 * @param {*} genre
 * @param {*} viewerId
 * @returns object with animes entries filtered by genre
 */
export const getAnimesByGenre = async (genre: any, viewerId: number | null) => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(genre: "${genre}", sort: TRENDING_DESC, type: ANIME) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Page;
};

/**
 * Gets anime entries from a search query
 *
 * @param {*} input
 * @returns object with searched animes
 */
export const getSearchedAnimes = async (input: any) => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  lastPage
                  hasNextPage
                  perPage
              }
              media(search: "${input}", type: ANIME, sort: SEARCH_MATCH) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, HEADERS, options);

  return respData.data.Page.media;
};

/* MUTATIONS */

/**
 * Updates a media entry list
 *
 * @param mediaId
 * @param status
 * @param scoreRaw
 * @param progress
 * @returns media list entry id
 */
export const updateAnimeFromList = async (
  mediaId: any,
  status?: any,
  scoreRaw?: any,
  progress?: any,
): Promise<number | null> => {
  try {
    var query = `
          mutation($mediaId: Int${progress ? ', $progress: Int' : ''}${scoreRaw ? ', $scoreRaw: Int' : ''}${status ? ', $status: MediaListStatus' : ''}) {
              SaveMediaListEntry(mediaId: $mediaId${progress ? ', progress: $progress' : ''}${scoreRaw ? ', scoreRaw: $scoreRaw' : ''}${status ? ', status: $status' : ''}) {
                  id
              }
          }
      `;

    var headers = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };

    var variables: any = {
      mediaId: mediaId,
    };

    if (status !== undefined) variables.status = status;
    if (scoreRaw !== undefined) variables.scoreRaw = scoreRaw;
    if (progress !== undefined) variables.progress = progress;

    const options = getOptions(query, variables);
    const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

    console.log(
      `Anime list updated (status: ${status},score: ${scoreRaw},progress: ${progress}) for list ${mediaId}`,
    );

    return respData.data.SaveMediaListEntry.id;
  } catch (error) {
    console.log(error);
    return null;
  }
};

export const deleteAnimeFromList = async (id: any): Promise<boolean> => {
  try {
    var query = `
          mutation($id: Int){
              DeleteMediaListEntry(id: $id){
                  deleted
              }
          }
      `;

    console.log('delte: ', id);

    var headers = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };

    var variables = {
      id: id,
    };

    const options = getOptions(query, variables);
    const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

    return respData
  } catch (error) {
    console.log(error);
    return false;
  }
};

/**
 * Updates the progress of an anime on list
 *
 * @param {*} mediaId
 * @param {*} progress
 */
export const updateAnimeProgress = async (
  mediaId: number,
  progress: number,
) => {
  var query = `
          mutation($mediaId: Int, $progress: Int) {
              SaveMediaListEntry(mediaId: $mediaId, progress: $progress) {
                  id
                  progress
              }
          }
      `;

  var headers = {
    Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  var variables = {
    mediaId: mediaId,
    progress: progress,
  };

  const options = getOptions(query, variables);
  await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  console.log(`Progress updated (${progress}) for anime ${mediaId}`);
};

================
File: src/modules/animeCustomTitles.ts
================
/*
    Some anime are difficult to pull automatically, so the
    correct titles for those (I hope rare) exceptions are written here.

    "AnimeId": { title: '`AnimeCustomTitle`', index: 0 } // problem faced

    where title is the anime title and index the element to take
*/

type AnimeCustomTitles = {
    [languageCode: string]: {
      [animeId: string]: {
        title: string;
        index: number;
      };
    };
  };
  
  export const animeCustomTitles: AnimeCustomTitles = {
    US: {
      // '235': { title: `Detective Conan Remastered`, index: 0 },
      '132052': { title: 'Kakkou no Iinazuke', index: 1 }, // same releaseDate with another one
      '168623': { title: 'Dahlia in Bloom', index: 0 }, // anilist has wrong name (Madougushi Dahlia wa Utsumukanai -> Madougushi Dahliya wa Utsumukanai)
    },
    INT: {},
    IT: {},
    ES: {},
    HU: {},
  };

================
File: src/modules/aniskip.ts
================
import { skip } from "node:test";
import { SkipEvent, SkipEventTypes } from "../types/aniskipTypes";
import { makeRequest } from "./requests";

const AniSkip = {
  baseUrl: "https://api.aniskip.com/",
  getSkipEvents: async function(
    malId: number,
    episodeNumber: number,
    episodeLength: number = 0
  ) {
    try {
      const data = await makeRequest('GET', `${this.baseUrl}v2/skip-times/${malId}/${episodeNumber}?types=op&types=ed&types=recap&episodeLength=${Math.floor(episodeLength)}`);

      if(!data.found)
        return [];

      return data.results as SkipEvent[];
    } catch {
      return [];
    }
  },
  getCurrentEvent: function(
    time: number,
    skipEvents: SkipEvent[],
  ) {
    if(!skipEvents || skipEvents.length === 0)
      return;

    for(const skipEvent of skipEvents) {
      const interval = skipEvent.interval;

      if(interval.startTime <= time && interval.endTime > time)
        return skipEvent
    }
  },
  getEventName: function(
    skipEvent: SkipEvent
  ) {
    for(const [name, value] of Object.entries(SkipEventTypes)) {
      if(value !== skipEvent.skipType)
        continue;

      return name;
    }
  }
}


export default AniSkip;

================
File: src/modules/clientData.ts
================
import { ClientData } from "../types/types";

export const clientData = {
  clientId: parseInt(process.env.NEXT_PUBLIC_CLIENT_ID || '0', 10),
  redirectUri: process.env.NEXT_PUBLIC_REDIRECT_URI || '',
  clientSecret: 'SXVsEkfa1hG0br0qC1uQjJCesB3CxjRnfVmq0KSq',
};

================
File: src/modules/history.ts
================
import { History, AnimeHistoryEntry, EpisodeHistoryEntry, HistoryEntries } from "../types/historyTypes";

let history: History = (typeof localStorage !== 'undefined' && localStorage.getItem('history')) ? JSON.parse(localStorage.getItem('history') || '{}') : { entries: {} };

/** * Get the history entry for the anime's id.
 *
 * @param animeId
 * @returns anime history
 */
export const getAnimeHistory = (
  animeId: number
): AnimeHistoryEntry | undefined => history.entries[animeId];

/**
 * Get all entries from local history.
 *
 * @returns history entries
 */
export const getHistoryEntries = (): HistoryEntries => history.entries;

/**
 * Get local history.
 *
 * @returns local history.
 */
export const getHistory = (): History => history;

/**
 * Get history entry for a specific episode
 *
 * @param animeId
 * @param episodeNumber
 * @returns history entry
 */
export const getEpisodeHistory = (
  animeId: number,
  episodeNumber: number
): EpisodeHistoryEntry | undefined => getAnimeHistory(animeId)?.history[episodeNumber]


/**
 * Set local history.
 *
 * @param newHistory
 */
export const setHistory = (
  newHistory: History
) => {
  history = newHistory;
  localStorage.setItem('history', JSON.stringify(newHistory));
}

/**
 * Update the anime's entry
 *
 * @param animeHistory
 */
export const setAnimeHistory = (
  animeHistory: AnimeHistoryEntry
) => {
  const listAnimeData = animeHistory.data;
  const animeId = (listAnimeData.media.id || listAnimeData.media.mediaListEntry && listAnimeData.media.mediaListEntry.id) as number

  history.entries[animeId] = animeHistory;

  localStorage.setItem('history', JSON.stringify(history));
}
/**
 * Get the last watched episode from an anime.
 *
 * @param animeId
 * @returns last watched episode
 */
export const getLastWatchedEpisode = (
  animeId: number
): EpisodeHistoryEntry | undefined => {
  const animeHistory = getAnimeHistory(animeId) as AnimeHistoryEntry;

  if(animeHistory === undefined)
    return;

  return Object.values(animeHistory?.history).reduce((latest, current) => {
    return current.timestamp > latest.timestamp ? current : latest;
  }, Object.values(animeHistory.history)[0]);
}

================
File: src/modules/providers/animedrive.ts
================
import { IVideo } from '@consumet/extensions';
import AnimeDrive from '@consumet/extensions/dist/providers/anime/animedrive';
import ProviderCache from './cache';
import { NextApiRequest, NextApiResponse } from 'next';


export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { type, query } = req.query

  switch(type) {
    case 'search':
      const results = await consumet.search(query as string)
      return res.status(200).json(results)
    
    case 'info':
      const info = await consumet.fetchAnimeInfo(query as string)
      return res.status(200).json(info)
    
    case 'sources':
      const sources = await consumet.fetchEpisodeSources(query as string)
      return res.status(200).json(sources)
  }
}
const cache = new ProviderCache();
const consumet = new AnimeDrive();

export const getEpisodeUrl = async (
  animeTitles: string[],
  index: number,
  episode: number,
  dubbed: boolean,
): Promise<IVideo[] | null> => {
  console.log(
    `%c Episode ${episode}, looking for ${consumet.name} source...`,
    `color: #6b8cff`,
  );

  for (const animeSearch of animeTitles) {
    const result = await searchEpisodeUrl(animeSearch, index, episode, dubbed);
    if (result) {
      return result;
    }
  }

  return null;
};

/**
 * Gets the episode url and isM3U8 flag
 *
 * @param {*} animeSearch
 * @param {*} episode anime episode to look for
 * @param {*} dubbed dubbed version or not
 * @returns IVideo sources if found, null otherwise
 */
async function searchEpisodeUrl(
  animeSearch: string,
  index: number,
  episode: number,
  dubbed: boolean
): Promise<IVideo[] | null> {
  const cacheId = `${animeSearch}-${episode}`;
  if(cache.search[cacheId] !== undefined)
    return cache.search[cacheId];

  const animeId = await getAnimeId(
    dubbed ? 0 : index,
    dubbed ? `${animeSearch} (Dub)` : animeSearch,
  );

  if (animeId) {
    const animeEpisodeId = await getAnimeEpisodeId(animeId, episode);
    if (animeEpisodeId) {
      const data = await consumet.fetchEpisodeSources(animeEpisodeId);

      console.log(`%c ${animeSearch}`, `color: #45AD67`);
      return (
        cache.search[cacheId] = data.sources
      );
    }
  }

  console.log(`%c ${animeSearch}`, `color: #E5A639`);
  return (
    cache.search[cacheId] = null
  );
}

/**
 * Gets the anime id
 *
 * @param {*} animeSearch
 * @returns anime id if found, otherwise null
 */
export const getAnimeId = async (
  index: number,
  animeSearch: string,
): Promise<string | null> => {
  if(cache.animeIds[animeSearch] !== undefined)
    return cache.animeIds[animeSearch];

  const data = await consumet.search(animeSearch);
  return (
    cache.animeIds[animeSearch] = data.results[index]?.id ?? null
  );
};

/**
 * Gets the anime episode id
 *
 * @param {*} animeId
 * @param {*} episode
 * @returns anime episode id if found, otherwise null
 */
export const getAnimeEpisodeId = async (
  animeId: string,
  episode: number,
): Promise<string | null> => {
  if(cache.episodes[animeId] !== undefined) {
    const found = cache.episodes[animeId]?.find((ep) => ep.number == episode)

    if(found)
      return found.id;
  }

  const data = await consumet.fetchAnimeInfo(animeId);
  return (
    cache.episodes[animeId] = data?.episodes
  )?.[episode - 1]?.id ?? null;
};

================
File: src/modules/providers/animesaturn.ts
================
import { IVideo } from '@consumet/extensions';
import AnimeSaturn from '@consumet/extensions/dist/providers/anime/animesaturn';

const consumet = new AnimeSaturn();

/**
 * 
 * @param animeTitles 
 * @param episode 
 * @param dubbed 
 * @returns 
 */
export const getEpisodeUrl = async (
  animeTitles: string[],
  episode: number,
  dubbed: boolean,
): Promise<IVideo | null> => {
  console.log(`%c Episode ${episode}, looking for ${consumet.name} source...`, `color: #6b8cff`);

  for (const animeSearch of animeTitles) {
    const result = await searchEpisodeUrl(animeSearch, episode, dubbed);
    if (result) {
      return result;
    }
  }

  return null;
}

/**
 * Gets the episode url and isM3U8 flag
 *
 * @param {*} animeTitles array of anime titles
 * @param {*} episode anime episode to look for
 * @param {*} dubbed dubbed version or not
 * @returns consumet IVideo if url is found, otherwise null
 */
async function searchEpisodeUrl(animeSearch: string, episode: number, dubbed: boolean): Promise<IVideo | null> {
  const animeId = await getAnimeId(dubbed ? `${animeSearch} (ITA)` : animeSearch);

  if (animeId) {
    const animeEpisodeId = await getAnimeEpisodeId(animeId, episode);
    if (animeEpisodeId) {
      const data = await consumet.fetchEpisodeSources(animeEpisodeId);
      console.log(`%c ${animeSearch}`, `color: #45AD67`);
      return data.sources[1]; // [1] is streamtape
    }
  }

  console.log(`%c ${animeSearch}`, `color: #E5A639`);
  return null;
}

/**
 * Gets the anime id
 *
 * @param {*} animeSearch
 * @returns anime id if found, otherwise null
 */
export const getAnimeId = async (
  animeSearch: string,
): Promise<string | null> => {
  const data = await consumet.search(animeSearch);
  return data.results[0]?.id ?? null;
};

/**
 * Gets the anime episode id
 *
 * @param {*} animeId
 * @param {*} episode
 * @returns anime episode id if found, otherwise null
 */
export const getAnimeEpisodeId = async (
  animeId: string,
  episode: number,
): Promise<string | null> => {
  const data = await consumet.fetchAnimeInfo(animeId);
  return data?.episodes?.[episode - 1]?.id ?? null;
};

================
File: src/modules/providers/animeunity.ts
================
import { IVideo } from '@consumet/extensions';
import AnimeUnity from '@consumet/extensions/dist/providers/anime/animeunity';
import ProviderCache from './cache';
import { getCacheId } from '../utils';
import { NextApiRequest, NextApiResponse } from 'next';

const consumet = new AnimeUnity();
const cache = new ProviderCache();

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { type, query } = req.query

  switch(type) {
    case 'search':
      const results = await consumet.search(query as string)
      return res.status(200).json(results)
    
    case 'info':
      const info = await consumet.fetchAnimeInfo(query as string)
      return res.status(200).json(info)
    
    case 'sources':
      const sources = await consumet.fetchEpisodeSources(query as string)
      return res.status(200).json(sources)
  }
}


/**
 *
 * @param animeTitles
 * @param episode
 * @param dubbed
 * @returns
 */
export const getEpisodeUrl = async (
  animeTitles: string[],
  index: number,
  episode: number,
  dubbed: boolean,
  releaseDate: number,
): Promise<IVideo[] | null> => {
  console.log(
    `%c Episode ${episode}, looking for ${consumet.name} source...`,
    `color: #0c7475`,
  );

  for (const animeSearch of animeTitles) {
    const result = await searchEpisodeUrl(
      animeSearch,
      index,
      episode,
      dubbed,
      releaseDate,
    );
    if (result) {
      return result;
    }
  }

  return null;
};

/**
 * Gets the episode url and isM3U8 flag
 *
 * @param {*} animeSearch
 * @param {*} episode anime episode to look for
 * @param {*} dubbed dubbed version or not
 * @returns consumet IVideo if url is found, otherwise null
 */
async function searchEpisodeUrl(
  animeSearch: string,
  index: number,
  episode: number,
  dubbed: boolean,
  releaseDate: number,
): Promise<IVideo[] | null> {
  const cacheId = getCacheId(animeSearch, episode, dubbed);

  if(cache.search[cacheId] !== undefined)
    return cache.search[cacheId];

  const animeId = await getAnimeId(
    index,
    dubbed ? `${animeSearch} (ITA)` : animeSearch,
    dubbed,
    releaseDate,
  );

  if (animeId) {
    const animeEpisodeId = await getAnimeEpisodeId(animeId, episode);
    if (animeEpisodeId) {
      const data = await consumet.fetchEpisodeSources(animeEpisodeId);
      console.log(`%c ${animeSearch}`, `color: #45AD67`);

      return (
        cache.search[cacheId] = data.sources
      );
    }
  }

  console.log(`%c ${animeSearch}`, `color: #E5A639`);
  return (
    cache.search[cacheId] = null
  );
}

/**
 * Gets the anime id
 *
 * @param {*} animeSearch
 * @returns anime id if found, otherwise null
 */
export const getAnimeId = async (
  index: number,
  animeSearch: string,
  dubbed: boolean,
  releaseDate: number,
): Promise<string | null> => {
  if(cache.animeIds[animeSearch] !== undefined)
    return cache.animeIds[animeSearch];

  const data = await consumet.search(animeSearch);

  const filteredResults = data.results.filter((result) =>
    dubbed
      ? (result.title as string).includes('(ITA)')
      : !(result.title as string).includes('(ITA)'),
  );

  return (
    cache.animeIds[animeSearch] = filteredResults.filter(
      (result) => result.releaseDate == releaseDate.toString(),
    )[index]?.id ?? null
  );
  // return data.results[index]?.id ?? null;
};

/**
 * Gets the anime episode id
 *
 * @param {*} animeId
 * @param {*} episode
 * @returns anime episode id if found, otherwise null
 */
export const getAnimeEpisodeId = async (
  animeId: string,
  episode: number,
): Promise<string | null> => {
  if(cache.episodes[animeId] !== undefined) {
    const found = cache.episodes[animeId]?.find((ep) => ep.number == episode)

    if(found)
      return found.id;
  }
  const data = await consumet.fetchAnimeInfo(
    animeId,
    episode > 120 ? Math.floor(episode / 120) + 1 : 1,
  );

  return (
    cache.episodes[animeId] = data?.episodes
  )?.find((ep) => ep.number == episode)?.id ?? null;
};

================
File: src/modules/providers/api.ts
================
import { IVideo } from '@consumet/extensions';
import { ListAnimeData } from '@/types/anilistAPITypes';
import { animeCustomTitles } from '../animeCustomTitles';
import { getAvailableEpisodes, getParsedAnimeTitles } from '../utils';
import { getEpisodeUrl as gogoanime } from './gogoanime';
import { getEpisodeUrl as hianime } from './hianime';
import { CachedLink } from '@/components/shared/cached-links'

const API_BASE = '/api/anime'


export const fetchFromProvider = async (provider: string, type: string, query: string) => {
  const response = await fetch(`${API_BASE}/${provider}?type=${type}&query=${encodeURIComponent(query)}`)
  return response.json()
}

export const getUniversalEpisodeUrl = async (
  listAnimeData: ListAnimeData,
  episode: number,
): Promise<IVideo[] | null> => {
  const lang = localStorage.getItem('source_flag') || 'INT';
  const dubbed = localStorage.getItem('dubbed') === 'true';
  const customTitle = animeCustomTitles[lang] && animeCustomTitles[lang][listAnimeData.media?.id!];
  const animeTitles = getParsedAnimeTitles(listAnimeData.media);
  
  if (customTitle) {
    animeTitles.unshift(customTitle.title);
  }

  const providers = [
    {
      name: 'Gogoanime',
      fetch: async () => {
        const sources = await gogoanime(
          animeTitles, 
          customTitle?.index || 0, 
          episode, 
          dubbed, 
          listAnimeData.media.startDate?.year ?? 0
        );
        
        // Preload next chunk while current is playing
        if (sources?.[0]?.url) {
          sources.forEach(source => {
            const preloadLink = document.createElement('link');
            preloadLink.rel = 'preload';
            preloadLink.as = 'fetch';
            preloadLink.href = source.url;
            document.head.appendChild(preloadLink);
          });
        }

        // if (episode < totalEpisodes) {
        //   getUniversalEpisodeUrl(listAnimeData, episode + 1);
        // }
        
        return sources?.sort((a, b) => {
          const qualityA = parseInt(a.quality?.replace('p', '') ?? '0');
          const qualityB = parseInt(b.quality?.replace('p', '') ?? '0');
          return qualityB - qualityA;
        });
      }
    },

  ];


  for (const provider of providers) {
    try {
      const sources = await provider.fetch();
      if (sources && sources.length > 0) {
        console.log(`Found ${sources.length} quality options from ${provider.name}`);
        return sources;
      }
    } catch (error) {
      console.error(`Failed to fetch from ${provider.name}:`, error);
      continue;
    }
  }

  return null;
}


export const getBestQualityVideo = (videos: IVideo[]): IVideo => {
  const qualityOrder = ['1080p', '720p', '480p', '360p', 'default', 'backup'];

  videos.sort((a, b) => {
    const indexA = qualityOrder.indexOf(a.quality || 'default');
    const indexB = qualityOrder.indexOf(b.quality || 'default');

    if (indexA < indexB) return -1;
    if (indexA > indexB) return 1;
    return 0;
  });

  return videos[0];
};

================
File: src/modules/providers/cache.ts
================
import { IVideo, IAnimeEpisode } from "@consumet/extensions"

export default class ProviderCache {
  search: { [key: string]:  IVideo[] | null};
  animeIds: { [key: string]: string | null};
  episodes: { [key: string]: IAnimeEpisode[] | undefined };

  constructor() {
    this.search = {};
    this.animeIds = {};
    this.episodes = {};
  }
}

================
File: src/modules/providers/gogoanime.ts
================
import { IVideo } from '@consumet/extensions';
import Gogoanime from '@consumet/extensions/dist/providers/anime/gogoanime';
import ProviderCache from './cache';
import { getCacheId, proxyRequest } from '../utils';
import { NextApiRequest, NextApiResponse } from 'next';

const cache = new ProviderCache();
const consumet = new Gogoanime();


export const getEpisodeUrl = async (
  animeTitles: string[],
  index: number,
  episode: number,
  dubbed: boolean,
  releaseDate: number,
): Promise<IVideo[] | null> => {
  console.log(
    `%c Episode ${episode}, looking for ${consumet.name} source...`,
    `color: #ffc119`,
  );

  for (const animeSearch of animeTitles) {
    const result = await searchEpisodeUrl(
      animeSearch,
      index,
      episode,
      dubbed,
      releaseDate,
    );
    if (result) {
      return result;
    }
  }

  return null;
};

/**
 * Gets the episode url and isM3U8 flag
 *
 * @param {*} animeSearch
 * @param {*} episode anime episode to look for
 * @param {*} dubbed dubbed version or not
 * @returns IVideo sources if found, null otherwise
 */
async function searchEpisodeUrl(
  animeSearch: string,
  index: number,
  episode: number,
  dubbed: boolean,
  releaseDate: number,
): Promise<IVideo[] | null> {
  const cacheId = getCacheId(animeSearch, episode, dubbed);

  if(cache.search[cacheId] !== undefined)
    return cache.search[cacheId];

  try {
    const animeId = await getAnimeId(
      index,
      dubbed ? `${animeSearch} (Dub)` : animeSearch,
      dubbed,
      releaseDate,
    );

    if (animeId) {
      const animeEpisodeId = await getAnimeEpisodeId(animeId, episode);
      if (animeEpisodeId) {
        // Request all qualities
        const [gogocdn, streamsb, vidstreaming] = await Promise.all([
          proxyRequest(`https://apiconsumet-gamma.vercel.app/anime/gogoanime/watch/${animeEpisodeId}?server=gogocdn`),
          proxyRequest(`https://apiconsumet-gamma.vercel.app/anime/gogoanime/watch/${animeEpisodeId}?server=streamsb`),
          proxyRequest(`https://apiconsumet-gamma.vercel.app/anime/gogoanime/watch/${animeEpisodeId}?server=vidstreaming`)
        ]);

        const sources = [
          ...(gogocdn?.sources || []),
          ...(streamsb?.sources || []),
          ...(vidstreaming?.sources || [])
        ];

        console.log(`Found sources for ${animeSearch}:`, sources);
        return (cache.search[cacheId] = sources);
      }
    }
  } catch (error) {
    console.error("Error fetching episode:", error);
    return null;
  }

  return (cache.search[cacheId] = null);
}




/**
 * Gets the anime id
 *
 * @param {*} animeSearch
 * @returns anime id if found, otherwise null
 */
export const getAnimeId = async (
  index: number,
  animeSearch: string,
  dubbed: boolean,
  releaseDate: number,
): Promise<string | null> => {
  if(cache.animeIds[animeSearch] !== undefined)
    return cache.animeIds[animeSearch];

  const data = await proxyRequest(`https://apiconsumet-gamma.vercel.app/anime/gogoanime/${animeSearch}?page=1`);

  const filteredResults = data.results.filter((result: { title: string; }) =>
    dubbed
      ? (result.title as string).includes('(Dub)')
      : !(result.title as string).includes('(Dub)'),
  );

  const result = (
    cache.animeIds[animeSearch] = filteredResults.filter(
      (result: { releaseDate: string; title: string; }) => result.releaseDate == releaseDate.toString() ||
        result.title == animeSearch,
    )[index]?.id ?? null
  );

  return result;
};

/**
 * Gets the anime episode id
 *
 * @param {*} animeId
 * @param {*} episode
 * @returns anime episode id if found, otherwise null
 */
export const getAnimeEpisodeId = async (
  animeId: string,
  episode: number,
): Promise<string | null> => {
  if(cache.episodes[animeId] !== undefined) {
    const found = cache.episodes[animeId]?.find((ep) => ep.number == episode)

    if(found)
      return found.id;
  }

  const data = await proxyRequest(`https://apiconsumet-gamma.vercel.app/anime/gogoanime/info/${animeId}`);
  return (
    cache.episodes[animeId] = data?.episodes
  )?.find((ep: { number: number; }) => ep.number == episode)?.id ?? null;
};

================
File: src/modules/providers/hianime.ts
================
import { IVideo } from '@consumet/extensions';
import ProviderCache from './cache';
import Zoro from '@consumet/extensions/dist/providers/anime/zoro';
import axios from 'axios';
import { getCacheId } from '../utils';

const cache = new ProviderCache();
const consumet = new Zoro();
const apiUrl = 'https://aniwatch-api-ch0nker.vercel.app'
import { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { type, query, episode } = req.query

  switch(type) {
    case 'search':
      const results = await consumet.search(query as string)
      return res.status(200).json(results)
    
    case 'info':
      const info = await consumet.fetchAnimeInfo(query as string)
      return res.status(200).json(info)
    
    case 'sources':
      const sources = await consumet.fetchEpisodeSources(query as string)
      return res.status(200).json(sources)
  }
}
export const getEpisodeUrl = async (
animeTitles: string[], index: number, episode: number, dubbed: boolean, p0: number,
): Promise<IVideo[] | null> => {
  console.log('HiAnime search params:', {
    titles: animeTitles,
    index,
    episode,
    dubbed
  });

  for (const animeSearch of animeTitles) {
    const result = await searchEpisodeUrl(
      animeSearch,
      index,
      episode,
      dubbed
    );
    if (result) {
      console.log('HiAnime found source:', result);
      return result;
    }
  }

  return null;
};

/**
 * Gets the episode url and isM3U8 flag
 *
 * @param {*} animeSearch
 * @param {*} episode anime episode to look for
 * @param {*} dubbed dubbed version or not
 * @returns IVideo sources if found, null otherwise
 */
async function searchEpisodeUrl(
  animeSearch: string,
  index: number,
  episode: number,
  dubbed: boolean,
): Promise<IVideo[] | null> {
  const cacheId = getCacheId(animeSearch, episode, dubbed);

  if(cache.search[cacheId] !== undefined)
    return cache.search[cacheId];

  const animeId = await getAnimeId(
    index,
    dubbed ? `${animeSearch} (Dub)` : animeSearch,
    dubbed,
  );

  if (animeId) {
    const animeEpisodeId = await getAnimeEpisodeId(animeId, episode);
    console.log('episodeId',animeEpisodeId)
    if (animeEpisodeId) {
      try {
        const data = await consumet.fetchEpisodeSources(animeEpisodeId);
        console.log(`%c ${animeSearch}`, `color: #45AD67`);
        return (
          cache.search[cacheId] = data.sources.map((value) => {
              value.tracks = data.subtitles;
              value.skipEvents = {
                intro: data.intro,
                outro: data.outro
              };

              return value;
          }) ?? null
        );
      } catch {
        /* consumet fails to get raw servers so this needed. damn */
        const episodeId = animeEpisodeId.replace('$episode$', '?ep=').split('$')[0];

        const servers = (await axios.get(
          `${apiUrl}/anime/servers?episodeId=${episodeId}`
        )).data;
        const episodeInfo = await axios.get(
          `${apiUrl}/anime/episode-srcs?id=${episodeId}&server=hd-1&category=${dubbed ?
            'dub' :
            servers.sub.length > 0 ? 'sub' : 'raw'
          }`
        );

        return (
          cache.search[cacheId] = (episodeInfo.data.sources as IVideo[]).map((value) => {
              value.tracks = (episodeInfo.data.tracks as any[]).map(value => ({
                url: value.file,
                lang: value.label
              }));

              value.skipEvents = {
                intro: episodeInfo.data.intro,
                outro: episodeInfo.data.outro
              };

              console.log(value.tracks)

              return value;
          }) ?? null
        )
      }
    }
  }

  cache.search[cacheId] = null;
  console.log(`%c ${animeSearch}`, `color: #E5A639`);
  return null;
}

/**
 * Gets the anime id
 *
 * @param {*} animeSearch
 * @returns anime id if found, otherwise null
 */
export const getAnimeId = async (
  index: number,
  animeSearch: string,
  dubbed: boolean,
): Promise<string | null> => {
  if(cache.animeIds[animeSearch] !== undefined)
    return cache.animeIds[animeSearch];

  const data = await consumet.search(animeSearch);

  const filteredResults = data.results.filter((result) =>
    dubbed
      ? (result.title as string).includes('(Dub)')
      : !(result.title as string).includes('(Dub)'),
  );

  const normalizedSearch = animeSearch.toLowerCase();

  const result = (
    cache.animeIds[animeSearch] = filteredResults.filter(
      result =>
        (result.title.toString()).toLowerCase() === normalizedSearch ||
        (result.japaneseTitle.toString()).toLowerCase() === normalizedSearch
    )[index]?.id ?? null
  );

  return result;
};




/**
 * Gets the anime episode id
 *
 * @param {*} animeId
 * @param {*} episode
 * @returns anime episode id if found, otherwise null
 */
export const getAnimeEpisodeId = async (
  animeId: string,
  episode: number,
): Promise<string | null> => {
  if(cache.episodes[animeId] !== undefined) {
    const found = cache.episodes[animeId]?.find((ep) => ep.number == episode)

    if(found)
      return found.id;
  }

  const data = await consumet.fetchAnimeInfo(animeId);
  return (
    cache.episodes[animeId] = data?.episodes
  )?.find((ep) => ep.number == episode)?.id ?? null;
};

================
File: src/modules/providers/monoschinos.ts
================
// import { IVideo } from '@consumet/extensions';
// import MonosChinos from '@consumet/extensions/dist/providers/anime/monoschinos';

// import ProviderCache from './cache';

// const consumet = new MonosChinos()

// const cache = new ProviderCache();

// export const getEpisodeUrl = async (
//   animeTitles: string[],
//   index: number,
//   episode: number,
//   dubbed: boolean,
//   releaseDate: number,
//   totalEpisodes?: number
// ): Promise<IVideo[] | null> => {
//   console.log(
//     `%c Episode ${episode}, looking for ${consumet.name} source...`,
//     `color: #e70071`,
//   );

//   // all broken
//   return null 

//   // dubbed is not implemented :(
//   if (dubbed) return null

//   for (const animeSearch of animeTitles) {
//     const result = await searchEpisodeUrl(
//       animeSearch,
//       index,
//       episode,
//       dubbed,
//       releaseDate,
//       totalEpisodes
//     );
//     if (result) {
//       return result;
//     }
//   }

//   return null;
// };

// /**
//  * Gets the episode url and isM3U8 flag
//  *
//  * @param {*} animeSearch
//  * @param {*} episode anime episode to look for
//  * @param {*} dubbed dubbed version or not
//  * @returns IVideo sources if found, null otherwise
//  */
// async function searchEpisodeUrl(
//   animeSearch: string,
//   index: number,
//   episode: number,
//   dubbed: boolean,
//   releaseDate: number,
//   totalEpisodes?: number
// ): Promise<IVideo[] | null> {
//   const cacheId = `${animeSearch}-${episode}`;

//   if(cache.search[cacheId] !== undefined)
//     return cache.search[cacheId];

//   const animeId = await getAnimeId(
//     index,
//     dubbed ? `${animeSearch} (???????)` : animeSearch,
//     dubbed,
//     releaseDate,
//   );

//   if (animeId) {
//     const animeEpisodeId = await getAnimeEpisodeId(animeId, episode, totalEpisodes);
//     if (animeEpisodeId) {
//       const data = await consumet.fetchEpisodeSources(animeEpisodeId);
//       console.log(`%c ${animeSearch}`, `color: #45AD67`);
//       const result = (
//         cache.search[cacheId] = data.sources
//       );
//       return result;
//     }
//   }

//   cache.search[cacheId] = null;
//   console.log(`%c ${animeSearch}`, `color: #E5A639`);
//   return null;
// }

// /**
//  * Gets the anime id
//  *
//  * @param {*} animeSearch
//  * @returns anime id if found, otherwise null
//  */
// export const getAnimeId = async (
//   index: number,
//   animeSearch: string,
//   dubbed: boolean,
//   releaseDate: number,
// ): Promise<string | null> => {
//   if(cache.animeIds[animeSearch] !== undefined)
//     return cache.animeIds[animeSearch];

//   const data = await consumet.search(animeSearch);

//   const filteredResults = data.results.filter((result) =>
//     dubbed
//       ? (result.title as string).includes('(Dub)')
//       : !(result.title as string).includes('(Dub)'),
//   );

//   const result = (
//     cache.animeIds[animeSearch] = filteredResults.filter(
//       (result) => result.releaseDate == releaseDate.toString() ||
//         result.title == animeSearch,
//     )[index]?.id ?? null
//   );

//   return result;
// };

// /**
//  * Gets the anime episode id
//  *
//  * @param {*} animeId
//  * @param {*} episode
//  * @returns anime episode id if found, otherwise null
//  */
// export const getAnimeEpisodeId = async (
//   animeId: string,
//   episode: number,
//   totalEpisodes?: number
// ): Promise<string | null> => {
//   if(cache.episodes[animeId] !== undefined) {
//     const found = cache.episodes[animeId]?.find((ep) => ep.number == episode)

//     if(found)
//       return found.id;
//   }

//   const data = await consumet.fetchAnimeInfo(animeId, totalEpisodes);
//   return (
//     cache.episodes[animeId] = data?.episodes
//   )?.find((ep) => ep.number == episode)?.id ?? null;
// };

================
File: src/modules/requests.ts
================
import axios from 'axios';

var remainingRequests = 90;
var resetTime = 0;
var lockUntil = 0;

const delay = async (seconds: number) => new Promise((resolve) => setTimeout(resolve, seconds * 1000));

const handleRateLimiting = async (current: number) => {
  if (current < lockUntil)
    await delay(lockUntil - current);

  if (current >= resetTime)
    remainingRequests = 90;

  if (remainingRequests <= 0)
    await delay(60);
};

const handleResponseHeaders = (headers: any) => {
  if (headers['x-ratelimit-remaining'])
    remainingRequests = parseInt(headers['x-ratelimit-remaining']);

  if (headers['x-ratelimit-reset'])
    resetTime = parseInt(headers['x-ratelimit-reset']);
};

/**
 * Builds the data options for the request
 *
 * @param {*} query
 * @param {*} variables
 * @returns object with the data options
 */
export const getOptions = (query: any = {}, variables: any = {}) => {
  return JSON.stringify({
    query: query,
    variables: variables,
  });
};

/**
 * Makes a Promise based HTTP request with Axios
 *
 * @param {*} method
 * @param {*} url
 * @param {*} headers
 * @param {*} options
 * @returns object with the fetched data
 * @throws error if the request was not successful
 */

export const makeRequest = async (
  method: 'GET' | 'POST' | string,
  url: string,
  headers: any = {},
  options: any = {},
): Promise<any> => {
  if (url === 'https://graphql.anilist.co') {
    const current = Date.now() / 1000;

    await handleRateLimiting(current);

    try {
      const response = await axios({
        method: method,
        url: url,
        headers: headers,
        data: options,
      });

      handleResponseHeaders(response.headers);

      return response.data;
    } catch (error) {
      let response = (error as { response?: { status: number, headers: { [key: string]: any } } }).response;

      if (response && response.status === 429) {
        const retryAfter = parseInt(response.headers['retry-after'] || '60');
        lockUntil = current + retryAfter;
        await delay(retryAfter);
        return makeRequest(method, url, headers, options);
      }

      throw error;
    }
  }

  const response = await axios({
    method: method,
    url: url,
    headers: headers,
    data: options,
  });

  return response.data;
};

================
File: src/modules/utils.ts
================
import { Media } from "@/types/anilistGraphQLTypes";

export async function proxyRequest(url: string, method: string = 'GET', headers: object = {}, data?: any) {
  const response = await fetch('/api/anime/proxy', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      url,
      method,
      headers,
      data
    })
  });
  return response.json();
}

export function getParsedAnimeTitles(media: Media): string[] {
  const titles: string[] = [];

  // Add all available titles
  if (media.title?.english) titles.push(media.title.english);
  if (media.title?.romaji) titles.push(media.title.romaji);
  if (media.title?.native) titles.push(media.title.native);
  
  // Add synonyms if available
  if (media.synonyms) {
    titles.push(...media.synonyms);
  }

  // Clean and normalize titles
  return titles
    .filter(Boolean) // Remove empty/null values
    .map(title => title.trim())
    .filter((title, index, self) => self.indexOf(title) === index); // Remove duplicates
}

export function formatTime(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const remainingSeconds = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
  }
  return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
}

export function getCacheId(
  animeSearch: string,
  episode: number,
  dubbed: boolean,
): string {
  return `${animeSearch}-${episode}-${dubbed ? 'dub' : 'sub'}`;
}

export function getAvailableEpisodes(media: Media): number | null {
  if (media.episodes != null) {
    return media.episodes;
  }
  
  if (media.nextAiringEpisode != null) {
    return media.nextAiringEpisode.episode - 1;
  }

  if (media.airingSchedule?.edges?.[0]?.node?.episode) {
    return media.airingSchedule.edges[0].node.episode;
  }

  return null;
}

export function formatDate(date: string | number): string {
  return new Date(date).toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
}

export function formatNumber(num: number): string {
  return new Intl.NumberFormat("en-US", {
    notation: "compact",
    maximumFractionDigits: 1,
  }).format(num);
}

================
File: src/pages/api/anime/[provider]/[...params].ts
================
import { NextApiRequest, NextApiResponse } from 'next';
import Gogoanime from '@consumet/extensions/dist/providers/anime/gogoanime';

const consumet = new Gogoanime();

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { provider, params } = req.query;
  
  if (provider === 'gogoanime' && Array.isArray(params)) {
    try {
      switch(params[0]) {
        case 'search':
          const results = await consumet.search(params[1]);
          return res.status(200).json(results);
        
        case 'info':
          const info = await consumet.fetchAnimeInfo(params[1]);
          return res.status(200).json(info);
        
        case 'watch':
          const sources = await consumet.fetchEpisodeSources(params[1]);
          return res.status(200).json(sources);
      }
    } catch (error) {
      return res.status(500).json({ error: 'Failed to fetch data' });
    }
  }

  return res.status(404).json({ error: 'Provider not found' });
}

================
File: src/pages/api/anime/proxy.ts
================
import { NextApiRequest, NextApiResponse } from 'next';
import axios from 'axios';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method === 'OPTIONS') {
      res.setHeader('Access-Control-Allow-Credentials', 'true');
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
      res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
      res.setHeader('Access-Control-Max-Age', '86400');
      return res.status(200).end();
    }
  
    if (req.method !== 'POST') {
      return res.status(405).json({ error: 'Method not allowed' });
    }
  
    const { url, method = 'GET', headers = {}, data } = req.body;
    
    try {
      const response = await axios({
        url,
        method,
        headers: {
          ...headers,
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
          'Accept': 'application/json, text/plain, */*',
          'Accept-Language': 'en-US,en;q=0.9',
          'Origin': process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',
          'Referer': process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'
        },
        data, // Include the request data
        validateStatus: (status) => status < 500
      });
  
      res.setHeader('Access-Control-Allow-Credentials', 'true');
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
      res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
      
      res.status(response.status).json(response.data);
    } catch (error) {
      console.error('Proxy error:', error);
      res.status(500).json({ 
        error: 'Proxy request failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }

================
File: src/services/auth.ts
================
import { getAccessToken, getViewerId, getViewerInfo, getViewerLists } from "@/modules/anilist/anilistsAPI";
import type { MediaListStatus } from "@/types/anilistGraphQLTypes";

export interface UserData {
  id: number;
  name: string;
  avatar?: {
    medium?: string;
  };
}

export interface AuthResponse {
  success: boolean;
  error?: string;
  userData?: UserData;
  lists?: Array<{
    id: number | null;
    mediaId: number | null;
    progress?: number | null;
    media: {
      id: number;
      title: {
        english?: string;
        romaji?: string;
      };
      coverImage?: {
        large?: string;
      };
    };
  }>;
}

export async function handleAuthentication(token: string): Promise<AuthResponse> {
  try {
    // Get access token
    const accessToken = await getAccessToken(token);
    if (!accessToken) {
      return { success: false, error: "Failed to obtain access token" };
    }

    // Store access token
    if (typeof window !== 'undefined') {
      sessionStorage.setItem('access_token', accessToken);
    }
    
    // Get user ID
    const id = await getViewerId();
    if (!id) {
      return { success: false, error: "Failed to obtain user ID" };
    }

    // Store user ID
    if (typeof window !== 'undefined') {
      sessionStorage.setItem('viewer_id', id.toString());
    }
    
    // Get user data
    const userData = await getViewerInfo(id);
    if (!userData) {
      return { success: false, error: "Failed to fetch user data" };
    }

    // Get user lists
    const lists = await getViewerLists(
      id, 
      'CURRENT' as MediaListStatus,
      'REPEATING' as MediaListStatus,
      'PAUSED' as MediaListStatus
    );

    // Store lists
    if (typeof window !== 'undefined' && lists) {
      const serializedLists = lists.map(item => ({
        id: item.id,
        mediaId: item.mediaId,
        progress: item.progress,
        media: {
          id: item.media.id,
          title: {
            english: item.media.title?.english,
            romaji: item.media.title?.romaji
          },
          coverImage: {
            large: item.media.coverImage?.large
          }
        }
      }));
      sessionStorage.setItem("anime_lists", JSON.stringify(serializedLists));
    }

    return {
      success: true,
      userData: {
        id: userData.id,
        name: userData.name,
        avatar: {
          medium: userData.avatar?.medium
        }
      },
      lists
    };
  } catch (error) {
    console.error('Authentication error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Authentication failed"
    };
  }
}

export function clearAuthData(): void {
  if (typeof window !== 'undefined') {
    sessionStorage.removeItem("access_token");
    sessionStorage.removeItem("viewer_id");
    sessionStorage.removeItem("anime_lists");
  }
}

================
File: src/types/auth.ts
================
export interface UserProfile {
  id: number;
  name: string;
  avatar?: {
    medium?: string;
  };
}

export interface AnimeListEntry {
  status: string;
  id: number | null;
  mediaId: number | null;
  progress: number | null;
  media: {
    genres: any;
    id: number;
    title: {
      english?: string;
      romaji?: string;
    };
    coverImage?: {
      large?: string;
    };
    episodes?: number;
    status?: string;
  };
}

export interface AuthState {
  isAuthenticated: boolean;
  user: UserProfile | null;
  lists: AnimeListEntry[];
  isLoading: boolean;
  error: string | null;
}

export interface AuthResponse {
  success: boolean;
  user?: UserProfile;
  lists?: AnimeListEntry[];
  error?: string;
}

================
File: src/types/search.ts
================
export interface SearchFilters {
  query?: string;
  genres?: string[];
  seasons?: string[];
  year?: string;
  format?: string;
  sort?: string;
}

export interface SearchState extends SearchFilters {
  page: number;
  hasMore: boolean;
  isLoading: boolean;
  error: string | null;
}

================
File: src/types/watchlist.ts
================
export type WatchStatus = "watching" | "completed" | "on_hold" | "dropped" | "plan_to_watch";

export interface WatchlistEntry {
  id: number;
  status: WatchStatus;
  progress: number;
  score?: number;
  media: {
    id: number;
    title: {
      english?: string;
      romaji?: string;
    };
    coverImage?: {
      large?: string;
    };
    episodes?: number;
    genres?: string[];
  };
  updatedAt: number;
}

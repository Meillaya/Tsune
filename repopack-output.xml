This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-03T22:55:33.108Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</file_summary>

<repository_structure>
src/app/anime/[id]/page.tsx
src/app/auth/callback/AuthCallbackContent.tsx
src/app/auth/callback/AuthCallbackHandler.tsx
src/app/auth/callback/page.tsx
src/app/auth/token/route.tsx
src/app/layout.tsx
src/app/library/page.tsx
src/app/page.tsx
src/app/popular/page.tsx
src/app/search/page.tsx
src/app/stats/page.tsx
src/app/trending/page.tsx
src/app/watch/[animeId]/[episodeId]/error.tsx
src/app/watch/[animeId]/[episodeId]/layout.tsx
src/app/watch/[animeId]/[episodeId]/loading.tsx
src/app/watch/[animeId]/[episodeId]/page.tsx
src/app/watch/[animeId]/[episodeId]/WatchPageContent.tsx
src/app/watchlist/page.tsx
src/components/anime-details.tsx
src/components/anime-grid.tsx
src/components/anime-section.tsx
src/components/anime-tabs.tsx
src/components/auth/login-dialog.tsx
src/components/ContinueWatchingSection.tsx
src/components/episode-list.tsx
src/components/episode-navigation.tsx
src/components/featured-carousel.tsx
src/components/hero-section.tsx
src/components/library/my-list-section.tsx
src/components/loading-spinner.tsx
src/components/main-content.tsx
src/components/navbar.tsx
src/components/providers/query-provider.tsx
src/components/search-command.tsx
src/components/search-content.tsx
src/components/search/search-bar.tsx
src/components/search/search-filters.tsx
src/components/search/search-results.tsx
src/components/shared/cached-images.tsx
src/components/shared/cached-links.tsx
src/components/stats/genre-distribution.tsx
src/components/stats/rating-distribution.tsx
src/components/stats/stats-overview.tsx
src/components/stats/watch-history.tsx
src/components/theme-provider.tsx
src/components/ui/accordion.tsx
src/components/ui/alert-dialog.tsx
src/components/ui/alert.tsx
src/components/ui/aspect-ratio.tsx
src/components/ui/avatar.tsx
src/components/ui/badge.tsx
src/components/ui/breadcrumb.tsx
src/components/ui/button.tsx
src/components/ui/calendar.tsx
src/components/ui/card.tsx
src/components/ui/carousel.tsx
src/components/ui/chart.tsx
src/components/ui/checkbox.tsx
src/components/ui/collapsible.tsx
src/components/ui/command.tsx
src/components/ui/context-menu.tsx
src/components/ui/dialog.tsx
src/components/ui/drawer.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/form.tsx
src/components/ui/hover-card.tsx
src/components/ui/input-otp.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/menubar.tsx
src/components/ui/navigation-menu.tsx
src/components/ui/pagination.tsx
src/components/ui/popover.tsx
src/components/ui/progress.tsx
src/components/ui/radio-group.tsx
src/components/ui/resizable.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/separator.tsx
src/components/ui/sheet.tsx
src/components/ui/skeleton.tsx
src/components/ui/slider.tsx
src/components/ui/sonner.tsx
src/components/ui/switch.tsx
src/components/ui/table.tsx
src/components/ui/tabs.tsx
src/components/ui/textarea.tsx
src/components/ui/toast.tsx
src/components/ui/toaster.tsx
src/components/ui/toggle-group.tsx
src/components/ui/toggle.tsx
src/components/ui/tooltip.tsx
src/components/video-controls.tsx
src/components/video-player-client.tsx
src/components/video-player.tsx
src/components/watch-button.tsx
src/components/watchlist/watchlist-button.tsx
src/components/watchlist/watchlist-filters.tsx
src/components/watchlist/watchlist-grid.tsx
src/components/watchlist/watchlist-stats.tsx
src/constants/anilist.ts
src/constants/utils.ts
src/context/HistoryContext.tsx
src/context/ListsContext.tsx
src/hooks/use-debounce.ts
src/hooks/use-local-storage.ts
src/hooks/use-toast.ts
src/hooks/use-watch-progress.ts
src/hooks/use-watchlist.ts
src/hooks/useAuth.ts
src/lib/actions.ts
src/lib/anilist.ts
src/lib/auth.ts
src/lib/cache-service.ts
src/lib/cache.ts
src/lib/prisma.ts
src/lib/redis.ts
src/lib/utils.ts
src/modules/anilist/anilistsAPI.ts
src/modules/animeCustomTitles.ts
src/modules/aniskip.ts
src/modules/clientData.ts
src/modules/history.ts
src/modules/providers/animedrive.ts
src/modules/providers/animesaturn.ts
src/modules/providers/animeunity.ts
src/modules/providers/api.ts
src/modules/providers/cache.ts
src/modules/providers/gogoanime.ts
src/modules/providers/hianime.ts
src/modules/providers/monoschinos.ts
src/modules/requests.ts
src/modules/utils.ts
src/pages/api/anime/[provider]/[...params].ts
src/pages/api/anime/proxy.ts
src/services/auth.ts
src/types/anilistAPITypes.tsx
src/types/anilistGraphQLTypes.tsx
src/types/aniskipTypes.tsx
src/types/auth.ts
src/types/historyTypes.tsx
src/types/search.ts
src/types/types.tsx
src/types/watchlist.ts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="src/app/anime/[id]/page.tsx">
"use client";

import { use } from "react";
import { useEffect, useState } from "react";
import { getAnimeInfo } from "@/modules/anilist/anilistsAPI";
import { Media, AiringSchedule } from "@/types/anilistGraphQLTypes";
import { AnimeTabs } from "../../../components/anime-tabs";
import { LoadingSpinner } from "@/components/loading-spinner";
import { Suspense } from "react";
import { AnimeDetails } from "@/components/anime-details";
import { EpisodeList } from "@/components/episode-list";
import { Anime } from "@/lib/anilist";
import { Separator } from "@/components/ui/separator";

export default function AnimePage({ params }: { params: Promise<{ id: string }> }) {
  const resolvedParams = use(params);
  const [anime, setAnime] = useState<Media | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [releasedEpisodes, setReleasedEpisodes] = useState<number>(0);

  useEffect(() => {
    async function fetchAnimeData() {
      try {
        const data = await getAnimeInfo(parseInt(resolvedParams.id));
        setAnime(data);
        // console.log('Relations:', data.relations?.edges?.length);
        // console.log('Recommendations:', data.recommendations?.nodes?.length);
        
        
        // Calculate released episodes
        const totalEpisodes = data.episodes || 0;
        const nextAiring = data.nextAiringEpisode;
        
        if (nextAiring && nextAiring.timeUntilAiring > 0) {
          setReleasedEpisodes(nextAiring.episode - 1);
        } else {
          setReleasedEpisodes(totalEpisodes);
        }
        
      } catch (error) {
        console.error("Failed to fetch anime:", error);
      } finally {
        setIsLoading(false);
      }
    }

    fetchAnimeData();
  }, [resolvedParams.id]);

  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (!anime || anime.id === undefined) {
    return <div>Anime not found</div>;
  }

  return (
    <div>
      <Suspense fallback={<LoadingSpinner />}>
        <AnimeDetails anime={anime as Anime} />
      </Suspense>
      <div className="container space-y-8 py-8">
        <Suspense fallback={<LoadingSpinner />}>
          <EpisodeList 
            episodes={releasedEpisodes} 
            animeId={anime.id} 
            coverImage={anime.coverImage?.large ?? ''}
            bannerImage={anime.bannerImage ?? ''}
          />
        </Suspense>
        
        <Separator className="my-8" />
        
        <AnimeTabs anime={anime} />
      </div>
    </div>
  );
}
</file>

<file path="src/app/auth/callback/AuthCallbackContent.tsx">
"use client";

import { useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { getAccessToken, getViewerId, getViewerInfo, getViewerLists } from "@/modules/anilist/anilistsAPI";
import type { MediaListStatus } from "@/types/anilistGraphQLTypes";

export default function AuthCallbackContent() {
  const router = useRouter();
  const searchParams = useSearchParams();

  useEffect(() => {
    const handleAuth = async () => {
      const code = searchParams?.get("code");
      if (!code) {
        router.push("/");
        return;
      }

      try {
        // Get and store access token
        const accessToken = await getAccessToken(code);
        sessionStorage.setItem("access_token", accessToken);

        // Get and store user ID
        const viewerId = await getViewerId();
        sessionStorage.setItem("viewer_id", viewerId.toString());

        // Store user data in background
        getViewerInfo(viewerId).then(userData => {
          const userProfile = {
            id: userData.id,
            name: userData.name,
            avatar: {
              medium: userData.avatar?.medium
            }
          };
          sessionStorage.setItem("user_data", JSON.stringify(userProfile));
        });

        // Get lists in background
        getViewerLists(
          viewerId,
          "CURRENT" as MediaListStatus,
          "REPEATING" as MediaListStatus,
          "PAUSED" as MediaListStatus
        ).then(lists => {
          if (lists) {
            sessionStorage.setItem("anime_lists", JSON.stringify(lists));
          }
        });

        // Redirect immediately after essential data is stored
        router.push("/");
        
      } catch (error) {
        console.error("Auth error:", error);
        router.push("/");
      }
    };

    handleAuth();
  }, [router, searchParams]);

  return null;
}
</file>

<file path="src/app/auth/callback/AuthCallbackHandler.tsx">
"use client";

import { useEffect } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { getAccessToken, getViewerId, getViewerLists } from "@/modules/anilist/anilistsAPI";
import type { MediaListStatus } from "@/types/anilistGraphQLTypes";

export default function AuthCallbackContent() {
  const router = useRouter();
  const searchParams = useSearchParams();

  useEffect(() => {
    const handleAuth = async () => {
      const code = searchParams?.get("code");
      if (!code) {
        router.push("/");
        return;
      }

      try {
        // Run essential operations
        const accessToken = await getAccessToken(code);
        sessionStorage.setItem("access_token", accessToken);
        sessionStorage.setItem("logged", "true");

        const viewerId = await getViewerId();
        sessionStorage.setItem("viewer_id", viewerId.toString());

        // Get lists in background after redirect
        router.push("/");
        
        getViewerLists(
          viewerId,
          "CURRENT" as MediaListStatus,
          "REPEATING" as MediaListStatus,
          "PAUSED" as MediaListStatus
        ).then(lists => {
          if (lists) {
            sessionStorage.setItem("anime_lists", JSON.stringify(lists));
          }
        });

      } catch (error) {
        console.error("Auth error:", error);
        router.push("/");
      }
    };

    handleAuth();
  }, [router, searchParams]);

  return null;
}
</file>

<file path="src/app/auth/callback/page.tsx">
import { Suspense } from "react";
import { LoadingSpinner } from "@/components/loading-spinner";
import AuthCallbackContent from "./AuthCallbackContent";

export const dynamic = "force-dynamic";

export default function AuthCallback() {
  return (
    <Suspense 
      fallback={
        <div className="flex min-h-screen items-center justify-center">
          <div className="text-center">
            <LoadingSpinner />
            <h2 className="mt-4 text-xl font-semibold">
              Initializing...
            </h2>
          </div>
        </div>
      }
    >
      <AuthCallbackContent />
    </Suspense>
  );
}
</file>

<file path="src/app/auth/token/route.tsx">
import { NextResponse } from 'next/server';
import { clientData } from '@/modules/clientData';

export async function POST(request: Request) {
  const data = await request.json();
  
  const tokenResponse = await fetch('https://anilist.co/api/v2/oauth/token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    },
    body: JSON.stringify({
      grant_type: 'authorization_code',
      client_id: clientData.clientId,
      client_secret: clientData.clientSecret,
      redirect_uri: clientData.redirectUri,
      code: data.code,
    }),
  });

  const tokenData = await tokenResponse.json();
  return NextResponse.json(tokenData);
}
</file>

<file path="src/app/layout.tsx">
import './globals.css';
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import { ThemeProvider } from '@/components/theme-provider';
import { Navbar } from '@/components/navbar';
import { HistoryProvider } from "@/context/HistoryContext";
import { ListsProvider } from '@/context/ListsContext';
import { MainContent } from '@/components/main-content';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'


const inter = Inter({ subsets: ['latin'] });
const queryClient = new QueryClient()
import QueryProvider from '@/components/providers/query-provider'

export const metadata: Metadata = {
  title: 'AniStream - Anime Streaming Platform',
  description: 'Watch your favorite anime shows and movies',
};

export const revalidate = 3600 // Revalidate every hour

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <ListsProvider>
          <HistoryProvider>
            <ThemeProvider
              attribute="class"
              defaultTheme="dark"
              enableSystem
              disableTransitionOnChange
            >
              <div className="relative flex min-h-screen flex-col">
                <Navbar />
                <QueryProvider>
                  <MainContent>
                    {children}
                  </MainContent>
                </QueryProvider>
              </div>
            </ThemeProvider>
          </HistoryProvider>
        </ListsProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/app/library/page.tsx">
"use client";

import { useState } from "react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ContinueWatchingSection } from "@/components/ContinueWatchingSection";
import { MyListSection } from "@/components/library/my-list-section";
import { Button } from "@/components/ui/button";
import { LoginDialog } from "@/components/auth/login-dialog";
import { useAuth } from "@/hooks/useAuth";

export const dynamic = 'force-dynamic';

export default function LibraryPage() {
  const { isAuthenticated } = useAuth();
  const [isLoginDialogOpen, setIsLoginDialogOpen] = useState(false);

  return (
    <div className="container py-8 space-y-6">
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
        <h1 className="text-3xl font-bold">My Library</h1>
        {!isAuthenticated && (
          <Button onClick={() => setIsLoginDialogOpen(true)}>
            Connect with AniList
          </Button>
        )}
      </div>

      <Tabs defaultValue="continue" className="space-y-6">
        <TabsList>
          <TabsTrigger value="continue">Continue Watching</TabsTrigger>
          <TabsTrigger value="list">My List</TabsTrigger>
        </TabsList>

        <TabsContent value="continue" className="space-y-6">
          <ContinueWatchingSection />
        </TabsContent>

        <TabsContent value="list" className="space-y-6">
          <MyListSection />
        </TabsContent>
      </Tabs>

      <LoginDialog 
        isOpen={isLoginDialogOpen}
        onOpenChange={setIsLoginDialogOpen}
        onLogin={async () => false}
        isLoading={false}
        error={null}
      />
    </div>
  );
}
</file>

<file path="src/app/page.tsx">
import { Suspense } from "react";
import { 
  getTrendingAnime, 
  getMostPopularAnime,
  searchFilteredAnime 
} from "@/modules/anilist/anilistsAPI";
import { LoadingSpinner } from "@/components/loading-spinner";
import { FeaturedCarousel } from "@/components/featured-carousel";
import { AnimeSection } from "@/components/anime-section";
import { ContinueWatchingSection } from "@/components/ContinueWatchingSection";

export const dynamic = 'force-dynamic';
export const revalidate = 0;

async function getData() {
  try {
    const [trending, popular, topRated] = await Promise.all([
      getTrendingAnime(null),
      searchFilteredAnime("type: ANIME, sort: POPULARITY_DESC, season: FALL, seasonYear: 2024, status: RELEASING", null),
      getMostPopularAnime(null)
    ]);

    return {
      trending: trending?.media || [],
      popular: popular?.media || [],
      topRated: topRated?.media || []
    };
  } catch (error) {
    console.error("Error fetching anime data:", error);
    return {
      trending: [],
      popular: [],
      topRated: []
    };
  }
}

export default async function Home() {
  const data = await getData();

  return (
    <div className="relative min-h-screen">
      <div className="absolute inset-0 bg-gradient-to-b from-background/0 via-background/50 to-background pointer-events-none" />
      
      <section className="relative w-full">
        <Suspense fallback={<LoadingSpinner />}>
          <FeaturedCarousel items={data.trending.slice(0, 8)} />
        </Suspense>
      </section>

      <section className="relative z-10 container space-y-12 py-8">
        <Suspense fallback={<LoadingSpinner />}>
          <ContinueWatchingSection />
        </Suspense>
        
        <Suspense fallback={<LoadingSpinner />}>
          <AnimeSection 
            title="Trending Now" 
            anime={data.trending} 
          />
        </Suspense>
  
        <Suspense fallback={<LoadingSpinner />}>
          <AnimeSection 
            title="Popular This Season" 
            anime={data.popular} 
          />
        </Suspense>

        <Suspense fallback={<LoadingSpinner />}>
          <AnimeSection 
            title="Top Rated" 
            anime={data.topRated} 
          />
        </Suspense>
      </section>
    </div>
  );
}
</file>

<file path="src/app/popular/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { searchFilteredAnime } from "@/modules/anilist/anilistsAPI";
import { AnimeGrid } from "@/components/anime-grid";
import { LoadingSpinner } from "@/components/loading-spinner";
import type { Media } from "@/types/anilistGraphQLTypes";

export const dynamic = 'force-dynamic';

export default function PopularPage() {
  const [anime, setAnime] = useState<Media[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchPopular() {
      try {
        setIsLoading(true);
        const data = await searchFilteredAnime(
          "type: ANIME, sort: POPULARITY_DESC, season: FALL, seasonYear: 2024, status: RELEASING",
          null
        );
        
        if (data?.media) {
          setAnime(data.media);
        }
      } catch (err) {
        setError("Failed to load popular anime");
        console.error("Error fetching popular anime:", err);
      } finally {
        setIsLoading(false);
      }
    }

    fetchPopular();
  }, []);

  if (isLoading) {
    return (
      <div className="container py-8">
        <LoadingSpinner />
      </div>
    );
  }

  if (error) {
    return (
      <div className="container py-8">
        <div className="text-center">
          <h2 className="text-xl font-semibold text-red-500 mb-2">{error}</h2>
          <p className="text-muted-foreground">Please try again later</p>
        </div>
      </div>
    );
  }

  return (
    <div className="container py-8 space-y-8">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">Popular This Season</h1>
      </div>
      <AnimeGrid anime={anime} />
    </div>
  );
}
</file>

<file path="src/app/search/page.tsx">
import { Suspense } from "react";
import { SearchContent } from "@/components/search-content";
import { LoadingSpinner } from "@/components/loading-spinner";

export default function SearchPage() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <SearchContent />
    </Suspense>
  );
}
</file>

<file path="src/app/stats/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/hooks/useAuth";
import { StatsOverview } from "@/components/stats/stats-overview";
import { GenreDistribution } from "@/components/stats/genre-distribution";
import { WatchHistory } from "@/components/stats/watch-history";
import { RatingDistribution } from "@/components/stats/rating-distribution";
import { LoadingSpinner } from "@/components/loading-spinner";
import { Button } from "@/components/ui/button";
import { LoginDialog } from "@/components/auth/login-dialog";
import { useWatchProgress } from "@/hooks/use-watch-progress";
import { useWatchlist } from "@/hooks/use-watchlist";

export const fetchCache = 'force-no-store';

export default function StatsPage() {
  const { isAuthenticated, lists } = useAuth();
  const { watchlist, isLoading: isWatchlistLoading } = useWatchlist();
  const { isLoading: isProgressLoading } = useWatchProgress();
  const [isLoginDialogOpen, setIsLoginDialogOpen] = useState(false);

  // Use local watchlist if not authenticated, otherwise use AniList data
  const entries = isAuthenticated ? lists : watchlist;

  // Show loading state only during initial data fetch
  if (isWatchlistLoading || isProgressLoading) {
    return <LoadingSpinner />;
  }

  // Calculate stats from available data
  const totalAnime = entries?.length || 0;
  const totalEpisodes = entries?.reduce((sum, item) => sum + (item.progress || 0), 0) || 0;
  const averageScore = entries?.reduce((sum, item) => {
    const score = isAuthenticated 
      ? item.media.averageScore 
      : item.media.averageScore;
    return sum + (score || 0);
  }, 0) / (totalAnime || 1);
  
  // Estimate watch time (24 minutes per episode)
  const watchTime = (totalEpisodes * 24) / 60;

  // Generate genre distribution data
  const genreMap = new Map<string, number>();
  entries?.forEach(item => {
    item.media.genres?.forEach(genre => {
      genreMap.set(genre, (genreMap.get(genre) || 0) + 1);
    });
  });
  
  const genreData = Array.from(genreMap.entries())
    .map(([genre, count]) => ({ genre, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 8);

  // Generate rating distribution data
  const ratingMap = new Map<number, number>();
  entries?.forEach(item => {
    const score = isAuthenticated 
      ? item.media.averageScore 
      : item.media.averageScore;
    if (score) {
      const rating = Math.floor(score / 10);
      ratingMap.set(rating, (ratingMap.get(rating) || 0) + 1);
    }
  });
  
  const ratingData = Array.from(ratingMap.entries())
    .map(([rating, count]) => ({ rating, count }))
    .sort((a, b) => a.rating - b.rating);

  // Generate watch history data (last 30 days)
  const watchHistoryData = Array.from({ length: 30 }, (_, i) => {
    const date = new Date();
    date.setDate(date.getDate() - i);
    return {
      date: date.toISOString(),
      episodes: Math.floor(Math.random() * 5), // Replace with actual watch history data
    };
  }).reverse();

  return (
    <div className="container py-6 space-y-8">
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
        <h1 className="text-3xl font-bold">Statistics</h1>
        {!isAuthenticated && (
          <Button onClick={() => setIsLoginDialogOpen(true)}>
            Connect with AniList
          </Button>
        )}
      </div>

      <StatsOverview
        totalAnime={totalAnime}
        totalEpisodes={totalEpisodes}
        averageScore={averageScore}
        watchTime={watchTime}
      />

      <div className="grid gap-4 md:grid-cols-2">
        <WatchHistory data={watchHistoryData} />
        <RatingDistribution data={ratingData} />
      </div>

      <GenreDistribution data={genreData} />

      <LoginDialog 
        isOpen={isLoginDialogOpen}
        onOpenChange={setIsLoginDialogOpen}
        onLogin={async () => false}
        isLoading={false}
        error={null}
      />
    </div>
  );
}
</file>

<file path="src/app/trending/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { getTrendingAnime } from "@/modules/anilist/anilistsAPI";
import { Media } from "@/types/anilistGraphQLTypes";
import { AnimeGrid } from "@/components/anime-grid";
import { LoadingSpinner } from "@/components/loading-spinner";
import { Button } from "@/components/ui/button";
import { RefreshCw } from "lucide-react";

export const dynamic = 'force-dynamic';

export default function TrendingPage() {
  const [anime, setAnime] = useState<Media[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchTrending = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const data = await getTrendingAnime(null);
      if (data?.media) {
        setAnime(data.media.slice(0, 40));
      }
    } catch (err) {
      console.error("Failed to fetch trending anime:", err);
      setError("Failed to load trending anime");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTrending();
  }, []);

  if (isLoading) {
    return <LoadingSpinner />;
  }

  if (error) {
    return (
      <div className="container py-8 text-center">
        <p className="text-red-500 mb-4">{error}</p>
        <Button onClick={fetchTrending} variant="outline">
          <RefreshCw className="mr-2 h-4 w-4" />
          Try Again
        </Button>
      </div>
    );
  }

  return (
    <div className="container py-8 space-y-6">
      <h1 className="text-3xl font-bold">Trending Now</h1>
      <AnimeGrid anime={anime} />
    </div>
  );
}
</file>

<file path="src/app/watch/[animeId]/[episodeId]/error.tsx">
"use client";

import { useEffect } from "react";
import { Button } from "@/components/ui/button";
import { useRouter } from "next/navigation";

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  const router = useRouter();
  
  useEffect(() => {
    console.error(error);
  }, [error]);

  return (
    <div className="flex min-h-[50vh] flex-col items-center justify-center space-y-4">
      <div className="text-center space-y-2">
        <h1 className="text-2xl font-bold">Something went wrong!</h1>
        <p className="text-muted-foreground">
          There was an error loading this episode.
        </p>
      </div>
      <div className="flex gap-2">
        <Button onClick={() => reset()}>Try again</Button>
        <Button variant="outline" onClick={() => router.back()}>
          Go back
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/app/watch/[animeId]/[episodeId]/layout.tsx">
import { Metadata } from "next";

export const metadata: Metadata = {
  title: "Watch Episode | AniStream",
  description: "Watch your favorite anime episodes",
};

export default function WatchLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <main className="min-h-screen bg-background">
      {children}
    </main>
  );
}
</file>

<file path="src/app/watch/[animeId]/[episodeId]/loading.tsx">
import { LoadingSpinner } from "@/components/loading-spinner";

export default function Loading() {
  return (
    <div className="container py-6">
      <LoadingSpinner />
    </div>
  );
}
</file>

<file path="src/app/watch/[animeId]/[episodeId]/page.tsx">
import { use } from "react";
import { notFound } from "next/navigation";
import { getAnimeInfo } from "@/modules/anilist/anilistsAPI";
import { Media } from "@/types/anilistGraphQLTypes";
import { WatchPageContent } from "./WatchPageContent";
import { LoadingSpinner } from "@/components/loading-spinner";

interface PageProps {
  params: Promise<{
    animeId: string;
    episodeId: string;
  }>;
}

export default function WatchPage({ params }: PageProps) {
  const resolvedParams = use(params);
  const animeId = parseInt(resolvedParams.animeId);
  const episodeNumber = parseInt(resolvedParams.episodeId);

  if (isNaN(animeId) || isNaN(episodeNumber)) {
    notFound();
  }

  async function loadAnime(): Promise<Media> {
    try {
      const data = await getAnimeInfo(animeId);
      
      // Add logging to debug the data
      // console.log("Anime data:", data);
      // console.log("Episode number:", episodeNumber);
      // console.log("Total episodes:", data?.episodes);
  
      // More specific checks
      if (!data) {
        console.log("No anime data found");
        notFound();
      }
  
      if (episodeNumber < 1) {
        console.log("Episode number less than 1");
        notFound();
      }
  
      if (data.episodes && episodeNumber > data.episodes) {
        console.log("Episode number exceeds total episodes");
        notFound();
      }
  
      return data;
    } catch (error) {
      console.error("Error loading anime:", error);
      // Consider handling specific error types
      if (error instanceof Error) {
        console.error("Error message:", error.message);
      }
      throw error;
    }
  }
  

  const anime = use(loadAnime());

  return (
    <div className="min-h-screen bg-background">
      <div className="container max-w-7xl space-y-8 py-6">
        <WatchPageContent 
          anime={anime} 
          animeId={resolvedParams.animeId}
          episodeId={resolvedParams.episodeId}
          episodeNumber={episodeNumber}
        />
      </div>
    </div>
  );
}
</file>

<file path="src/app/watch/[animeId]/[episodeId]/WatchPageContent.tsx">
"use client";

import { VideoPlayer } from "@/components/video-player";
import { Badge } from "@/components/ui/badge";
import { WatchlistButton } from "@/components/watchlist/watchlist-button";
import { EpisodeNavigation } from "@/components/episode-navigation";
import { Media } from "@/types/anilistGraphQLTypes";
import { Card } from "@/components/ui/card";
import { useEffect } from "react";

interface WatchPageContentProps {
  anime: Media;
  animeId: string;
  episodeId: string;
  episodeNumber: number;
}

export function WatchPageContent({ 
  anime, 
  animeId,
  episodeId,
  episodeNumber 
}: WatchPageContentProps) {
  useEffect(() => {
    console.log("Loading episode:", {
      animeId,
      episodeId,
      episodeNumber,
      animeTitle: anime.title?.english || anime.title?.romaji,
      totalEpisodes: anime.episodes
    });
  }, [animeId, episodeId, episodeNumber, anime]);

  // Calculate a reasonable episode range for pagination if needed
  const isLongRunning = !anime.episodes || anime.episodes > 100;
  const currentEpisodeRange = isLongRunning ? {
    start: Math.max(1, episodeNumber - 50),
    end: episodeNumber + 50
  } : {
    start: 1,
    end: anime.episodes || 1
  };

  return (
    <>
      <div className="relative">
        <VideoPlayer
          animeId={animeId}
          episodeId={episodeId}
          title={anime.title?.english || anime.title?.romaji || ""}
          episodeNumber={episodeNumber}
          totalEpisodes={anime.episodes || 9999} // Use a high number for ongoing series
          listAnimeData={{
            id: null,
            mediaId: null,
            progress: undefined,
            media: anime
          }}
        />
      </div>

      <div className="grid gap-8 lg:grid-cols-[2fr_1fr]">
        <Card className="p-6 space-y-4">
          <h1 className="text-2xl font-bold">
            {anime.title?.english || anime.title?.romaji}
          </h1>
          
          <div className="flex flex-wrap gap-2">
            {anime.genres?.map((genre) => (
              <Badge key={genre} variant="secondary">
                {genre}
              </Badge>
            ))}
          </div>

          <p className="text-muted-foreground">
            {anime.description?.replace(/<[^>]*>/g, "")}
          </p>

          <div className="flex items-center gap-4">
            <WatchlistButton anime={anime} />
            <div className="text-sm text-muted-foreground">
              {anime.episodes ? `${anime.episodes} Episodes` : 'Ongoing'} â€¢ {anime.duration} mins
            </div>
          </div>
        </Card>

        <Card className="p-6 space-y-4">
          <h2 className="text-lg font-semibold">Episodes</h2>
          <EpisodeNavigation
            currentEpisode={episodeNumber}
            totalEpisodes={anime.episodes || 9999} // Use a high number for ongoing series
            animeId={parseInt(animeId)}
            episodeRange={currentEpisodeRange}
          />
        </Card>
      </div>
    </>
  );
}
</file>

<file path="src/app/watchlist/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/hooks/useAuth";
import { WatchlistGrid } from "@/components/watchlist/watchlist-grid";
import { WatchlistFilters } from "@/components/watchlist/watchlist-filters";
import { WatchlistStats } from "@/components/watchlist/watchlist-stats";
import { LoadingSpinner } from "@/components/loading-spinner";
import { Button } from "@/components/ui/button";
import { LoginDialog } from "@/components/auth/login-dialog";
import { useWatchlist } from "@/hooks/use-watchlist";
import type { WatchStatus } from "@/types/watchlist";

export const dynamic = 'force-dynamic';

export default function WatchlistPage() {
  const { isAuthenticated } = useAuth();
  const { watchlist, isLoading } = useWatchlist();
  const [status, setStatus] = useState<WatchStatus>("watching");
  const [isLoginDialogOpen, setIsLoginDialogOpen] = useState(false);

  const filteredList = watchlist?.filter(item => 
    item.status?.toLowerCase() === status
  ) || [];

  if (isLoading) {
    return <LoadingSpinner />;
  }

  return (
    <div className="container py-6 space-y-6">
      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
        <h1 className="text-2xl font-bold">My Watchlist</h1>
        {!isAuthenticated && (
          <Button onClick={() => setIsLoginDialogOpen(true)}>
            Connect with AniList
          </Button>
        )}
      </div>

      <div className="grid gap-6 lg:grid-cols-[1fr_300px]">
        <div className="space-y-6">
          <WatchlistFilters 
            currentStatus={status} 
            onStatusChange={setStatus}
          />
          <WatchlistGrid entries={filteredList} />
        </div>

        <div>
          <WatchlistStats entries={watchlist || []} />
        </div>
      </div>

      <LoginDialog 
        isOpen={isLoginDialogOpen}
        onOpenChange={setIsLoginDialogOpen}
        onLogin={async () => false}
        isLoading={false}
        error={null}
      />
    </div>
  );
}
</file>

<file path="src/components/anime-details.tsx">
"use client";

import Image from "next/image";
import { WatchButton } from "@/components/watch-button";
import { WatchlistButton } from "@/components/watchlist/watchlist-button";
import { Badge } from "@/components/ui/badge";
import { Star } from "lucide-react";
import type { Anime } from "@/lib/anilist";

export function AnimeDetails({ anime }: { anime: Anime }) {
  return (
    <div>
      <div className="relative h-[50vh] w-full overflow-hidden">
        <Image
          src={anime.bannerImage || anime.coverImage.large}
          alt={anime.title.english || anime.title.romaji}
          fill
          className="object-cover brightness-50"
          priority
        />
        <div className="absolute inset-0 bg-gradient-to-t from-background to-transparent" />
      </div>

      <div className="container relative -mt-32">
        <div className="grid gap-6 md:grid-cols-[250px_1fr] lg:grid-cols-[300px_1fr]">
          <div className="relative aspect-[3/4] w-full overflow-hidden rounded-lg border shadow-lg">
            <Image
              src={anime.coverImage.large}
              alt={anime.title.english || anime.title.romaji}
              fill
              className="object-cover"
              priority
            />
          </div>

          <div className="space-y-4">
            <h1 className="text-4xl font-bold">
              {anime.title.english || anime.title.romaji}
            </h1>
            
            <div className="flex flex-wrap gap-2">
              {anime.genres?.map((genre) => (
                <Badge key={genre} variant="secondary">
                  {genre}
                </Badge>
              ))}
            </div>

            <div className="flex items-center gap-4 text-sm">
              <div className="flex items-center">
                <Star className="mr-1 h-4 w-4 text-yellow-500" />
                <span>{anime.averageScore ? (anime.averageScore / 10).toFixed(1) : "N/A"}</span>
              </div>
              <div>{anime.format}</div>
              <div>{anime.episodes} Episodes</div>
              {anime.duration && <div>{anime.duration} mins</div>}
            </div>

            <p className="text-muted-foreground">
              {anime.description?.replace(/<[^>]*>/g, "")}
            </p>

            <div className="flex gap-4">
              <WatchButton anime={anime} size="lg" />
              <WatchlistButton anime={anime} size="lg" variant="secondary" />
            </div>

            <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
              <div>
                <h4 className="text-sm font-medium text-muted-foreground">Status</h4>
                <p className="text-sm">{anime.status}</p>
              </div>
              {anime.season && (
                <div>
                  <h4 className="text-sm font-medium text-muted-foreground">Season</h4>
                  <p className="text-sm">{`${anime.season} ${anime.seasonYear}`}</p>
                </div>
              )}
              {anime.studios?.nodes && anime.studios.nodes.length > 0 && (
                <div>
                  <h4 className="text-sm font-medium text-muted-foreground">Studio</h4>
                  <p className="text-sm">{anime.studios.nodes[0].name}</p>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/anime-grid.tsx">
import Link from "next/link";
import Image from "next/image";
import { Card, CardContent } from "@/components/ui/card";
import { Media } from "@/types/anilistGraphQLTypes";

export function AnimeGrid({ anime }: { anime: Media[] }) {
  // Filter out duplicates based on ID
  const uniqueAnime = anime.reduce((acc: Media[], current) => {
    const exists = acc.find(item => item.id === current.id);
    if (!exists && current.id) {
      acc.push(current);
    }
    return acc;
  }, []);
  return (
    <div className="flex gap-4">
      {uniqueAnime.map((item) => (
        <Link 
          key={item.id} 
          href={`/anime/${item.id}`}
          className="flex-none w-[200px] transition-transform hover:scale-[1.02]"
        >
          <Card className="h-full overflow-hidden">
            <div className="aspect-[3/4] relative">
              <Image
                src={item.coverImage?.large || ''}
                alt={item.title?.english || item.title?.romaji || ""}
                fill
                className="object-cover"
              />
            </div>
            <CardContent className="p-4">
              <h2 className="font-semibold line-clamp-1">
                {item.title?.english || item.title?.romaji}
              </h2>
              <p className="text-sm text-muted-foreground line-clamp-2 mt-1">
                {item.description?.replace(/<[^>]*>/g, "")}
              </p>
            </CardContent>
          </Card>
        </Link>
      ))}    </div>
  );
}
</file>

<file path="src/components/anime-section.tsx">
"use client";

import { useRef, useState } from "react";
import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { AnimeGrid } from "@/components/anime-grid";
import { Media } from "@/types/anilistGraphQLTypes";
import { ListAnimeData } from '../types/anilistAPITypes';
import { ListsProvider, useLists } from '@/context/ListsContext';
interface AnimeSectionProps {
  title: string;
  anime: Media[];
  animeData: (lists: ListAnimeData[]) => void;
  
}

export function AnimeSection({ title, anime }: AnimeSectionProps) {
  const [scrollPosition, setScrollPosition] = useState(0);
  const scrollContainerRef = useRef<HTMLDivElement>(null);

  const handleScroll = (direction: 'left' | 'right') => {
    const container = scrollContainerRef.current;
    if (!container) return;
    
    const scrollAmount = direction === 'left' ? -800 : 800;
    container.scrollBy({ left: scrollAmount, behavior: 'smooth' });
  };

  return (
    <ListsProvider>
    <section className="w-full mx-auto relative group">
      <div className="mb-6 flex flex-col sm:flex-row items-center justify-between gap-4">
        <h2 className="text-2xl sm:text-3xl font-bold">{title}</h2>
        <div className="flex gap-2">
          <Button
            variant="outline"
            size="icon"
            onClick={() => handleScroll('left')}
            className="h-8 w-8 sm:h-10 sm:w-10"
          >
            <ChevronLeft className="h-4 w-4 sm:h-5 sm:w-5" />
          </Button>
          <Button
            variant="outline"
            size="icon"
            onClick={() => handleScroll('right')}
            className="h-8 w-8 sm:h-10 sm:w-10"
          >
            <ChevronRight className="h-4 w-4 sm:h-5 sm:w-5" />
          </Button>
        </div>
      </div>
      <div 
        ref={scrollContainerRef}
        className="relative overflow-x-auto overflow-y-hidden"
      >
        <AnimeGrid anime={anime} />
      </div>
    </section>
    </ListsProvider>
  );
}
</file>

<file path="src/components/anime-tabs.tsx">
import { useState, useRef } from 'react'
import { Media, Relation } from '@/types/anilistGraphQLTypes'
import { Button } from '@/components/ui/button'
import { Card, CardContent } from "@/components/ui/card"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import { ChevronDown, ChevronLeft, ChevronRight } from 'lucide-react'
import Image from "next/image"
import Link from "next/link"

type AnimeTabsProps = {
  anime: Media
}

export function AnimeTabs({ anime }: AnimeTabsProps) {
  const [activeTab, setActiveTab] = useState<'related' | 'recommendations'>(
    anime.relations?.edges?.some(relation => 
      relation?.node?.type === 'ANIME' && 
      ['PREQUEL', 'SEQUEL', 'SIDE_STORY', 'PARENT', 'ALTERNATIVE'].includes(relation.relationType)
    ) ? 'related' : 'recommendations'
  );
  const scrollContainerRef = useRef<HTMLDivElement>(null)

  const handleScroll = (direction: 'left' | 'right') => {
    const container = scrollContainerRef.current
    if (!container) return
    
    const scrollAmount = direction === 'left' ? -800 : 800
    container.scrollBy({ left: scrollAmount, behavior: 'smooth' })
  }

  const relatedAnime = anime.relations?.edges
  .filter(relation => {
    // console.log('Relation:', {
    //   hasRelation: !!relation,
    //   hasNode: !!relation?.node,
    //   type: relation?.node?.type,
    //   relationType: relation?.relationType,
    //   isValidType: relation?.node?.type === 'ANIME',
    //   isValidRelation: ['PREQUEL', 'SEQUEL', 'SIDE_STORY', 'PARENT', 'ALTERNATIVE', 'OTHER'].includes(relation?.relationType)
    // });
    
    return relation &&
      relation.node &&
      relation.node.type === 'ANIME' &&
      ['PREQUEL', 'SEQUEL', 'SIDE_STORY', 'PARENT', 'ALTERNATIVE', 'OTHER'].includes(relation.relationType);
  })
  .map(relation => ({
    ...relation.node,
    relationType: relation.relationType
  })) || [];

  
  // console.log('Raw recommendations:', {
  // hasNodes: !!anime.recommendations?.nodes,
  // nodesLength: anime.recommendations?.nodes?.length,
  // nodes: anime.recommendations?.nodes
  // });

  const recommendedAnime = anime.recommendations?.nodes
    ?.filter(node => {
      // console.log('Recommendation node:', {
      //   hasNode: !!node,
      //   hasMediaRec: !!node?.mediaRecommendation
      // });
      return node && node.mediaRecommendation;
    })
    .map(rec => rec.mediaRecommendation) || [];

  // console.log('Final counts:', {
  // relatedAnimeCount: relatedAnime.length,
  // recommendedAnimeCount: recommendedAnime.length
  // });
  

  return (
    <section className="w-full mx-auto relative group">
      <div className="mb-6 flex flex-col sm:flex-row items-center justify-between gap-4">
        {relatedAnime.length > 0 ? (
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline">
                {activeTab === 'related' ? 'Related Anime' : 'Recommendations'}
                <ChevronDown className="ml-2 h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent>
              <DropdownMenuItem onClick={() => setActiveTab('related')}>
                Related Anime
              </DropdownMenuItem>
              <DropdownMenuItem onClick={() => setActiveTab('recommendations')}>
                Recommendations  
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        ) : (
          <h2 className="text-2xl sm:text-3xl font-bold">Recommendations</h2>
        )}
        
        <div className="flex gap-2">
          <Button
            variant="outline"
            size="icon"
            onClick={() => handleScroll('left')}
            className="h-8 w-8 sm:h-10 sm:w-10"
          >
            <ChevronLeft className="h-4 w-4 sm:h-5 sm:w-5" />
          </Button>
          <Button
            variant="outline"
            size="icon"
            onClick={() => handleScroll('right')}
            className="h-8 w-8 sm:h-10 sm:w-10"
          >
            <ChevronRight className="h-4 w-4 sm:h-5 sm:w-5" />
          </Button>
        </div>
      </div>

      <div 
        ref={scrollContainerRef}
        className="relative overflow-x-auto overflow-y-hidden"
      >
        <div className="flex gap-4">
          {activeTab === 'related' && relatedAnime.map((item) => (
            <Link 
              key={item.id} 
              href={`/anime/${item.id}`}
              className="flex-none w-[200px] transition-transform hover:scale-[1.02]"
            >
              <Card className="h-full overflow-hidden">
                <div className="aspect-[3/4] relative">
                  <Image
                    src={item.coverImage?.large || ''}
                    alt={item.title?.english || item.title?.romaji || ""}
                    fill
                    className="object-cover"
                  />
                </div>
                <CardContent className="p-4">
                  <h2 className="font-semibold line-clamp-1">
                    {item.title?.english || item.title?.romaji}
                  </h2>
                  <div className="flex flex-col gap-1 mt-2 text-sm text-muted-foreground">
                    <div className="flex justify-between">
                    <span>{item.seasonYear}</span>
                    <span className="capitalize">{item.relationType?.toLowerCase().replace('_', ' ')}</span>
                    </div>
                  </div>
                </CardContent>
              </Card>
            </Link>
          ))}

          {activeTab === 'recommendations' && recommendedAnime.map((item) => (
            <Link 
              key={item.id} 
              href={`/anime/${item.id}`}
              className="flex-none w-[200px] transition-transform hover:scale-[1.02]"
            >
              <Card className="h-full overflow-hidden">
                <div className="aspect-[3/4] relative">
                  <Image
                    src={item.coverImage?.large || ''}
                    alt={item.title?.english || item.title?.romaji || ""}
                    fill
                    className="object-cover"
                  />
                </div>
                <CardContent className="p-4">
                  <h2 className="font-semibold line-clamp-1">
                    {item.title?.english || item.title?.romaji}
                  </h2>
                  <div className="flex flex-col gap-1 mt-2 text-sm text-muted-foreground">
                    <span>{item.seasonYear}</span>
                    <span>{item.format}</span>
                  </div>
                </CardContent>
              </Card>
            </Link>
          ))}
        </div>
      </div>
    </section>
  )
}
</file>

<file path="src/components/auth/login-dialog.tsx">
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { clientData } from "@/modules/clientData";

interface LoginDialogProps {
  isOpen: boolean;
  onOpenChange: (open: boolean) => void;
  onLogin: (token: string) => Promise<boolean>;
  isLoading: boolean;
  error: string | null;
}

export function LoginDialog({
  isOpen,
  onOpenChange,
  onLogin,
  isLoading,
  error
}: LoginDialogProps) {
  const [token, setToken] = useState("");
  const authUrl = `https://anilist.co/api/v2/oauth/authorize?client_id=${clientData.clientId}&redirect_uri=${clientData.redirectUri}&response_type=code`;

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (token.trim()) {
      const success = await onLogin(token);
      if (success) {
        setToken("");
        onOpenChange(false);
      }
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Login to AniList</DialogTitle>
          <DialogDescription>
            Connect your AniList account to sync your watchlist and track your progress.
          </DialogDescription>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="grid gap-4 py-4">
          <Input
            placeholder="Paste your token here..."
            value={token}
            onChange={(e) => setToken(e.target.value)}
            disabled={isLoading}
            aria-label="AniList Token"
          />
          {error && (
            <p className="text-sm text-red-500" role="alert">{error}</p>
          )}
          <div className="flex gap-4">
            <Button
              type="button"
              variant="outline"
              onClick={() => window.open(authUrl, '_blank')}
              disabled={isLoading}
            >
              Get Token
            </Button>
            <Button 
              type="submit"
              disabled={isLoading || !token.trim()}
              className="flex-1"
            >
              {isLoading ? "Logging in..." : "Submit"}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/ContinueWatchingSection.tsx">
"use client";

import { useEffect, useState } from 'react';
import { useAuth } from '@/hooks/useAuth';
import { useLocalStorage } from '@/hooks/use-local-storage';
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import { PlayCircle } from "lucide-react";
import Image from "next/image";
import Link from "next/link";
import { formatTime } from "@/lib/utils";
import { cacheService } from "@/lib/cache-service";

interface WatchProgress {
  animeId: number;
  episodeNumber: number;
  timestamp: number;
  progress: number;
  duration: number;
  title: string;
  coverImage: string;
  totalEpisodes?: number;
}

export function ContinueWatchingSection() {
  const { isAuthenticated, lists } = useAuth();
  const [watchProgress] = useLocalStorage<Record<string, WatchProgress>>("watch-progress", {});
  const [recentlyWatched, setRecentlyWatched] = useState<WatchProgress[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [cachedAnime, setCachedAnime] = useState([]);
  

  useEffect(() => {
    if (isAuthenticated && lists) {
      // Get recently watched from AniList data
      const watched = lists
        .filter(item => item.progress && item.progress > 0)
        .map(item => ({
          animeId: item.media.id,
          episodeNumber: item.progress || 0,
          timestamp: Date.now(), // AniList doesn't provide timestamp
          progress: 100, // AniList doesn't provide episode progress
          duration: 24 * 60, // Default episode length in seconds
          title: item.media.title?.english || item.media.title?.romaji || '',
          coverImage: item.media.coverImage?.large || '',
          totalEpisodes: item.media.episodes
        }))
        .sort((a, b) => b.timestamp - a.timestamp)
        .slice(0, 12);

      setRecentlyWatched(watched);
    } else {
      // Get recently watched from local storage
      const watched = Object.values(watchProgress)
        .sort((a, b) => b.timestamp - a.timestamp)
        .slice(0, 12);

      setRecentlyWatched(watched);
    }
    setIsLoading(false);
  }, [isAuthenticated, lists, watchProgress]);

  if (isLoading) {
    return (
      <div className="grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4">
        {[...Array(4)].map((_, i) => (
          <Card key={i} className="animate-pulse">
            <div className="aspect-video bg-muted" />
            <div className="p-4 space-y-3">
              <div className="h-4 bg-muted rounded w-3/4" />
              <div className="h-3 bg-muted rounded w-1/2" />
            </div>
          </Card>
        ))}
      </div>
    );
  }

  if (!recentlyWatched.length) {
    return (
      <div className="text-center py-12">
        <h3 className="text-lg font-medium mb-2">No watched anime yet</h3>
        <p className="text-muted-foreground">
          Start watching anime to track your progress
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <h2 className="text-2xl font-bold">Continue Watching</h2>
      
      <div className="grid gap-4 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4">
        {recentlyWatched.map((item) => (
          <Link 
            key={`${item.animeId}-${item.episodeNumber}`}
            href={`/watch/${item.animeId}/${item.episodeNumber + 1}`}
          >
            <Card className="overflow-hidden transition-transform hover:scale-[1.02]">
              <div className="relative aspect-video group">
                <Image
                  src={item.coverImage}
                  alt={item.title}
                  fill
                  className="object-cover"
                />
                <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                  <Button size="sm" variant="secondary">
                    <PlayCircle className="mr-2 h-4 w-4" />
                    Continue
                  </Button>
                </div>
              </div>
              
              <div className="p-4 space-y-2">
                <h3 className="font-medium line-clamp-1">{item.title}</h3>
                <div className="text-sm text-muted-foreground">
                  Episode {item.episodeNumber}
                  {item.totalEpisodes && ` of ${item.totalEpisodes}`}
                </div>
                
                <div className="space-y-1">
                  <Progress 
                    value={item.progress} 
                    className="h-1"
                  />
                  <div className="flex justify-between text-xs text-muted-foreground">
                    <span>{formatTime(item.duration * (item.progress / 100))}</span>
                    <span>{formatTime(item.duration)}</span>
                  </div>
                </div>
              </div>
            </Card>
          </Link>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="src/components/episode-list.tsx">
"use client";

import { useState, useEffect, useMemo } from "react";
import Link from "next/link";
import Image from "next/image";
import { EPISODES_INFO_URL } from "@/constants/utils";
import { Card } from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Pagination,
  PaginationContent,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
} from "@/components/ui/pagination";
import { PlayCircle } from "lucide-react";
import { Button } from "@/components/ui/button";

interface Episode {
  title: {
    en: string;
  };
  image: string;
  runtime: number;
}

interface EpisodeMapping {
  episodes: {
    [key: string]: Episode;
  };
}

interface EpisodeListProps {
  episodes: number;
  animeId: number;
  coverImage: string;
  bannerImage?: string;
}

const EPISODES_PER_PAGE = 24;
const MAX_VISIBLE_PAGES = 5;

export function EpisodeList({ episodes, animeId, coverImage, bannerImage }: EpisodeListProps) {
  const [currentPage, setCurrentPage] = useState(1);
  const [episodeData, setEpisodeData] = useState<EpisodeMapping | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Calculate pagination values
  const totalPages = Math.ceil(episodes / EPISODES_PER_PAGE);
  const startEpisode = (currentPage - 1) * EPISODES_PER_PAGE + 1;
  const endEpisode = Math.min(currentPage * EPISODES_PER_PAGE, episodes);

  // Generate visible page numbers
  const visiblePages = useMemo(() => {
    const pages: number[] = [];
    let start = Math.max(1, currentPage - Math.floor(MAX_VISIBLE_PAGES / 2));
    let end = Math.min(totalPages, start + MAX_VISIBLE_PAGES - 1);

    // Adjust start if we're near the end
    if (end - start + 1 < MAX_VISIBLE_PAGES) {
      start = Math.max(1, end - MAX_VISIBLE_PAGES + 1);
    }

    for (let i = start; i <= end; i++) {
      pages.push(i);
    }
    return pages;
  }, [currentPage, totalPages]);

  // Get episodes for current page
  const currentEpisodes = useMemo(() => {
    return Array.from(
      { length: endEpisode - startEpisode + 1 },
      (_, i) => startEpisode + i
    );
  }, [startEpisode, endEpisode]);

  useEffect(() => {
    const fetchEpisodeData = async () => {
      if (!animeId) return;

      try {
        setIsLoading(true);
        setError(null);
        const response = await fetch(`${EPISODES_INFO_URL}${animeId}`);
        
        if (!response.ok) {
          throw new Error('Failed to fetch episode data');
        }
        
        const data = await response.json();
        setEpisodeData(data);
      } catch (error) {
        console.error("Error fetching episode data:", error);
        setError("Failed to load episode information");
      } finally {
        setIsLoading(false);
      }
    };

    fetchEpisodeData();
  }, [animeId]);

  // Handle page change
  const handlePageChange = (page: number) => {
    setCurrentPage(page);
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };

  // Loading state with skeleton UI
  if (isLoading) {
    return (
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <h2 className="text-2xl font-bold">Episodes</h2>
          <div className="w-[120px] h-10 bg-muted rounded-md animate-pulse" />
        </div>
        <div className="grid gap-4 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4">
          {Array.from({ length: EPISODES_PER_PAGE }).map((_, i) => (
            <Card key={i} className="overflow-hidden animate-pulse">
              <div className="aspect-video bg-muted" />
              <div className="p-4 space-y-2">
                <div className="h-4 w-24 bg-muted rounded" />
                <div className="h-3 w-16 bg-muted rounded" />
              </div>
            </Card>
          ))}
        </div>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div className="text-center py-8">
        <p className="text-red-500 mb-4">{error}</p>
        <Button onClick={() => window.location.reload()}>
          Try Again
        </Button>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div className="space-y-1">
          <h2 className="text-2xl font-bold">Episodes</h2>
          <p className="text-sm text-muted-foreground">
            Showing episodes {startEpisode}-{endEpisode} of {episodes}
          </p>
        </div>

        {totalPages > 1 && (
          <Select
            value={currentPage.toString()}
            onValueChange={(value) => handlePageChange(parseInt(value))}
          >
            <SelectTrigger className="w-[120px]">
              <SelectValue placeholder="Page" />
            </SelectTrigger>
            <SelectContent>
              {Array.from({ length: totalPages }, (_, i) => i + 1).map((page) => (
                <SelectItem key={page} value={page.toString()}>
                  Page {page}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        )}
      </div>

      <div className="grid gap-4 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4">
        {currentEpisodes.map((episodeNumber) => {
          const episodeInfo = episodeData?.episodes?.[episodeNumber.toString()];
          const imageSource = episodeInfo?.image || bannerImage || coverImage;

          return (
            <Link 
              key={episodeNumber} 
              href={`/watch/${animeId}/${episodeNumber}`}
              className="transition-transform hover:scale-[1.02]"
            >
              <Card className="overflow-hidden h-full">
                <div className="group relative flex flex-col h-full">
                  <div className="relative aspect-video w-full overflow-hidden">
                    <Image
                      src={imageSource}
                      alt={`Episode ${episodeNumber}`}
                      fill
                      className="object-cover transition-transform group-hover:scale-105"
                      sizes="(max-width: 640px) 100vw, (max-width: 768px) 50vw, (max-width: 1024px) 33vw, 25vw"
                      priority={episodeNumber <= 4}
                    />
                    <div className="absolute inset-0 flex items-center justify-center bg-black/60 opacity-0 transition-opacity group-hover:opacity-100">
                      <PlayCircle className="h-12 w-12 text-white" />
                    </div>
                  </div>

                  <div className="flex flex-col justify-between p-4 flex-1">
                    <div>
                      <div className="font-medium">Episode {episodeNumber}</div>
                      <div className="text-sm text-muted-foreground">
                        {episodeInfo?.title?.en || `${episodeInfo?.runtime || 24}m`}
                      </div>
                    </div>
                  </div>
                </div>
              </Card>
            </Link>
          );
        })}
      </div>

      {totalPages > 1 && (
        <Pagination className="justify-center">
          <PaginationContent>
            <PaginationItem>
              <PaginationPrevious 
                href="#"
                onClick={(e) => {
                  e.preventDefault();
                  if (currentPage > 1) handlePageChange(currentPage - 1);
                }}
                aria-disabled={currentPage === 1}
              />
            </PaginationItem>
            
            {currentPage > MAX_VISIBLE_PAGES && (
              <>
                <PaginationItem>
                  <PaginationLink
                    href="#"
                    onClick={(e) => {
                      e.preventDefault();
                      handlePageChange(1);
                    }}
                  >
                    1
                  </PaginationLink>
                </PaginationItem>
                <PaginationItem>
                  <span className="px-4">...</span>
                </PaginationItem>
              </>
            )}
            
            {visiblePages.map((page) => (
              <PaginationItem key={page}>
                <PaginationLink
                  href="#"
                  onClick={(e) => {
                    e.preventDefault();
                    handlePageChange(page);
                  }}
                  isActive={page === currentPage}
                >
                  {page}
                </PaginationLink>
              </PaginationItem>
            ))}
            
            {currentPage < totalPages - MAX_VISIBLE_PAGES + 1 && (
              <>
                <PaginationItem>
                  <span className="px-4">...</span>
                </PaginationItem>
                <PaginationItem>
                  <PaginationLink
                    href="#"
                    onClick={(e) => {
                      e.preventDefault();
                      handlePageChange(totalPages);
                    }}
                  >
                    {totalPages}
                  </PaginationLink>
                </PaginationItem>
              </>
            )}
            
            <PaginationItem>
              <PaginationNext
                href="#"
                onClick={(e) => {
                  e.preventDefault();
                  if (currentPage < totalPages) handlePageChange(currentPage + 1);
                }}
                aria-disabled={currentPage === totalPages}
              />
            </PaginationItem>
          </PaginationContent>
        </Pagination>
      )}
    </div>
  );
}
</file>

<file path="src/components/episode-navigation.tsx">
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface EpisodeNavigationProps {
  currentEpisode: number;
  totalEpisodes: number;
  animeId: number;
}

export function EpisodeNavigation({
  currentEpisode,
  totalEpisodes,
  animeId,
}: EpisodeNavigationProps) {
  return (
    <div className="flex flex-col gap-4">
      <div className="flex items-center gap-2">
        <Button
          variant="outline"
          size="icon"
          asChild
          disabled={currentEpisode <= 1}
        >
          <Link href={`/watch/${animeId}/${currentEpisode - 1}`}>
            <ChevronLeft className="h-4 w-4" />
          </Link>
        </Button>

        <Select
          value={currentEpisode.toString()}
          onValueChange={(value) => {
            window.location.href = `/watch/${animeId}/${value}`;
          }}
        >
          <SelectTrigger className="flex-1">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {Array.from({ length: totalEpisodes }, (_, i) => i + 1).map(
              (episode) => (
                <SelectItem key={episode} value={episode.toString()}>
                  Episode {episode}
                </SelectItem>
              )
            )}
          </SelectContent>
        </Select>

        <Button
          variant="outline"
          size="icon"
          asChild
          disabled={currentEpisode >= totalEpisodes}
        >
          <Link href={`/watch/${animeId}/${currentEpisode + 1}`}>
            <ChevronRight className="h-4 w-4" />
          </Link>
        </Button>
      </div>

      <div className="grid grid-cols-4 gap-2">
        {Array.from({ length: 8 }, (_, i) => {
          const episode = currentEpisode - 4 + i;
          if (episode < 1 || episode > totalEpisodes) return null;

          return (
            <Button
              key={episode}
              variant={episode === currentEpisode ? "default" : "outline"}
              asChild
              className="w-full"
            >
              <Link href={`/watch/${animeId}/${episode}`}>
                {episode}
              </Link>
            </Button>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="src/components/featured-carousel.tsx">
"use client";

import { useState, useCallback, useEffect } from "react";
import Image from "next/image";
import Link from "next/link";
import useEmblaCarousel from "embla-carousel-react";
import { Button } from "@/components/ui/button";
import { WatchButton } from "@/components/watch-button";
import { WatchlistButton } from "@/components/watchlist/watchlist-button";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Media } from "@/types/anilistGraphQLTypes";


export function FeaturedCarousel({ items }: { items: Media[] }) {

  const filteredItems = items.filter(
    (anime) => anime.bannerImage
  );
  
  const [emblaRef, emblaApi] = useEmblaCarousel({ 
    loop: true,
    duration: 30,
    skipSnaps: false,
  });
  const [selectedIndex, setSelectedIndex] = useState(0);
  const [prevBtnDisabled, setPrevBtnDisabled] = useState(true);
  const [nextBtnDisabled, setNextBtnDisabled] = useState(true);

  const scrollPrev = useCallback(() => emblaApi?.scrollPrev(), [emblaApi]);
  const scrollNext = useCallback(() => emblaApi?.scrollNext(), [emblaApi]);

  const onSelect = useCallback(() => {
    if (!emblaApi) return;
    setSelectedIndex(emblaApi.selectedScrollSnap());
    setPrevBtnDisabled(!emblaApi.canScrollPrev());
    setNextBtnDisabled(!emblaApi.canScrollNext());
  }, [emblaApi]);

  useEffect(() => {
    if (!emblaApi) return;
    onSelect();
    emblaApi.on("select", onSelect);
    emblaApi.on("reInit", onSelect);

    // Auto-play functionality
    const autoplayInterval = setInterval(() => {
      if (emblaApi.canScrollNext()) {
        emblaApi.scrollNext();
      } else {
        emblaApi.scrollTo(0); // Reset to first slide
      }
    }, 6000); // Change slide every 6 seconds

    return () => {
      clearInterval(autoplayInterval);
      emblaApi.off("select", onSelect);
      emblaApi.off("reInit", onSelect);
    };
  }, [emblaApi, onSelect]);

  return (
    <div className="relative group h-screen">
      <div className="overflow-hidden h-full" ref={emblaRef}>
        <div className="flex h-full">
          {filteredItems.map((anime) => (
            <div
              key={anime.id}
              className="relative h-screen min-w-full flex-[0_0_100%]"
            >
              <div className="absolute inset-0">
                <Image
                  src={anime.bannerImage || anime.coverImage?.large || ""}
                  alt={anime.title?.english || anime.title?.romaji || ""}
                  fill
                  className="object-cover brightness-[0.7] transition-all duration-500"
                  priority
                />
              </div>
              <div className="absolute inset-0 bg-gradient-to-t from-background via-background/50 to-transparent" />
              <div className="container relative flex h-full items-center pb-24">
                <div className="max-w-3xl space-y-4 px-4 sm:px-6 lg:px-8">
                  <div className="space-y-2">
                    <div className="flex flex-wrap gap-2">
                      {anime.genres?.slice(0, 3).map((genre) => (
                        <Badge key={genre} variant="secondary">
                          {genre}
                        </Badge>
                      ))}
                    </div>
                    <h1 className="text-2xl sm:text-3xl lg:text-4xl font-bold">
                      {anime.title?.english || anime.title?.romaji}
                    </h1>
                  </div>
                  
                  <p className="line-clamp-2 sm:line-clamp-3 text-base sm:text-lg text-muted-foreground">
                    {anime.description?.replace(/<[^>]*>/g, "")}
                  </p>
                  
                  <div className="flex flex-wrap gap-3">
                    <WatchButton anime={anime} size="lg" />
                    <WatchlistButton anime={anime} size="lg" variant="secondary" />
                  </div>

                  <div className="flex flex-wrap gap-x-6 gap-y-2 text-sm text-muted-foreground">
                    {anime.episodes && (
                      <div>{anime.episodes} Episodes</div>
                    )}
                    {anime.duration && (
                      <div>{anime.duration} Min/Ep</div>
                    )}
                    {anime.averageScore && (
                      <div>Score: {(anime.averageScore / 10).toFixed(1)}</div>
                    )}
                    {anime.season && anime.seasonYear && (
                      <div>{`${anime.season.charAt(0) + anime.season.slice(1).toLowerCase()} ${anime.seasonYear}`}</div>
                    )}
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      <div className="absolute left-2 right-2 sm:left-4 sm:right-4 top-1/2 flex -translate-y-1/2 justify-between z-20">
  <Button
    variant="ghost"
    size="icon"
    className="h-8 w-8 sm:h-12 sm:w-12 rounded-full bg-background/50 hover:bg-background/70 transition-all duration-200 backdrop-blur-sm"
    onClick={scrollPrev}
    disabled={prevBtnDisabled}
  >
    <ChevronLeft className="h-4 w-4 sm:h-6 sm:w-6" />
    <span className="sr-only">Previous slide</span>
  </Button>
  <Button
    variant="ghost"
    size="icon"
    className="h-8 w-8 sm:h-12 sm:w-12 rounded-full bg-background/50 hover:bg-background/70 transition-all duration-200 backdrop-blur-sm"
    onClick={scrollNext}
    disabled={nextBtnDisabled}
  >
    <ChevronRight className="h-4 w-4 sm:h-6 sm:w-6" />
    <span className="sr-only">Next slide</span>
  </Button>
</div>

      <div className="absolute bottom-4 sm:bottom-8 left-1/2 flex -translate-x-1/2 gap-1.5 sm:gap-2">
        {filteredItems.map((_, index) => (
          <button
            key={index}
            onClick={() => emblaApi?.scrollTo(index)}
            className={`h-1.5 sm:h-2 transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary ${
              selectedIndex === index
                ? "bg-primary w-6 sm:w-8"
                : "w-1.5 sm:w-2 bg-primary/30 hover:bg-primary/50"
            } rounded-full`}
            aria-label={`Go to slide ${index + 1}`}
          />
        ))}
      </div>
    </div>
  );
}
</file>

<file path="src/components/hero-section.tsx">
import Image from "next/image";
import { Button } from "@/components/ui/button";
import { PlayCircle, Plus } from "lucide-react";
import type { Anime } from "@/lib/anilist";

export function HeroSection({ anime }: { anime: Anime }) {
  return (
    <div className="relative h-[70vh] w-full overflow-hidden">
      <div className="absolute inset-0">
        <Image
          src={anime.bannerImage || anime.coverImage.large}
          alt={anime.title.english || anime.title.romaji}
          fill
          className="object-cover brightness-50"
          priority
        />
      </div>
      <div className="absolute inset-0 bg-gradient-to-t from-background to-transparent" />
      <div className="container relative flex h-full items-end pb-16">
        <div className="max-w-2xl">
          <h1 className="mb-4 text-4xl font-bold">
            {anime.title.english || anime.title.romaji}
          </h1>
          <p className="mb-6 line-clamp-3 text-lg text-muted-foreground">
            {anime.description?.replace(/<[^>]*>/g, "")}
          </p>
          <div className="flex gap-4">
            <Button size="lg">
              <PlayCircle className="mr-2 h-5 w-5" />
              Watch Now
            </Button>
            <Button size="lg" variant="secondary">
              <Plus className="mr-2 h-5 w-5" />
              Add to Watchlist
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/library/my-list-section.tsx">
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/hooks/useAuth";
import { useWatchlist } from "@/hooks/use-watchlist";
import { WatchlistGrid } from "@/components/watchlist/watchlist-grid";
import { LoadingSpinner } from "@/components/loading-spinner";
import type { WatchlistEntry } from "@/types/watchlist";

export function MyListSection() {
  const { isAuthenticated, lists } = useAuth();
  const { watchlist, isLoading: isWatchlistLoading } = useWatchlist();
  const [filteredList, setFilteredList] = useState<WatchlistEntry[]>([]);

  useEffect(() => {
    const entries = isAuthenticated ? lists : watchlist;
    const filtered = entries?.filter(item => 
      item.status !== "completed" && item.status !== "dropped"
    ) || [];
    setFilteredList(filtered);
  }, [isAuthenticated, lists, watchlist]);

  if (isWatchlistLoading) {
    return <LoadingSpinner />;
  }

  if (!filteredList.length) {
    return (
      <div className="text-center py-12">
        <h3 className="text-lg font-medium mb-2">Your list is empty</h3>
        <p className="text-muted-foreground">
          Add some anime to your list to see them here
        </p>
      </div>
    );
  }

  return <WatchlistGrid entries={filteredList} />;
}
</file>

<file path="src/components/loading-spinner.tsx">
export function LoadingSpinner() {
  return (
    <div className="flex h-[200px] items-center justify-center">
      <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent" />
    </div>
  );
}
</file>

<file path="src/components/main-content.tsx">
// Create a new client component
'use client';
import { usePathname } from 'next/navigation';

export function MainContent({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();
  const isHomePage = pathname === '/';
  
  return (
    <main className={`flex-1 ${isHomePage ? '' : 'pt-14 sm:pt-16'}`}>
      {children}
    </main>
  );
}
</file>

<file path="src/components/navbar.tsx">
"use client";

import { useEffect, useState } from "react";
import Link from "next/link";
import Image from "next/image";
import { useTheme } from "next-themes";
import { Button } from "@/components/ui/button";
import { SearchCommand } from "@/components/search-command";
import { useAuth } from "@/hooks/useAuth";
import { getAuthUrl } from "@/lib/auth";
import {
  Moon,
  Sun,
  Menu,
  X,
  PlayCircle,
  BookmarkPlus,
  BarChart2,
} from "lucide-react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

export function Navbar() {
  const { theme, setTheme } = useTheme();
  const { isAuthenticated, user, logout } = useAuth();
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [scrolled, setScrolled] = useState(false);



  const handleLogin = () => {
    window.location.href = getAuthUrl();
  };
  
  const handleLogout = () => {
    // Clear all session storage
    sessionStorage.clear();
    
    // Clear all local storage
    localStorage.clear();
    
    // Refresh the page to reset app state
    window.location.reload();
  };

  useEffect(() => {
    const handleScroll = () => {
      setScrolled(window.scrollY > 0);
    };

    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  
  const navLinks = [
    { href: "/", label: "Home", icon: PlayCircle },
    { href: "/watchlist", label: "Watchlist", icon: BookmarkPlus },
    { href: "/stats", label: "Stats", icon: BarChart2 },
  ];

  return (
    <header className={`fixed top-0 z-50 w-full transition-all duration-300 ${
      scrolled ? 'bg-background/80 backdrop-blur-md border-b border-white/5' : 'bg-transparent'
    }`}>
      <nav className="container flex h-14 sm:h-16 items-center">
        <div className="flex items-center gap-2 sm:gap-6 flex-1">
          <Button
            variant="ghost"
            size="icon"
            className="md:hidden"
            onClick={() => setIsMenuOpen(!isMenuOpen)}
          >
            {isMenuOpen ? (
              <X className="h-5 w-5" />
            ) : (
              <Menu className="h-5 w-5" />
            )}
          </Button>

          <Link href="/" className="flex items-center space-x-2">
            <PlayCircle className="h-6 w-6 text-primary" />
            <span className="hidden font-bold sm:inline-block">AniStream</span>
          </Link>

          <div className="hidden md:flex gap-6">
            {navLinks.map((link) => (
              <Link
                key={link.href}
                href={link.href}
                className="flex items-center gap-2 text-sm font-medium text-muted-foreground transition-colors hover:text-primary"
              >
                <link.icon className="h-4 w-4" />
                {link.label}
              </Link>
            ))}
          </div>
        </div>

        <div className="flex items-center gap-2">
          <SearchCommand />
          <Button
            variant="ghost"
            size="icon"
            onClick={() => setTheme(theme === "light" ? "dark" : "light")}
            className="h-9 w-9 sm:h-10 sm:w-10"
          >
            <Sun className="h-4 w-4 sm:h-5 sm:w-5 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
            <Moon className="absolute h-4 w-4 sm:h-5 sm:w-5 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
            <span className="sr-only">Toggle theme</span>
          </Button>

          {isAuthenticated && user ? (
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" className="relative h-9 w-9 rounded-full">
              <Image
                src={user.avatar?.medium || ""}
                alt={user.name}
                fill
                className="rounded-full object-cover"
              />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end">
            <DropdownMenuItem onClick={handleLogout}>
              Log out
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      ) : (
        <Button 
          variant="outline"
          onClick={handleLogin}
          className="ml-2"
        >
          Login with AniList
        </Button>
      )}
        </div>
      </nav>

      {isMenuOpen && (
        <div className="border-b bg-background p-4 md:hidden">
          <div className="grid gap-2">
            {navLinks.map((link) => (
              <Link
                key={link.href}
                href={link.href}
                className="flex items-center gap-2 text-sm font-medium text-muted-foreground"
                onClick={() => setIsMenuOpen(false)}
              >
                <link.icon className="h-4 w-4" />
                {link.label}
              </Link>
            ))}
          </div>
        </div>
      )}
    </header>
  );
}
</file>

<file path="src/components/providers/query-provider.tsx">
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useState } from 'react'

export default function QueryProvider({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient())

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}
</file>

<file path="src/components/search-command.tsx">
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import Image from "next/image";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  CommandLoading,
} from "@/components/ui/command";
import {
  Dialog,
  DialogContent,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Search } from "lucide-react";
import type { Anime } from "@/lib/anilist";
import { searchAnime } from "@/lib/actions";

export function SearchCommand() {
  const router = useRouter();
  const [open, setOpen] = useState(false);
  const [query, setQuery] = useState("");
  const [results, setResults] = useState<Anime[]>([]);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    const down = (e: KeyboardEvent) => {
      if (e.key === "k" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        setOpen((open) => !open);
      }
    };
    document.addEventListener("keydown", down);
    return () => document.removeEventListener("keydown", down);
  }, []);

  useEffect(() => {
    const searchTimeout = setTimeout(async () => {
      if (query.length >= 2) {
        setIsLoading(true);
        try {
          const data = await searchAnime(query);
          setResults(data.slice(0, 5));
        } catch (error) {
          console.error("Error searching anime:", error);
        } finally {
          setIsLoading(false);
        }
      } else {
        setResults([]);
      }
    }, 300);

    return () => clearTimeout(searchTimeout);
  }, [query]);

  const handleSelect = (path: string) => {
    setOpen(false);
    router.push(path);
  };

  return (
    <>
      <Button
        variant="outline"
        className="relative h-9 w-9 p-0 xl:h-10 xl:w-60 xl:justify-start xl:px-3 xl:py-2"
        onClick={() => setOpen(true)}
      >
        <Search className="h-4 w-4 xl:mr-2" />
        <span className="hidden xl:inline-flex">Search anime...</span>
        <span className="sr-only">Search anime</span>
        <kbd className="pointer-events-none absolute right-1.5 top-2 hidden h-6 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium opacity-100 xl:flex">
          <span className="text-xs">âŒ˜</span>K
        </kbd>
      </Button>
      <Dialog open={open} onOpenChange={setOpen}>
        <DialogContent className="overflow-hidden p-0">
          <DialogTitle className="sr-only">Search Anime</DialogTitle>
          <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
            <CommandInput 
              placeholder="Search anime..." 
              value={query}
              onValueChange={setQuery}
            />
            <CommandList>
              <CommandEmpty>No results found.</CommandEmpty>
              {isLoading && (
                <CommandLoading>Searching...</CommandLoading>
              )}
              {results.length > 0 && (
                <CommandGroup heading="Search Results">
                  {results.map((anime) => (
                    <CommandItem
                      key={anime.id}
                      onSelect={() => handleSelect(`/anime/${anime.id}`)}
                      className="flex items-center gap-2 p-2"
                    >
                      <div className="relative h-16 w-12 flex-none overflow-hidden rounded-sm">
                        <Image
                          src={anime.coverImage.medium}
                          alt={anime.title.english || anime.title.romaji}
                          fill
                          className="object-cover"
                        />
                      </div>
                      <div className="flex flex-col overflow-hidden">
                        <span className="truncate font-medium">
                          {anime.title.english || anime.title.romaji}
                        </span>
                        <span className="text-sm text-muted-foreground">
                          {anime.episodes} Episodes â€¢ {anime.status}
                        </span>
                      </div>
                    </CommandItem>
                  ))}
                </CommandGroup>
              )}
              <CommandGroup heading="Quick Links">
                <CommandItem
                  onSelect={() => handleSelect("/trending")}
                  className="flex items-center gap-2 py-3"
                >
                  Trending Anime
                </CommandItem>
                <CommandItem
                  onSelect={() => handleSelect("/popular")}
                  className="flex items-center gap-2 py-3"
                >
                  Popular This Season
                </CommandItem>
                <CommandItem
                  onSelect={() => handleSelect("/library")}
                  className="flex items-center gap-2 py-3"
                >
                  My Library
                </CommandItem>
                <CommandItem
                  onSelect={() => handleSelect("/search")}
                  className="flex items-center gap-2 py-3 border-t"
                >
                  Advanced Search
                </CommandItem>
              </CommandGroup>
            </CommandList>
          </Command>
        </DialogContent>
      </Dialog>
    </>
  );
}
</file>

<file path="src/components/search-content.tsx">
"use client";

import { useState, useCallback } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { SearchFilters } from "@/components/search/search-filters";
import { SearchResults } from "@/components/search/search-results";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { X } from "lucide-react";
import { searchFilteredAnime } from "@/modules/anilist/anilistsAPI";
import { Media } from "@/types/anilistGraphQLTypes";
import { SearchFilters as Filters } from "@/types/search";

export function SearchContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [query, setQuery] = useState(searchParams.get("q") || "");
  const [results, setResults] = useState<Media[]>([]);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [filters, setFilters] = useState<Filters>({
    genres: [],
    seasons: [],
    year: "",
    format: "",
    sort: "TRENDING_DESC"
  });

  const buildSearchQuery = useCallback((currentFilters: Filters) => {
    let query = "type: ANIME";
    
    if (currentFilters.genres?.length) {
      query += `, genre_in: [${currentFilters.genres.join(", ")}]`;
    }
    
    if (currentFilters.seasons?.length) {
      query += `, season_in: [${currentFilters.seasons.join(", ")}]`;
    }
    
    if (currentFilters.year) {
      query += `, seasonYear: ${currentFilters.year}`;
    }
    
    if (currentFilters.format) {
      query += `, format: ${currentFilters.format}`;
    }
    
    if (currentFilters.sort) {
      query += `, sort: ${currentFilters.sort}`;
    }

    return query;
  }, []);

  const handleSearch = useCallback(async (resetResults = true) => {
    try {
      setIsLoading(true);
      setError(null);

      const searchQuery = buildSearchQuery(filters);
      const data = await searchFilteredAnime(searchQuery, null, resetResults ? 1 : page);

      if (!data?.media) {
        throw new Error("No results found");
      }

      setResults(prev => resetResults ? data.media : [...prev, ...data.media]);
      setHasMore(data.pageInfo?.hasNextPage || false);
      setPage(prev => resetResults ? 2 : prev + 1);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to search anime");
      setHasMore(false);
    } finally {
      setIsLoading(false);
    }
  }, [filters, page, buildSearchQuery]);

  const handleFilterChange = (newFilters: Filters) => {
    setFilters(newFilters);
    handleSearch(true);
  };

  const handleLoadMore = () => {
    if (!isLoading && hasMore) {
      handleSearch(false);
    }
  };

  const handleClear = () => {
    setQuery("");
    setFilters({
      genres: [],
      seasons: [],
      year: "",
      format: "",
      sort: "TRENDING_DESC"
    });
    setResults([]);
    setPage(1);
    setHasMore(true);
    router.push("/search");
  };

  return (
    <div className="container py-6 md:py-8">
      <div className="grid gap-6 md:grid-cols-[250px_1fr]">
        <div className="space-y-4">
          <div className="flex items-center gap-2">
            <Input
              placeholder="Search anime..."
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              onKeyDown={(e) => e.key === "Enter" && handleSearch(true)}
            />
            {(query || filters.genres?.length || filters.seasons?.length || filters.year || filters.format) && (
              <Button
                variant="ghost"
                size="icon"
                onClick={handleClear}
                className="shrink-0"
              >
                <X className="h-4 w-4" />
              </Button>
            )}
          </div>
          <SearchFilters filters={filters} onFilterChange={handleFilterChange} />
        </div>

        <SearchResults
          results={results}
          isLoading={isLoading}
          error={error}
          hasMore={hasMore}
          onLoadMore={handleLoadMore}
        />
      </div>
    </div>
  );
}
</file>

<file path="src/components/search/search-bar.tsx">
"use client";

import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Search, X } from "lucide-react";

interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onClear: () => void;
}

export function SearchBar({ value, onChange, onClear }: SearchBarProps) {
  return (
    <div className="relative">
      <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
      <Input
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder="Search anime..."
        className="pl-9 pr-9"
      />
      {value && (
        <Button
          variant="ghost"
          size="sm"
          className="absolute right-1 top-1/2 h-7 w-7 -translate-y-1/2 p-0"
          onClick={onClear}
        >
          <X className="h-4 w-4" />
        </Button>
      )}
    </div>
  );
}
</file>

<file path="src/components/search/search-filters.tsx">
"use client";

import { GENRES, SEASONS, FORMATS, SORTS } from "@/constants/anilist";
import { SearchFilters as Filters } from "@/types/search";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Separator } from "@/components/ui/separator";
import { Input } from "@/components/ui/input";
import { X } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface SearchFiltersProps {
  filters: Filters;
  onFilterChange: (filters: Filters) => void;
}

export function SearchFilters({ filters, onFilterChange }: SearchFiltersProps) {
  const handleGenreToggle = (genre: string) => {
    const newGenres = filters.genres?.includes(genre)
      ? filters.genres.filter(g => g !== genre)
      : [...(filters.genres || []), genre];
    onFilterChange({ ...filters, genres: newGenres });
  };

  const handleSeasonToggle = (season: string) => {
    const newSeasons = filters.seasons?.includes(season)
      ? filters.seasons.filter(s => s !== season)
      : [...(filters.seasons || []), season];
    onFilterChange({ ...filters, seasons: newSeasons });
  };

  return (
    <div className="space-y-4">
      <div className="space-y-2">
        <h3 className="font-medium">Year</h3>
        <Input
          type="number"
          placeholder="Enter year..."
          value={filters.year}
          onChange={(e) => onFilterChange({ ...filters, year: e.target.value })}
          min={1960}
          max={new Date().getFullYear() + 1}
        />
      </div>

      <Separator />

      <div className="space-y-2">
        <h3 className="font-medium">Format</h3>
        <Select
          value={filters.format || ""}
          onValueChange={(value) => onFilterChange({ ...filters, format: value })}
        >
          <SelectTrigger>
            <SelectValue placeholder="Any format" />
          </SelectTrigger>
          <SelectContent>
            {FORMATS.map((format) => (
              <SelectItem key={format.value} value={format.value}>
                {format.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <Separator />

      <div className="space-y-2">
        <h3 className="font-medium">Sort By</h3>
        <Select
          value={filters.sort || "TRENDING_DESC"}
          onValueChange={(value) => onFilterChange({ ...filters, sort: value })}
        >
          <SelectTrigger>
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {SORTS.map((sort) => (
              <SelectItem key={sort.value} value={sort.value}>
                {sort.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <Separator />

      <div className="space-y-2">
        <h3 className="font-medium">Seasons</h3>
        <div className="flex flex-wrap gap-2">
          {SEASONS.slice(1).map((season) => (
            <Badge
              key={season.value}
              variant={filters.seasons?.includes(season.value) ? "default" : "outline"}
              className="cursor-pointer"
              onClick={() => handleSeasonToggle(season.value)}
            >
              {season.label}
            </Badge>
          ))}
        </div>
      </div>

      <Separator />

      <div className="space-y-2">
        <h3 className="font-medium">Genres</h3>
        <div className="flex flex-wrap gap-2">
          {GENRES.slice(1).map((genre) => (
            <Badge
              key={genre.value}
              variant={filters.genres?.includes(genre.value) ? "default" : "outline"}
              className="cursor-pointer"
              onClick={() => handleGenreToggle(genre.value)}
            >
              {genre.label}
            </Badge>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/search/search-results.tsx">
"use client";

import { useEffect, useRef } from "react";
import { AnimeGrid } from "@/components/anime-grid";
import { LoadingSpinner } from "@/components/loading-spinner";
import { Media } from "@/types/anilistGraphQLTypes";
import { Button } from "@/components/ui/button";

interface SearchResultsProps {
  results: Media[];
  isLoading: boolean;
  error: string | null;
  hasMore: boolean;
  onLoadMore: () => void;
}

export function SearchResults({ 
  results, 
  isLoading, 
  error, 
  hasMore,
  onLoadMore 
}: SearchResultsProps) {
  const observerTarget = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !isLoading) {
          onLoadMore();
        }
      },
      { threshold: 1.0 }
    );

    if (observerTarget.current) {
      observer.observe(observerTarget.current);
    }

    return () => observer.disconnect();
  }, [hasMore, isLoading, onLoadMore]);

  if (error) {
    return (
      <div className="flex flex-col items-center justify-center h-[400px] text-center">
        <p className="text-destructive mb-4">{error}</p>
        <Button onClick={onLoadMore}>Try Again</Button>
      </div>
    );
  }

  if (!results.length && !isLoading) {
    return (
      <div className="flex items-center justify-center h-[400px] text-center">
        <p className="text-muted-foreground">No results found</p>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <AnimeGrid anime={results} />
      
      <div ref={observerTarget} className="h-8 flex items-center justify-center">
        {isLoading && <LoadingSpinner />}
      </div>
    </div>
  );
}
</file>

<file path="src/components/shared/cached-images.tsx">
import Image from 'next/image'

interface CachedImageProps {
  src: string
  alt: string
  width: number
  height: number
  className?: string
  priority?: boolean
  loading: string
}

export function CachedImage({
  src,
  alt,
  width,
  height,
  className,
  priority = true,
  loading = "eager"
}: CachedImageProps) {
  return (
    <Image
      src={src}
      alt={alt}
      width={width}
      height={height}
      className={className}
      priority={priority}
      loading={loading as "eager" | "lazy"}
      quality={85}
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gHYSUNDX1BST0ZJTEUAAQEAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADb/2wBDABQODxIPDRQSEBIXFRQdHx4eHRoaHSQrJyEwPENBLzM0Lys5PFJCRjdLNyk3RV1CR0VQZk9PNlduVFZfR1BFZF3/2wBDARUXFx4aHR4eHV3KHSodXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV3/wAARCAAIAAoDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAb/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwCdABmX/9k="
    />
  )
}
</file>

<file path="src/components/shared/cached-links.tsx">
import Link from 'next/link'
import { useQuery } from '@tanstack/react-query'
import { getUniversalEpisodeUrl } from '@/modules/providers/api'
import { ListAnimeData } from '@/types/anilistAPITypes'

interface CachedLinkProps {
  listAnimeData: ListAnimeData
  episode: number
  children: React.ReactNode
}

export function CachedLink({ listAnimeData, episode, children }: CachedLinkProps) {
  // This will cache the episode URL data
  const { data: episodeUrl } = useQuery({
    queryKey: ['episode', listAnimeData.media?.id, episode],
    queryFn: () => getUniversalEpisodeUrl(listAnimeData, episode),
    staleTime: 1000 * 60 * 5, // Consider data fresh for 5 minutes
    gcTime: 1000 * 60 * 30 // Keep in cache for 30 minutes
  })

  return (
    <Link 
      href={`/watch/${listAnimeData.media?.id}/${episode}`}
      prefetch={true}
    >
      {children}
    </Link>
  )
}
</file>

<file path="src/components/stats/genre-distribution.tsx">
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Cell, Pie, PieChart, ResponsiveContainer, Tooltip } from "recharts";

interface GenreDistributionProps {
  data: Array<{
    genre: string;
    count: number;
  }>;
}

export function GenreDistribution({ data }: GenreDistributionProps) {
  const COLORS = [
    "hsl(var(--primary))",
    "hsl(var(--secondary))",
    "hsl(var(--accent))",
    "hsl(var(--muted))",
  ];

  return (
    <Card className="col-span-4">
      <CardHeader>
        <CardTitle>Genre Distribution</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-[300px]">
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={data}
                dataKey="count"
                nameKey="genre"
                cx="50%"
                cy="50%"
                outerRadius={100}
                label={(entry) => entry.genre}
              >
                {data.map((_, index) => (
                  <Cell 
                    key={`cell-${index}`} 
                    fill={COLORS[index % COLORS.length]} 
                  />
                ))}
              </Pie>
              <Tooltip
                content={({ active, payload }) => {
                  if (active && payload && payload.length) {
                    return (
                      <div className="rounded-lg border bg-background p-2 shadow-sm">
                        <div className="grid grid-cols-2 gap-2">
                          <div className="flex flex-col">
                            <span className="text-[0.70rem] uppercase text-muted-foreground">
                              Genre
                            </span>
                            <span className="font-bold text-muted-foreground">
                              {payload[0].name}
                            </span>
                          </div>
                          <div className="flex flex-col">
                            <span className="text-[0.70rem] uppercase text-muted-foreground">
                              Count
                            </span>
                            <span className="font-bold">
                              {payload[0].value}
                            </span>
                          </div>
                        </div>
                      </div>
                    );
                  }
                  return null;
                }}
              />
            </PieChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/stats/rating-distribution.tsx">
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Bar, BarChart, ResponsiveContainer, XAxis, YAxis, Tooltip } from "recharts";

interface RatingDistributionProps {
  data: Array<{
    rating: number;
    count: number;
  }>;
}

export function RatingDistribution({ data }: RatingDistributionProps) {
  return (
    <Card className="col-span-4">
      <CardHeader>
        <CardTitle>Rating Distribution</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-[300px]">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={data}>
              <XAxis
                dataKey="rating"
                stroke="#888888"
                fontSize={12}
                tickFormatter={(value) => `${value}/10`}
              />
              <YAxis
                stroke="#888888"
                fontSize={12}
                allowDecimals={false}
              />
              <Tooltip
                content={({ active, payload }) => {
                  if (active && payload && payload.length) {
                    return (
                      <div className="rounded-lg border bg-background p-2 shadow-sm">
                        <div className="grid grid-cols-2 gap-2">
                          <div className="flex flex-col">
                            <span className="text-[0.70rem] uppercase text-muted-foreground">
                              Rating
                            </span>
                            <span className="font-bold text-muted-foreground">
                              {payload[0].payload.rating}/10
                            </span>
                          </div>
                          <div className="flex flex-col">
                            <span className="text-[0.70rem] uppercase text-muted-foreground">
                              Count
                            </span>
                            <span className="font-bold">
                              {payload[0].value}
                            </span>
                          </div>
                        </div>
                      </div>
                    );
                  }
                  return null;
                }}
              />
              <Bar
                dataKey="count"
                style={{
                  fill: "hsl(var(--primary))",
                  opacity: 0.9,
                }}
              />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/stats/stats-overview.tsx">
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

interface StatsOverviewProps {
  totalAnime: number;
  totalEpisodes: number;
  averageScore: number;
  watchTime: number;
}

export function StatsOverview({ 
  totalAnime, 
  totalEpisodes, 
  averageScore, 
  watchTime 
}: StatsOverviewProps) {
  const stats = [
    {
      title: "Total Anime",
      value: totalAnime,
      unit: "",
    },
    {
      title: "Episodes Watched",
      value: totalEpisodes,
      unit: "eps",
    },
    {
      title: "Average Score",
      value: averageScore.toFixed(1),
      unit: "/10",
    },
    {
      title: "Watch Time",
      value: Math.round(watchTime),
      unit: "hrs",
    },
  ];

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
      {stats.map((stat) => (
        <Card key={stat.title}>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">
              {stat.title}
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {stat.value}
              <span className="text-sm font-normal text-muted-foreground ml-1">
                {stat.unit}
              </span>
            </div>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}
</file>

<file path="src/components/stats/watch-history.tsx">
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Line, LineChart, ResponsiveContainer, Tooltip, XAxis, YAxis } from "recharts";
import { formatDate } from "@/lib/utils";

interface WatchHistoryProps {
  data: Array<{
    date: string;
    episodes: number;
  }>;
}

export function WatchHistory({ data }: WatchHistoryProps) {
  return (
    <Card className="col-span-4">
      <CardHeader>
        <CardTitle>Watch History</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-[300px]">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={data}>
              <XAxis 
                dataKey="date" 
                tickFormatter={(value) => formatDate(value)}
                stroke="#888888"
                fontSize={12}
              />
              <YAxis
                stroke="#888888"
                fontSize={12}
                tickFormatter={(value) => `${value} eps`}
              />
              <Tooltip
                content={({ active, payload }) => {
                  if (active && payload && payload.length) {
                    return (
                      <div className="rounded-lg border bg-background p-2 shadow-sm">
                        <div className="grid grid-cols-2 gap-2">
                          <div className="flex flex-col">
                            <span className="text-[0.70rem] uppercase text-muted-foreground">
                              Date
                            </span>
                            <span className="font-bold text-muted-foreground">
                              {formatDate(payload[0].payload.date)}
                            </span>
                          </div>
                          <div className="flex flex-col">
                            <span className="text-[0.70rem] uppercase text-muted-foreground">
                              Episodes
                            </span>
                            <span className="font-bold">
                              {payload[0].value}
                            </span>
                          </div>
                        </div>
                      </div>
                    );
                  }
                  return null;
                }}
              />
              <Line
                type="monotone"
                dataKey="episodes"
                strokeWidth={2}
                activeDot={{
                  r: 4,
                  style: { fill: "hsl(var(--primary))" },
                }}
                style={{
                  stroke: "hsl(var(--primary))",
                }}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/theme-provider.tsx">
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";
import { type ThemeProviderProps } from "next-themes/dist/types";

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}
</file>

<file path="src/components/ui/accordion.tsx">
'use client';

import * as React from 'react';
import * as AccordionPrimitive from '@radix-ui/react-accordion';
import { ChevronDown } from 'lucide-react';

import { cn } from '@/lib/utils';

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn('border-b', className)}
    {...props}
  />
));
AccordionItem.displayName = 'AccordionItem';

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        'flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180',
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn('pb-4 pt-0', className)}>{children}</div>
  </AccordionPrimitive.Content>
));

AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };
</file>

<file path="src/components/ui/alert-dialog.tsx">
'use client';

import * as React from 'react';
import * as AlertDialogPrimitive from '@radix-ui/react-alert-dialog';

import { cn } from '@/lib/utils';
import { buttonVariants } from '@/components/ui/button';

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-2 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
AlertDialogHeader.displayName = 'AlertDialogHeader';

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
AlertDialogFooter.displayName = 'AlertDialogFooter';

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold', className)}
    {...props}
  />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: 'outline' }),
      'mt-2 sm:mt-0',
      className
    )}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
};
</file>

<file path="src/components/ui/alert.tsx">
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const alertVariants = cva(
  'relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground',
  {
    variants: {
      variant: {
        default: 'bg-background text-foreground',
        destructive:
          'border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
));
Alert.displayName = 'Alert';

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn('mb-1 font-medium leading-none tracking-tight', className)}
    {...props}
  />
));
AlertTitle.displayName = 'AlertTitle';

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('text-sm [&_p]:leading-relaxed', className)}
    {...props}
  />
));
AlertDescription.displayName = 'AlertDescription';

export { Alert, AlertTitle, AlertDescription };
</file>

<file path="src/components/ui/aspect-ratio.tsx">
'use client';

import * as AspectRatioPrimitive from '@radix-ui/react-aspect-ratio';

const AspectRatio = AspectRatioPrimitive.Root;

export { AspectRatio };
</file>

<file path="src/components/ui/avatar.tsx">
'use client';

import * as React from 'react';
import * as AvatarPrimitive from '@radix-ui/react-avatar';

import { cn } from '@/lib/utils';

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      'relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full',
      className
    )}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn('aspect-square h-full w-full', className)}
    {...props}
  />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      'flex h-full w-full items-center justify-center rounded-full bg-muted',
      className
    )}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

export { Avatar, AvatarImage, AvatarFallback };
</file>

<file path="src/components/ui/badge.tsx">
import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const badgeVariants = cva(
  'inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground hover:bg-primary/80',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',
        destructive:
          'border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80',
        outline: 'text-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/breadcrumb.tsx">
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { ChevronRight, MoreHorizontal } from 'lucide-react';

import { cn } from '@/lib/utils';

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<'nav'> & {
    separator?: React.ReactNode;
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />);
Breadcrumb.displayName = 'Breadcrumb';

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<'ol'>
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      'flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5',
      className
    )}
    {...props}
  />
));
BreadcrumbList.displayName = 'BreadcrumbList';

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<'li'>
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn('inline-flex items-center gap-1.5', className)}
    {...props}
  />
));
BreadcrumbItem.displayName = 'BreadcrumbItem';

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<'a'> & {
    asChild?: boolean;
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : 'a';

  return (
    <Comp
      ref={ref}
      className={cn('transition-colors hover:text-foreground', className)}
      {...props}
    />
  );
});
BreadcrumbLink.displayName = 'BreadcrumbLink';

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<'span'>
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn('font-normal text-foreground', className)}
    {...props}
  />
));
BreadcrumbPage.displayName = 'BreadcrumbPage';

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<'li'>) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn('[&>svg]:size-3.5', className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
);
BreadcrumbSeparator.displayName = 'BreadcrumbSeparator';

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<'span'>) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn('flex h-9 w-9 items-center justify-center', className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
);
BreadcrumbEllipsis.displayName = 'BreadcrumbElipssis';

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
};
</file>

<file path="src/components/ui/button.tsx">
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const buttonVariants = cva(
  'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground hover:bg-primary/90',
        destructive:
          'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline:
          'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
        secondary:
          'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
        icon: 'h-10 w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button';
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = 'Button';

export { Button, buttonVariants };
</file>

<file path="src/components/ui/calendar.tsx">
'use client';

import * as React from 'react';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { DayPicker } from 'react-day-picker';

import { cn } from '@/lib/utils';
import { buttonVariants } from '@/components/ui/button';

export type CalendarProps = React.ComponentProps<typeof DayPicker>;

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn('p-3', className)}
      classNames={{
        months: 'flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0',
        month: 'space-y-4',
        caption: 'flex justify-center pt-1 relative items-center',
        caption_label: 'text-sm font-medium',
        nav: 'space-x-1 flex items-center',
        nav_button: cn(
          buttonVariants({ variant: 'outline' }),
          'h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100'
        ),
        nav_button_previous: 'absolute left-1',
        nav_button_next: 'absolute right-1',
        table: 'w-full border-collapse space-y-1',
        head_row: 'flex',
        head_cell:
          'text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]',
        row: 'flex w-full mt-2',
        cell: 'h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20',
        day: cn(
          buttonVariants({ variant: 'ghost' }),
          'h-9 w-9 p-0 font-normal aria-selected:opacity-100'
        ),
        day_range_end: 'day-range-end',
        day_selected:
          'bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground',
        day_today: 'bg-accent text-accent-foreground',
        day_outside:
          'day-outside text-muted-foreground opacity-50 aria-selected:bg-accent/50 aria-selected:text-muted-foreground aria-selected:opacity-30',
        day_disabled: 'text-muted-foreground opacity-50',
        day_range_middle:
          'aria-selected:bg-accent aria-selected:text-accent-foreground',
        day_hidden: 'invisible',
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  );
}
Calendar.displayName = 'Calendar';

export { Calendar };
</file>

<file path="src/components/ui/card.tsx">
import * as React from 'react';

import { cn } from '@/lib/utils';

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      'rounded-lg border bg-card text-card-foreground shadow-sm',
      className
    )}
    {...props}
  />
));
Card.displayName = 'Card';

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex flex-col space-y-1.5 p-6', className)}
    {...props}
  />
));
CardHeader.displayName = 'CardHeader';

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      'text-2xl font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
));
CardTitle.displayName = 'CardTitle';

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
CardDescription.displayName = 'CardDescription';

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
));
CardContent.displayName = 'CardContent';

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex items-center p-6 pt-0', className)}
    {...props}
  />
));
CardFooter.displayName = 'CardFooter';

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardDescription,
  CardContent,
};
</file>

<file path="src/components/ui/carousel.tsx">
'use client';

import * as React from 'react';
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from 'embla-carousel-react';
import { ArrowLeft, ArrowRight } from 'lucide-react';

import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: 'horizontal' | 'vertical';
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error('useCarousel must be used within a <Carousel />');
  }

  return context;
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = 'horizontal',
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === 'horizontal' ? 'x' : 'y',
      },
      plugins
    );
    const [canScrollPrev, setCanScrollPrev] = React.useState(false);
    const [canScrollNext, setCanScrollNext] = React.useState(false);

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return;
      }

      setCanScrollPrev(api.canScrollPrev());
      setCanScrollNext(api.canScrollNext());
    }, []);

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev();
    }, [api]);

    const scrollNext = React.useCallback(() => {
      api?.scrollNext();
    }, [api]);

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === 'ArrowLeft') {
          event.preventDefault();
          scrollPrev();
        } else if (event.key === 'ArrowRight') {
          event.preventDefault();
          scrollNext();
        }
      },
      [scrollPrev, scrollNext]
    );

    React.useEffect(() => {
      if (!api || !setApi) {
        return;
      }

      setApi(api);
    }, [api, setApi]);

    React.useEffect(() => {
      if (!api) {
        return;
      }

      onSelect(api);
      api.on('reInit', onSelect);
      api.on('select', onSelect);

      return () => {
        api?.off('select', onSelect);
      };
    }, [api, onSelect]);

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === 'y' ? 'vertical' : 'horizontal'),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn('relative', className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    );
  }
);
Carousel.displayName = 'Carousel';

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel();

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          'flex',
          orientation === 'horizontal' ? '-ml-4' : '-mt-4 flex-col',
          className
        )}
        {...props}
      />
    </div>
  );
});
CarouselContent.displayName = 'CarouselContent';

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel();

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        'min-w-0 shrink-0 grow-0 basis-full',
        orientation === 'horizontal' ? 'pl-4' : 'pt-4',
        className
      )}
      {...props}
    />
  );
});
CarouselItem.displayName = 'CarouselItem';

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = 'outline', size = 'icon', ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        'absolute  h-8 w-8 rounded-full',
        orientation === 'horizontal'
          ? '-left-12 top-1/2 -translate-y-1/2'
          : '-top-12 left-1/2 -translate-x-1/2 rotate-90',
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  );
});
CarouselPrevious.displayName = 'CarouselPrevious';

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = 'outline', size = 'icon', ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        'absolute h-8 w-8 rounded-full',
        orientation === 'horizontal'
          ? '-right-12 top-1/2 -translate-y-1/2'
          : '-bottom-12 left-1/2 -translate-x-1/2 rotate-90',
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  );
});
CarouselNext.displayName = 'CarouselNext';

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
};
</file>

<file path="src/components/ui/chart.tsx">
'use client';

import * as React from 'react';
import * as RechartsPrimitive from 'recharts';

import { cn } from '@/lib/utils';

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: '', dark: '.dark' } as const;

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode;
    icon?: React.ComponentType;
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  );
};

type ChartContextProps = {
  config: ChartConfig;
};

const ChartContext = React.createContext<ChartContextProps | null>(null);

function useChart() {
  const context = React.useContext(ChartContext);

  if (!context) {
    throw new Error('useChart must be used within a <ChartContainer />');
  }

  return context;
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> & {
    config: ChartConfig;
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >['children'];
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId();
  const chartId = `chart-${id || uniqueId.replace(/:/g, '')}`;

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  );
});
ChartContainer.displayName = 'Chart';

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  );

  if (!colorConfig.length) {
    return null;
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color;
    return color ? `  --color-${key}: ${color};` : null;
  })
  .join('\n')}
}
`
          )
          .join('\n'),
      }}
    />
  );
};

const ChartTooltip = RechartsPrimitive.Tooltip;

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<'div'> & {
      hideLabel?: boolean;
      hideIndicator?: boolean;
      indicator?: 'line' | 'dot' | 'dashed';
      nameKey?: string;
      labelKey?: string;
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = 'dot',
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart();

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null;
      }

      const [item] = payload;
      const key = `${labelKey || item.dataKey || item.name || 'value'}`;
      const itemConfig = getPayloadConfigFromPayload(config, item, key);
      const value =
        !labelKey && typeof label === 'string'
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label;

      if (labelFormatter) {
        return (
          <div className={cn('font-medium', labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        );
      }

      if (!value) {
        return null;
      }

      return <div className={cn('font-medium', labelClassName)}>{value}</div>;
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ]);

    if (!active || !payload?.length) {
      return null;
    }

    const nestLabel = payload.length === 1 && indicator !== 'dot';

    return (
      <div
        ref={ref}
        className={cn(
          'grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl',
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || 'value'}`;
            const itemConfig = getPayloadConfigFromPayload(config, item, key);
            const indicatorColor = color || item.payload.fill || item.color;

            return (
              <div
                key={item.dataKey}
                className={cn(
                  'flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground',
                  indicator === 'dot' && 'items-center'
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            'shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]',
                            {
                              'h-2.5 w-2.5': indicator === 'dot',
                              'w-1': indicator === 'line',
                              'w-0 border-[1.5px] border-dashed bg-transparent':
                                indicator === 'dashed',
                              'my-0.5': nestLabel && indicator === 'dashed',
                            }
                          )}
                          style={
                            {
                              '--color-bg': indicatorColor,
                              '--color-border': indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        'flex flex-1 justify-between leading-none',
                        nestLabel ? 'items-end' : 'items-center'
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            );
          })}
        </div>
      </div>
    );
  }
);
ChartTooltipContent.displayName = 'ChartTooltip';

const ChartLegend = RechartsPrimitive.Legend;

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<'div'> &
    Pick<RechartsPrimitive.LegendProps, 'payload' | 'verticalAlign'> & {
      hideIcon?: boolean;
      nameKey?: string;
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = 'bottom', nameKey },
    ref
  ) => {
    const { config } = useChart();

    if (!payload?.length) {
      return null;
    }

    return (
      <div
        ref={ref}
        className={cn(
          'flex items-center justify-center gap-4',
          verticalAlign === 'top' ? 'pb-3' : 'pt-3',
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || 'value'}`;
          const itemConfig = getPayloadConfigFromPayload(config, item, key);

          return (
            <div
              key={item.value}
              className={cn(
                'flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground'
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          );
        })}
      </div>
    );
  }
);
ChartLegendContent.displayName = 'ChartLegend';

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== 'object' || payload === null) {
    return undefined;
  }

  const payloadPayload =
    'payload' in payload &&
    typeof payload.payload === 'object' &&
    payload.payload !== null
      ? payload.payload
      : undefined;

  let configLabelKey: string = key;

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === 'string'
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string;
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === 'string'
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string;
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config];
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
};
</file>

<file path="src/components/ui/checkbox.tsx">
'use client';

import * as React from 'react';
import * as CheckboxPrimitive from '@radix-ui/react-checkbox';
import { Check } from 'lucide-react';

import { cn } from '@/lib/utils';

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      'peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground',
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn('flex items-center justify-center text-current')}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="src/components/ui/collapsible.tsx">
'use client';

import * as CollapsiblePrimitive from '@radix-ui/react-collapsible';

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleTrigger, CollapsibleContent };
</file>

<file path="src/components/ui/command.tsx">
'use client';

import * as React from 'react';
import { type DialogProps } from '@radix-ui/react-dialog';
import { Command as CommandPrimitive } from 'cmdk';
import { Search } from 'lucide-react';

import { cn } from '@/lib/utils';
import { Dialog, DialogContent } from '@/components/ui/dialog';

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      'flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground',
      className
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        'flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn('max-h-[300px] overflow-y-auto overflow-x-hidden', className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
));

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      'overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground',
      className
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 h-px bg-border', className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        'ml-auto text-xs tracking-widest text-muted-foreground',
        className
      )}
      {...props}
    />
  );
};
CommandShortcut.displayName = 'CommandShortcut';

const CommandLoading = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Loading>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Loading>
>((props, ref) => (
  <CommandPrimitive.Loading
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
));

CommandLoading.displayName = CommandPrimitive.Loading.displayName;


export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
  CommandLoading,
};
</file>

<file path="src/components/ui/context-menu.tsx">
'use client';

import * as React from 'react';
import * as ContextMenuPrimitive from '@radix-ui/react-context-menu';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const ContextMenu = ContextMenuPrimitive.Root;

const ContextMenuTrigger = ContextMenuPrimitive.Trigger;

const ContextMenuGroup = ContextMenuPrimitive.Group;

const ContextMenuPortal = ContextMenuPrimitive.Portal;

const ContextMenuSub = ContextMenuPrimitive.Sub;

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
));
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName;

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
));
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName;

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
));
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
));
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName;

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      'px-2 py-1.5 text-sm font-semibold text-foreground',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-border', className)}
    {...props}
  />
));
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName;

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        'ml-auto text-xs tracking-widest text-muted-foreground',
        className
      )}
      {...props}
    />
  );
};
ContextMenuShortcut.displayName = 'ContextMenuShortcut';

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};
</file>

<file path="src/components/ui/dialog.tsx">
'use client';

import * as React from 'react';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg',
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-1.5 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
DialogHeader.displayName = 'DialogHeader';

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
DialogFooter.displayName = 'DialogFooter';

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      'text-lg font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};
</file>

<file path="src/components/ui/drawer.tsx">
'use client';

import * as React from 'react';
import { Drawer as DrawerPrimitive } from 'vaul';

import { cn } from '@/lib/utils';

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
);
Drawer.displayName = 'Drawer';

const DrawerTrigger = DrawerPrimitive.Trigger;

const DrawerPortal = DrawerPrimitive.Portal;

const DrawerClose = DrawerPrimitive.Close;

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn('fixed inset-0 z-50 bg-black/80', className)}
    {...props}
  />
));
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName;

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        'fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background',
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
));
DrawerContent.displayName = 'DrawerContent';

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('grid gap-1.5 p-4 text-center sm:text-left', className)}
    {...props}
  />
);
DrawerHeader.displayName = 'DrawerHeader';

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('mt-auto flex flex-col gap-2 p-4', className)}
    {...props}
  />
);
DrawerFooter.displayName = 'DrawerFooter';

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      'text-lg font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
));
DrawerTitle.displayName = DrawerPrimitive.Title.displayName;

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
DrawerDescription.displayName = DrawerPrimitive.Description.displayName;

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
};
</file>

<file path="src/components/ui/dropdown-menu.tsx">
'use client';

import * as React from 'react';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      'px-2 py-1.5 text-sm font-semibold',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn('ml-auto text-xs tracking-widest opacity-60', className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = 'DropdownMenuShortcut';

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="src/components/ui/form.tsx">
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { Slot } from '@radix-ui/react-slot';
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from 'react-hook-form';

import { cn } from '@/lib/utils';
import { Label } from '@/components/ui/label';

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>');
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn('space-y-2', className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = 'FormItem';

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && 'text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = 'FormLabel';

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = 'FormControl';

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn('text-sm text-muted-foreground', className)}
      {...props}
    />
  );
});
FormDescription.displayName = 'FormDescription';

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn('text-sm font-medium text-destructive', className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = 'FormMessage';

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};
</file>

<file path="src/components/ui/hover-card.tsx">
'use client';

import * as React from 'react';
import * as HoverCardPrimitive from '@radix-ui/react-hover-card';

import { cn } from '@/lib/utils';

const HoverCard = HoverCardPrimitive.Root;

const HoverCardTrigger = HoverCardPrimitive.Trigger;

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      'z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName;

export { HoverCard, HoverCardTrigger, HoverCardContent };
</file>

<file path="src/components/ui/input-otp.tsx">
'use client';

import * as React from 'react';
import { OTPInput, OTPInputContext } from 'input-otp';
import { Dot } from 'lucide-react';

import { cn } from '@/lib/utils';

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      'flex items-center gap-2 has-[:disabled]:opacity-50',
      containerClassName
    )}
    className={cn('disabled:cursor-not-allowed', className)}
    {...props}
  />
));
InputOTP.displayName = 'InputOTP';

const InputOTPGroup = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('flex items-center', className)} {...props} />
));
InputOTPGroup.displayName = 'InputOTPGroup';

const InputOTPSlot = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext);
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index];

  return (
    <div
      ref={ref}
      className={cn(
        'relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md',
        isActive && 'z-10 ring-2 ring-ring ring-offset-background',
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  );
});
InputOTPSlot.displayName = 'InputOTPSlot';

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<'div'>,
  React.ComponentPropsWithoutRef<'div'>
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
));
InputOTPSeparator.displayName = 'InputOTPSeparator';

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator };
</file>

<file path="src/components/ui/input.tsx">
import * as React from 'react';

import { cn } from '@/lib/utils';

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          'flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = 'Input';

export { Input };
</file>

<file path="src/components/ui/label.tsx">
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const labelVariants = cva(
  'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70'
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="src/components/ui/menubar.tsx">
'use client';

import * as React from 'react';
import * as MenubarPrimitive from '@radix-ui/react-menubar';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const MenubarMenu = MenubarPrimitive.Menu;

const MenubarGroup = MenubarPrimitive.Group;

const MenubarPortal = MenubarPrimitive.Portal;

const MenubarSub = MenubarPrimitive.Sub;

const MenubarRadioGroup = MenubarPrimitive.RadioGroup;

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      'flex h-10 items-center space-x-1 rounded-md border bg-background p-1',
      className
    )}
    {...props}
  />
));
Menubar.displayName = MenubarPrimitive.Root.displayName;

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      className
    )}
    {...props}
  />
));
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName;

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      inset && 'pl-8',
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
));
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName;

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName;

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = 'start', alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          'z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
);
MenubarContent.displayName = MenubarPrimitive.Content.displayName;

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
MenubarItem.displayName = MenubarPrimitive.Item.displayName;

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
));
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName;

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
));
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName;

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      'px-2 py-1.5 text-sm font-semibold',
      inset && 'pl-8',
      className
    )}
    {...props}
  />
));
MenubarLabel.displayName = MenubarPrimitive.Label.displayName;

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName;

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        'ml-auto text-xs tracking-widest text-muted-foreground',
        className
      )}
      {...props}
    />
  );
};
MenubarShortcut.displayname = 'MenubarShortcut';

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
};
</file>

<file path="src/components/ui/navigation-menu.tsx">
import * as React from 'react';
import * as NavigationMenuPrimitive from '@radix-ui/react-navigation-menu';
import { cva } from 'class-variance-authority';
import { ChevronDown } from 'lucide-react';

import { cn } from '@/lib/utils';

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      'relative z-10 flex max-w-max flex-1 items-center justify-center',
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      'group flex flex-1 list-none items-center justify-center space-x-1',
      className
    )}
    {...props}
  />
));
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;

const NavigationMenuItem = NavigationMenuPrimitive.Item;

const navigationMenuTriggerStyle = cva(
  'group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50'
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), 'group', className)}
    {...props}
  >
    {children}{' '}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      'left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ',
      className
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;

const NavigationMenuLink = NavigationMenuPrimitive.Link;

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn('absolute left-0 top-full flex justify-center')}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        'origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]',
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      'top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in',
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName;

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
};
</file>

<file path="src/components/ui/pagination.tsx">
import * as React from 'react';
import { ChevronLeft, ChevronRight, MoreHorizontal } from 'lucide-react';

import { cn } from '@/lib/utils';
import { ButtonProps, buttonVariants } from '@/components/ui/button';

const Pagination = ({ className, ...props }: React.ComponentProps<'nav'>) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn('mx-auto flex w-full justify-center', className)}
    {...props}
  />
);
Pagination.displayName = 'Pagination';

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<'ul'>
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn('flex flex-row items-center gap-1', className)}
    {...props}
  />
));
PaginationContent.displayName = 'PaginationContent';

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<'li'>
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn('', className)} {...props} />
));
PaginationItem.displayName = 'PaginationItem';

type PaginationLinkProps = {
  isActive?: boolean;
} & Pick<ButtonProps, 'size'> &
  React.ComponentProps<'a'>;

const PaginationLink = ({
  className,
  isActive,
  size = 'icon',
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? 'page' : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? 'outline' : 'ghost',
        size,
      }),
      className
    )}
    {...props}
  />
);
PaginationLink.displayName = 'PaginationLink';

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn('gap-1 pl-2.5', className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
);
PaginationPrevious.displayName = 'PaginationPrevious';

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn('gap-1 pr-2.5', className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
);
PaginationNext.displayName = 'PaginationNext';

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<'span'>) => (
  <span
    aria-hidden
    className={cn('flex h-9 w-9 items-center justify-center', className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
);
PaginationEllipsis.displayName = 'PaginationEllipsis';

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
};
</file>

<file path="src/components/ui/popover.tsx">
'use client';

import * as React from 'react';
import * as PopoverPrimitive from '@radix-ui/react-popover';

import { cn } from '@/lib/utils';

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        'z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent };
</file>

<file path="src/components/ui/progress.tsx">
'use client';

import * as React from 'react';
import * as ProgressPrimitive from '@radix-ui/react-progress';

import { cn } from '@/lib/utils';

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      'relative h-4 w-full overflow-hidden rounded-full bg-secondary',
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };
</file>

<file path="src/components/ui/radio-group.tsx">
'use client';

import * as React from 'react';
import * as RadioGroupPrimitive from '@radix-ui/react-radio-group';
import { Circle } from 'lucide-react';

import { cn } from '@/lib/utils';

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn('grid gap-2', className)}
      {...props}
      ref={ref}
    />
  );
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        'aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };
</file>

<file path="src/components/ui/resizable.tsx">
'use client';

import { GripVertical } from 'lucide-react';
import * as ResizablePrimitive from 'react-resizable-panels';

import { cn } from '@/lib/utils';

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      'flex h-full w-full data-[panel-group-direction=vertical]:flex-col',
      className
    )}
    {...props}
  />
);

const ResizablePanel = ResizablePrimitive.Panel;

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      'relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90',
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
);

export { ResizablePanelGroup, ResizablePanel, ResizableHandle };
</file>

<file path="src/components/ui/scroll-area.tsx">
'use client';

import * as React from 'react';
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area';

import { cn } from '@/lib/utils';

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn('relative overflow-hidden', className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = 'vertical', ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      'flex touch-none select-none transition-colors',
      orientation === 'vertical' &&
        'h-full w-2.5 border-l border-l-transparent p-[1px]',
      orientation === 'horizontal' &&
        'h-2.5 flex-col border-t border-t-transparent p-[1px]',
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };
</file>

<file path="src/components/ui/select.tsx">
'use client';

import * as React from 'react';
import * as SelectPrimitive from '@radix-ui/react-select';
import { Check, ChevronDown, ChevronUp } from 'lucide-react';

import { cn } from '@/lib/utils';

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]'
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
</file>

<file path="src/components/ui/separator.tsx">
'use client';

import * as React from 'react';
import * as SeparatorPrimitive from '@radix-ui/react-separator';

import { cn } from '@/lib/utils';

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = 'horizontal', decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        'shrink-0 bg-border',
        orientation === 'horizontal' ? 'h-[1px] w-full' : 'h-full w-[1px]',
        className
      )}
      {...props}
    />
  )
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };
</file>

<file path="src/components/ui/sheet.tsx">
'use client';

import * as React from 'react';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
        right:
          'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
      },
    },
    defaultVariants: {
      side: 'right',
    },
  }
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-2 text-center sm:text-left',
      className
    )}
    {...props}
  />
);
SheetHeader.displayName = 'SheetHeader';

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className
    )}
    {...props}
  />
);
SheetFooter.displayName = 'SheetFooter';

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from '@/lib/utils';

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn('animate-pulse rounded-md bg-muted', className)}
      {...props}
    />
  );
}

export { Skeleton };
</file>

<file path="src/components/ui/slider.tsx">
'use client';

import * as React from 'react';
import * as SliderPrimitive from '@radix-ui/react-slider';

import { cn } from '@/lib/utils';

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      'relative flex w-full touch-none select-none items-center',
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };
</file>

<file path="src/components/ui/sonner.tsx">
'use client';

import { useTheme } from 'next-themes';
import { Toaster as Sonner } from 'sonner';

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = 'system' } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps['theme']}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            'group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg',
          description: 'group-[.toast]:text-muted-foreground',
          actionButton:
            'group-[.toast]:bg-primary group-[.toast]:text-primary-foreground',
          cancelButton:
            'group-[.toast]:bg-muted group-[.toast]:text-muted-foreground',
        },
      }}
      {...props}
    />
  );
};

export { Toaster };
</file>

<file path="src/components/ui/switch.tsx">
'use client';

import * as React from 'react';
import * as SwitchPrimitives from '@radix-ui/react-switch';

import { cn } from '@/lib/utils';

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      'peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input',
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        'pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0'
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };
</file>

<file path="src/components/ui/table.tsx">
import * as React from 'react';

import { cn } from '@/lib/utils';

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn('w-full caption-bottom text-sm', className)}
      {...props}
    />
  </div>
));
Table.displayName = 'Table';

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn('[&_tr]:border-b', className)} {...props} />
));
TableHeader.displayName = 'TableHeader';

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn('[&_tr:last-child]:border-0', className)}
    {...props}
  />
));
TableBody.displayName = 'TableBody';

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      'border-t bg-muted/50 font-medium [&>tr]:last:border-b-0',
      className
    )}
    {...props}
  />
));
TableFooter.displayName = 'TableFooter';

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      'border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted',
      className
    )}
    {...props}
  />
));
TableRow.displayName = 'TableRow';

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      'h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0',
      className
    )}
    {...props}
  />
));
TableHead.displayName = 'TableHead';

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn('p-4 align-middle [&:has([role=checkbox])]:pr-0', className)}
    {...props}
  />
));
TableCell.displayName = 'TableCell';

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn('mt-4 text-sm text-muted-foreground', className)}
    {...props}
  />
));
TableCaption.displayName = 'TableCaption';

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
};
</file>

<file path="src/components/ui/tabs.tsx">
'use client';

import * as React from 'react';
import * as TabsPrimitive from '@radix-ui/react-tabs';

import { cn } from '@/lib/utils';

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      'inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground',
      className
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      'inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm',
      className
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      'mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
      className
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from 'react';

import { cn } from '@/lib/utils';

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Textarea.displayName = 'Textarea';

export { Textarea };
</file>

<file path="src/components/ui/toast.tsx">
'use client';

import * as React from 'react';
import * as ToastPrimitives from '@radix-ui/react-toast';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive',
      className
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600',
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn('text-sm font-semibold', className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};
</file>

<file path="src/components/ui/toaster.tsx">
'use client';

import { useToast } from '@/hooks/use-toast';
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '@/components/ui/toast';

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}
</file>

<file path="src/components/ui/toggle-group.tsx">
'use client';

import * as React from 'react';
import * as ToggleGroupPrimitive from '@radix-ui/react-toggle-group';
import { type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';
import { toggleVariants } from '@/components/ui/toggle';

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: 'default',
  variant: 'default',
});

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn('flex items-center justify-center gap-1', className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
));

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName;

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext);

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  );
});

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName;

export { ToggleGroup, ToggleGroupItem };
</file>

<file path="src/components/ui/toggle.tsx">
'use client';

import * as React from 'react';
import * as TogglePrimitive from '@radix-ui/react-toggle';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '@/lib/utils';

const toggleVariants = cva(
  'inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground',
  {
    variants: {
      variant: {
        default: 'bg-transparent',
        outline:
          'border border-input bg-transparent hover:bg-accent hover:text-accent-foreground',
      },
      size: {
        default: 'h-10 px-3',
        sm: 'h-9 px-2.5',
        lg: 'h-11 px-5',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };
</file>

<file path="src/components/ui/tooltip.tsx">
'use client';

import * as React from 'react';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';

import { cn } from '@/lib/utils';

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      'z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
</file>

<file path="src/components/video-controls.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Play,
  Pause,
  Volume2,
  VolumeX,
  SkipBack,
  SkipForward,
  Settings,
  Globe,
  Languages,
  Maximize,
  Minimize,
  FastForward,
  Rewind,
} from "lucide-react";
import { formatTime } from "@/lib/utils";
import { IVideo } from "@consumet/extensions";

interface VideoControlsProps {
  currentTime: number;
  duration: number;
  isPlaying: boolean;
  volume: number;
  isMuted: boolean;
  isFullscreen: boolean;
  providers: { name: string; sources: IVideo[] }[];
  currentProviderIndex: number;
  dubbed: boolean;
  qualities: string[];
  currentQuality: number;
  hasSkipEvents: boolean;
  onPlayPause: () => void;
  onVolumeChange: (value: number[]) => void;
  onMuteToggle: () => void;
  onSeek: (value: number[]) => void;
  onPrevious?: () => void;
  onNext?: () => void;
  onProviderChange: (index: number) => void;
  onDubbedChange: (dubbed: boolean) => void;
  onQualityChange: (index: number) => void;
  onSkipIntro?: () => void;
  onSkipOutro?: () => void;
  onToggleFullscreen: () => void;
  onSeekBackward: () => void;
  onSeekForward: () => void;
}

export function VideoControls({
  currentTime,
  duration,
  isPlaying,
  volume,
  isMuted,
  isFullscreen,
  providers,
  currentProviderIndex,
  dubbed,
  qualities,
  currentQuality,
  hasSkipEvents,
  onPlayPause,
  onVolumeChange,
  onMuteToggle,
  onSeek,
  onPrevious,
  onNext,
  onProviderChange,
  onDubbedChange,
  onQualityChange,
  onSkipIntro,
  onSkipOutro,
  onToggleFullscreen,
  onSeekBackward,
  onSeekForward,
}: VideoControlsProps) {
  const [showVolumeSlider, setShowVolumeSlider] = useState(false);
  const [showSettings, setShowSettings] = useState(false);

  return (
    <div className="absolute inset-0 flex flex-col justify-end bg-gradient-to-t from-black/80 via-black/40 to-transparent opacity-0 transition-opacity duration-300 group-hover:opacity-100">
      <div className="space-y-4 p-4">
        {/* Progress bar */}
        <div className="flex items-center gap-2">
          <Slider
            value={[currentTime]}
            min={0}
            max={duration}
            step={1}
            onValueChange={onSeek}
            className="w-full"
          />
          <span className="text-sm text-white min-w-[80px]">
            {formatTime(currentTime)} / {formatTime(duration)}
          </span>
        </div>

        {/* Controls */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="text-white hover:bg-white/20"
              onClick={onPlayPause}
            >
              {isPlaying ? (
                <Pause className="h-6 w-6" />
              ) : (
                <Play className="h-6 w-6" />
              )}
            </Button>

            <div
              className="relative"
              onMouseEnter={() => setShowVolumeSlider(true)}
              onMouseLeave={() => setShowVolumeSlider(false)}
            >
              <Button
                variant="ghost"
                size="icon"
                className="text-white hover:bg-white/20"
                onClick={onMuteToggle}
              >
                {isMuted || volume === 0 ? (
                  <VolumeX className="h-6 w-6" />
                ) : (
                  <Volume2 className="h-6 w-6" />
                )}
              </Button>
              {showVolumeSlider && (
                <div className="absolute bottom-full left-0 mb-2 w-32 p-2 bg-black/80 rounded-md">
                  <Slider
                    value={[isMuted ? 0 : volume]}
                    min={0}
                    max={1}
                    step={0.1}
                    onValueChange={onVolumeChange}
                    orientation="horizontal"
                  />
                </div>
              )}
            </div>

            <Button
              variant="ghost"
              size="icon"
              className="text-white hover:bg-white/20"
              onClick={onSeekBackward}
            >
              <Rewind className="h-6 w-6" />
            </Button>

            <Button
              variant="ghost"
              size="icon"
              className="text-white hover:bg-white/20"
              onClick={onSeekForward}
            >
              <FastForward className="h-6 w-6" />
            </Button>
          </div>

          <div className="flex items-center gap-2">
            {onPrevious && (
              <Button
                variant="ghost"
                size="icon"
                className="text-white hover:bg-white/20"
                onClick={onPrevious}
              >
                <SkipBack className="h-6 w-6" />
              </Button>
            )}

            {onNext && (
              <Button
                variant="ghost"
                size="icon"
                className="text-white hover:bg-white/20"
                onClick={onNext}
              >
                <SkipForward className="h-6 w-6" />
              </Button>
            )}

            {hasSkipEvents && (
              <>
                {onSkipIntro && (
                  <Button
                    variant="outline"
                    size="sm"
                    className="text-white bg-white/20 hover:bg-white/30"
                    onClick={onSkipIntro}
                  >
                    Skip Intro
                  </Button>
                )}
                {onSkipOutro && (
                  <Button
                    variant="outline"
                    size="sm"
                    className="text-white bg-white/20 hover:bg-white/30"
                    onClick={onSkipOutro}
                  >
                    Skip Outro
                  </Button>
                )}
              </>
            )}

            <Select
              value={currentProviderIndex.toString()}
              onValueChange={(value) => onProviderChange(parseInt(value))}
            >
              <SelectTrigger className="w-[180px] bg-black/60 border-none text-white">
                <Globe className="h-4 w-4 mr-2" />
                <SelectValue placeholder="Select provider" />
              </SelectTrigger>
              <SelectContent>
                {providers.map((provider, index) => (
                  <SelectItem key={index} value={index.toString()}>
                    {provider.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>

            <Button
              variant="ghost"
              size="icon"
              className="text-white hover:bg-white/20"
              onClick={() => onDubbedChange(!dubbed)}
            >
              <Languages className="h-6 w-6" />
            </Button>

            <Button
              variant="ghost"
              size="icon"
              className="text-white hover:bg-white/20"
              onClick={() => setShowSettings(!showSettings)}
            >
              <Settings className="h-6 w-6" />
            </Button>

            <Button
              variant="ghost"
              size="icon"
              className="text-white hover:bg-white/20"
              onClick={onToggleFullscreen}
            >
              {isFullscreen ? (
                <Minimize className="h-6 w-6" />
              ) : (
                <Maximize className="h-6 w-6" />
              )}
            </Button>
          </div>
        </div>
      </div>
      {/* Settings panel */}
      {showSettings && (
        <div className="absolute bottom-full right-4 mb-2 w-56 rounded-md bg-black/80 p-2">
          <div className="space-y-2">
            <div className="flex items-center justify-between text-sm text-white">
              <span>Source</span>
              <span className="text-primary">{providers[currentProviderIndex].name}</span>
            </div>
            <div className="flex items-center justify-between text-sm text-white">
              <span>Quality</span>
              <Select
                value={currentQuality.toString()}
                onValueChange={(value) => onQualityChange(parseInt(value))}
              >
                <SelectTrigger className="w-24">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {qualities.map((quality, index) => (
                    <SelectItem key={quality} value={index.toString()}>
                      {quality}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>
      )}

    </div>
  );
}
</file>

<file path="src/components/video-player-client.tsx">
'use client';

import { useEffect, useRef, useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { VideoControls } from "@/components/video-controls";
import { ListAnimeData } from "@/types/anilistAPITypes";
import { IVideo } from "@consumet/extensions";
import { getUniversalEpisodeUrl } from "@/modules/providers/api";
import Hls from 'hls.js';

interface VideoPlayerProps {
  animeId: string;
  episodeId: string;
  title: string;
  episodeNumber: number;
  totalEpisodes: number;
  listAnimeData: ListAnimeData;
}

export default function VideoPlayerClient({
  animeId,
  episodeId,
  title,
  episodeNumber,
  totalEpisodes,
  listAnimeData,
}: VideoPlayerProps) {
  const router = useRouter();
  const videoRef = useRef<HTMLVideoElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(1);
  const [isMuted, setIsMuted] = useState(false);
  const [showControls, setShowControls] = useState(true);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [videoSource, setVideoSource] = useState<IVideo | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [currentProviderIndex, setCurrentProviderIndex] = useState(0);
  const [providers, setProviders] = useState<{ name: string, sources: IVideo[] }[]>([]);
  const [dubbed, setDubbed] = useState(false);

  useEffect(() => {
    const loadVideo = async () => {
      try {
        setIsLoading(true);
        setError(null);
        const source = await getUniversalEpisodeUrl(listAnimeData, episodeNumber);
        if (source) {
          setVideoSource(source);
        } else {
          setError("No video sources found. Please try another provider or episode.");
        }
      } catch (err) {
        console.error("Failed to load video:", err);
        setError("Failed to load video. Please try again later.");
      } finally {
        setIsLoading(false);
      }
    };

    loadVideo();
  }, [listAnimeData, episodeNumber]);

  useEffect(() => {
    if (!videoRef.current || !videoSource?.url) return;
      
    let hls: Hls | null = null;
    
    const initializeVideo = async () => {
      if (!videoRef.current) return;

      try {
        if (videoSource.isM3U8) {
          if (Hls.isSupported()) {
            hls = new Hls({
              enableWorker: true,
              lowLatencyMode: true,
              debug: process.env.NODE_ENV === 'development'
            });
            
            hls.on(Hls.Events.ERROR, (event, data) => {
              if (data.fatal) {
                setError('Failed to load video stream. Please try a different quality or provider.');
                console.error('Fatal HLS error:', data);
                
                switch (data.type) {
                  case Hls.ErrorTypes.NETWORK_ERROR:
                    hls?.startLoad();
                    break;
                  case Hls.ErrorTypes.MEDIA_ERROR:
                    hls?.recoverMediaError();
                    break;
                  default:
                    hls?.destroy();
                    break;
                }
              }
            });

            hls.loadSource(videoSource.url);
            hls.attachMedia(videoRef.current);
            
            hls.on(Hls.Events.MANIFEST_PARSED, () => {
              videoRef.current?.play().catch(error => {
                console.error('Failed to start playback:', error);
                setError('Failed to start video playback. Please try again.');
              });
            });
          } else if (videoRef.current.canPlayType('application/vnd.apple.mpegurl')) {
            videoRef.current.src = videoSource.url;
            await videoRef.current.play();
          }
        } else {
          videoRef.current.src = videoSource.url;
          await videoRef.current.play();
        }
      } catch (error) {
        console.error('Failed to initialize video:', error);
        setError('Failed to initialize video player. Please try again or use a different provider.');
      }
    };

    initializeVideo();

    return () => {
      if (hls) {
        hls.destroy();
      }
    };
  }, [videoSource]);

  // ... Rest of the component implementation remains the same as in the original video-player.tsx

  return (
    <div
      ref={containerRef}
      className="group relative aspect-video bg-black"
      onMouseEnter={() => setShowControls(true)}
      onMouseLeave={() => setShowControls(false)}
    >
      {isLoading ? (
        <div className="flex items-center justify-center h-full text-white">
          Loading video...
        </div>
      ) : error ? (
        <div className="absolute inset-0 flex items-center justify-center bg-black/80">
          <div className="text-center p-4">
            <p className="text-red-500 mb-4">{error}</p>
            <Button 
              variant="outline" 
              onClick={() => {
                setError(null);
                if (videoRef.current) {
                  videoRef.current.load();
                }
              }}
            >
              Try Again
            </Button>
          </div>
        </div>
      ) : (
        <>
          <video
            ref={videoRef}
            className="h-full w-full"
            poster={listAnimeData.media?.coverImage?.extraLarge}
            crossOrigin="anonymous"
            playsInline
          />
          {showControls && (
            <VideoControls
              currentTime={currentTime}
              duration={duration}
              isPlaying={isPlaying}
              volume={volume}
              isMuted={isMuted}
              onPlayPause={() => {/* implement controls */}}
              onVolumeChange={() => {/* implement controls */}}
              onMuteToggle={() => {/* implement controls */}}
              onSeek={() => {/* implement controls */}}
              providers={providers}
              currentProviderIndex={currentProviderIndex}
              onProviderChange={setCurrentProviderIndex}
              dubbed={dubbed}
              onDubbedChange={setDubbed}
              qualities={[]}
              currentQuality={0}
              onQualityChange={() => {/* implement controls */}}
              hasSkipEvents={false}
            />
          )}
        </>
      )}
    </div>
  );
}
</file>

<file path="src/components/video-player.tsx">
import { useEffect, useRef, useState } from "react";
import { useRouter } from "next/navigation";
import { MediaPlayer, MediaProvider, useMediaPlayer } from '@vidstack/react';
import { DefaultVideoLayout, defaultLayoutIcons } from '@vidstack/react/player/layouts/default';
import '@vidstack/react/player/styles/default/theme.css';
import '@vidstack/react/player/styles/default/layouts/video.css';
import { ListAnimeData } from "@/types/anilistAPITypes";
import { IVideo } from "@consumet/extensions";
import { getUniversalEpisodeUrl } from "@/modules/providers/api";
import { LoadingSpinner } from "@/components/loading-spinner";
import { CachedLink } from '@/components/shared/cached-links'
import { useLocalStorage } from "@/hooks/use-local-storage";



interface VideoPlayerProps {
  animeId: string;
  episodeId: string;
  title: string;
  episodeNumber: number;
  totalEpisodes: number;
  listAnimeData: ListAnimeData;
}

export function VideoPlayer({
  animeId,
  episodeId,
  title,
  episodeNumber,
  totalEpisodes,
  listAnimeData,
}: VideoPlayerProps) {
  const router = useRouter();
  const [videoSource, setVideoSource] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [subtitles, setSubtitles] = useState<{ url: string, lang: string }[]>([]);
  const [thumbnails, setThumbnails] = useState<string>('');
  const [cachedSources, setCachedSources] = useLocalStorage<Record<string, IVideo[]>>("cached-sources", {});
 


  function PlayerControls() {
    const player = useMediaPlayer();
    // Use player here
    return null;
  }
  useEffect(() => {
    const loadVideo = async () => {
      setIsLoading(true);
      setError(null);
      const cacheKey = `${animeId}-${episodeNumber}`; // create cache key

      if (cachedSources[cacheKey]) {
        // Use cached sources if available
        const bestSource = cachedSources[cacheKey][0];
        setVideoSource(bestSource.url);
        setSubtitles(bestSource.tracks || []);

        if (bestSource.isM3U8) {
          setThumbnails(`https://${new URL(bestSource.url).hostname.replace('sbfull.com', 'thumb.sbplay.org')}/hls/${new URL(bestSource.url).searchParams.get('id')}/thumbs.vtt`);
      } else {
          setThumbnails(`https://${new URL(bestSource.url).hostname.replace('sbfull.com', 'thumb.sbplay.org')}/preview/${new URL(bestSource.url).pathname.split('/').pop()}.vtt`)
      }


        setIsLoading(false);
      } else {
        try {
          const sources = await getUniversalEpisodeUrl(listAnimeData, episodeNumber);
          if (!sources || sources.length === 0) {
            throw new Error("No video sources found");
          }
          
          // Cache the sources
          setCachedSources(prev => ({ ...prev, [cacheKey]: sources }));
  
          const bestSource = sources[0];

          if (bestSource.url) {
            setVideoSource(bestSource.url);
          } else {
            throw new Error("Source URL is missing");
          }
          if (bestSource.tracks) {
            setSubtitles(bestSource.tracks)
          }

          if (bestSource.isM3U8) {
              setThumbnails(`https://${new URL(bestSource.url).hostname.replace('sbfull.com', 'thumb.sbplay.org')}/hls/${new URL(bestSource.url).searchParams.get('id')}/thumbs.vtt`);
          } else {
              setThumbnails(`https://${new URL(bestSource.url).hostname.replace('sbfull.com', 'thumb.sbplay.org')}/preview/${new URL(bestSource.url).pathname.split('/').pop()}.vtt`)
          }

        } catch (err) {
          console.error("Failed to load video:", err);
          setError("Failed to load video. Please try again later.");
        } finally {
          setIsLoading(false);
        }
      }
    };

    loadVideo();
  }, [listAnimeData, episodeNumber, animeId, cachedSources]);

  const handlePreviousEpisode = () => {
    if (episodeNumber > 1) {
      router.push(`/watch/${animeId}/${episodeNumber - 1}`);
    }
  };

  const handleNextEpisode = () => {
    if (episodeNumber < totalEpisodes) {
      router.push(`/watch/${animeId}/${episodeNumber + 1}`);
    }
  };

  if (isLoading) {
    return (
      <div className="aspect-video bg-black rounded-lg shadow-lg flex items-center justify-center">
        <LoadingSpinner />
      </div>
    );
  }

  if (error) {
    return (
      <div className="aspect-video bg-black rounded-lg shadow-lg flex items-center justify-center">
        <div className="text-center text-white p-4">
          <p className="mb-4">{error}</p>
          <button
            onClick={() => window.location.reload()}
            className="px-4 py-2 bg-primary rounded-md hover:bg-primary/90 transition-colors"
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }

  return (
    <MediaPlayer 
      title={title} 
      src={videoSource!}
      poster={listAnimeData.media?.coverImage?.extraLarge}
      autoplay
      crossOrigin='anonymous'
    >
      <MediaProvider />
      <PlayerControls />
      <DefaultVideoLayout
          thumbnails={thumbnails}
          icons={defaultLayoutIcons} 
          className="!border-0 !shadow-none" 
      />
    </MediaPlayer>
  );
}
</file>

<file path="src/components/watch-button.tsx">
"use client";

import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { PlayCircle, Loader2 } from "lucide-react";
import { useWatchProgress } from "@/hooks/use-watch-progress";
import { Media } from "@/types/anilistGraphQLTypes";

interface WatchButtonProps {
  anime: Media;
  variant?: "default" | "outline" | "secondary";
  size?: "default" | "sm" | "lg" | "icon";
}

export function WatchButton({ anime, variant = "default", size = "default" }: WatchButtonProps) {
  const router = useRouter();
  const { getProgress, isLoading } = useWatchProgress();
  
  const handleClick = () => {
    const progress = getProgress(anime.id!);
    const nextEpisode = progress ? progress + 1 : 1;
    
    // Only navigate if there are more episodes to watch
    if (!anime.episodes || nextEpisode <= anime.episodes) {
      router.push(`/watch/${anime.id}/${nextEpisode}`);
    }
  };

  if (isLoading) {
    return (
      <Button variant={variant} size={size} disabled>
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
        Loading
      </Button>
    );
  }

  const progress = getProgress(anime.id!);
  const isComplete = progress && anime.episodes && progress >= anime.episodes;

  return (
    <Button
      variant={variant}
      size={size}
      onClick={handleClick}
      disabled={isComplete}
    >
      <PlayCircle className="mr-2 h-4 w-4" />
      {progress ? (
        isComplete ? (
          "Completed"
        ) : (
          `Continue Episode ${progress + 1}`
        )
      ) : (
        "Start Watching"
      )}
    </Button>
  );
}
</file>

<file path="src/components/watchlist/watchlist-button.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Plus, Check, Loader2 } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useWatchlist } from "@/hooks/use-watchlist";
import { WatchStatus } from "@/types/watchlist";
import { Media } from "@/types/anilistGraphQLTypes";
import { useToast } from "@/hooks/use-toast";

interface WatchlistButtonProps {
  anime: Media;
  variant?: "default" | "outline" | "secondary";
  size?: "default" | "sm" | "lg" | "icon";
}

const statusOptions: { value: WatchStatus; label: string }[] = [
  { value: "watching", label: "Watching" },
  { value: "completed", label: "Completed" },
  { value: "plan_to_watch", label: "Plan to Watch" },
  { value: "on_hold", label: "On Hold" },
  { value: "dropped", label: "Dropped" },
];

export function WatchlistButton({ anime, variant = "default", size = "default" }: WatchlistButtonProps) {
  const { addToWatchlist, removeFromWatchlist, getStatus, isLoading } = useWatchlist();
  const { toast } = useToast();
  const [isOpen, setIsOpen] = useState(false);
  const currentStatus = getStatus(anime.id!);

  const handleStatusChange = async (status: WatchStatus) => {
    try {
      if (currentStatus === status) {
        await removeFromWatchlist(anime.id!);
        toast({
          title: "Removed from watchlist",
          description: `${anime.title?.english || anime.title?.romaji} has been removed from your watchlist.`,
        });
      } else {
        await addToWatchlist({
          id: anime.id!,
          status,
          progress: 0,
          media: {
            id: anime.id!,
            title: anime.title,
            coverImage: anime.coverImage,
            episodes: anime.episodes,
            genres: anime.genres,
          },
          updatedAt: Date.now(),
        });
        toast({
          title: "Added to watchlist",
          description: `${anime.title?.english || anime.title?.romaji} has been added to your ${status.replace('_', ' ')}.`,
        });
      }
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to update watchlist. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsOpen(false);
    }
  };

  if (isLoading) {
    return (
      <Button variant={variant} size={size} disabled>
        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
        Loading
      </Button>
    );
  }

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <DropdownMenuTrigger asChild>
        <Button variant={variant} size={size}>
          {currentStatus ? (
            <>
              <Check className="mr-2 h-4 w-4" />
              {statusOptions.find(opt => opt.value === currentStatus)?.label}
            </>
          ) : (
            <>
              <Plus className="mr-2 h-4 w-4" />
              Add to List
            </>
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-48">
        {statusOptions.map((option) => (
          <DropdownMenuItem
            key={option.value}
            onClick={() => handleStatusChange(option.value)}
          >
            {currentStatus === option.value && (
              <Check className="mr-2 h-4 w-4" />
            )}
            {option.label}
          </DropdownMenuItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/watchlist/watchlist-filters.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { WatchStatus } from "@/types/watchlist";

interface WatchlistFiltersProps {
  currentStatus: WatchStatus;
  onStatusChange: (status: WatchStatus) => void;
}

const statusOptions: { value: WatchStatus; label: string }[] = [
  { value: "watching", label: "Watching" },
  { value: "completed", label: "Completed" },
  { value: "on_hold", label: "On Hold" },
  { value: "dropped", label: "Dropped" },
  { value: "plan_to_watch", label: "Plan to Watch" },
];

export function WatchlistFilters({
  currentStatus,
  onStatusChange,
}: WatchlistFiltersProps) {
  return (
    <div className="flex flex-wrap gap-2">
      {statusOptions.map((status) => (
        <Button
          key={status.value}
          variant={currentStatus === status.value ? "default" : "outline"}
          onClick={() => onStatusChange(status.value)}
        >
          {status.label}
        </Button>
      ))}
    </div>
  );
}
</file>

<file path="src/components/watchlist/watchlist-grid.tsx">
"use client";

import Link from "next/link";
import Image from "next/image";
import { Card } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { WatchlistEntry } from "@/types/watchlist";

interface WatchlistGridProps {
  entries: WatchlistEntry[];
}

export function WatchlistGrid({ entries }: WatchlistGridProps) {
  if (!entries.length) {
    return (
      <div className="text-center py-8">
        <p className="text-muted-foreground">No entries found</p>
      </div>
    );
  }

  return (
    <div className="grid gap-4 grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5">
      {entries.map((entry) => (
        <Link
          key={entry.id}
          href={`/anime/${entry.media.id}`}
          className="transition-transform hover:scale-[1.02]"
        >
          <Card className="overflow-hidden h-full">
            <div className="aspect-[2/3] relative">
              <Image
                src={entry.media.coverImage?.large || ""}
                alt={entry.media.title?.english || entry.media.title?.romaji || ""}
                fill
                className="object-cover"
                sizes="(max-width: 640px) 50vw, (max-width: 1024px) 33vw, 20vw"
              />
            </div>
            <div className="p-3 space-y-2">
              <h3 className="font-medium text-sm line-clamp-1">
                {entry.media.title?.english || entry.media.title?.romaji}
              </h3>
              <div className="flex justify-between text-xs text-muted-foreground">
                <span>Progress</span>
                <span>
                  {entry.progress} / {entry.media.episodes || "?"}
                </span>
              </div>
              <Progress 
                value={entry.media.episodes ? (entry.progress / entry.media.episodes) * 100 : 0} 
                className="h-1"
              />
            </div>
          </Card>
        </Link>
      ))}
    </div>
  );
}
</file>

<file path="src/components/watchlist/watchlist-stats.tsx">
"use client";

import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import type { WatchlistEntry } from "@/types/watchlist";

interface WatchlistStatsProps {
  entries: WatchlistEntry[];
}

export function WatchlistStats({ entries }: WatchlistStatsProps) {
  const totalAnime = entries.length;
  const totalEpisodes = entries.reduce((sum, entry) => sum + (entry.progress || 0), 0);
  const completedAnime = entries.filter(entry => entry.status === "completed").length;
  const watchingAnime = entries.filter(entry => entry.status === "watching").length;
  const onHoldAnime = entries.filter(entry => entry.status === "on_hold").length;
  const droppedAnime = entries.filter(entry => entry.status === "dropped").length;

  const stats = [
    {
      label: "Total Anime",
      value: totalAnime,
    },
    {
      label: "Episodes Watched",
      value: totalEpisodes,
    },
    {
      label: "Completion Rate",
      value: `${totalAnime ? ((completedAnime / totalAnime) * 100).toFixed(1) : 0}%`,
    },
  ];

  const statusBreakdown = [
    {
      status: "Watching",
      count: watchingAnime,
      color: "bg-blue-500",
    },
    {
      status: "Completed",
      count: completedAnime,
      color: "bg-green-500",
    },
    {
      status: "On Hold",
      count: onHoldAnime,
      color: "bg-yellow-500",
    },
    {
      status: "Dropped",
      count: droppedAnime,
      color: "bg-red-500",
    },
  ];

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Overview</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {stats.map((stat) => (
            <div key={stat.label}>
              <div className="flex justify-between text-sm mb-1">
                <span className="text-muted-foreground">{stat.label}</span>
                <span className="font-medium">{stat.value}</span>
              </div>
            </div>
          ))}
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Status Breakdown</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {statusBreakdown.map((item) => (
            <div key={item.status}>
              <div className="flex justify-between text-sm mb-1">
                <span className="text-muted-foreground">{item.status}</span>
                <span className="font-medium">{item.count}</span>
              </div>
              <Progress
                value={totalAnime ? (item.count / totalAnime) * 100 : 0}
                className={item.color}
              />
            </div>
          ))}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/constants/anilist.ts">
export const GENRES = [
    { value: '', label: 'Any' },
    { value: 'Action', label: 'Action' },
    { value: 'Adventure', label: 'Adventure' },
    { value: 'Comedy', label: 'Comedy' },
    { value: 'Drama', label: 'Drama' },
    { value: 'Ecchi', label: 'Ecchi' }, // Note: Consider filtering based on user preferences due to mature content
    { value: 'Fantasy', label: 'Fantasy' },
    { value: 'Horror', label: 'Horror' },
    { value: 'Mahou Shoujo', label: 'Mahou Shoujo' }, // Magical Girl
    { value: 'Mecha', label: 'Mecha' }, // Giant robots
    { value: 'Music', label: 'Music' },
    { value: 'Mystery', label: 'Mystery' }, // Misspelled in previous response
    { value: 'Psychological', label: 'Psychological' },
    { value: 'Romance', label: 'Romance' },
    { value: 'Sci-Fi', label: 'Sci-Fi' },
    { value: 'Slice of Life', label: 'Slice of Life' },
    { value: 'Sports', label: 'Sports' },
    { value: 'Supernatural', label: 'Supernatural' },
    { value: 'Thriller', label: 'Thriller' },
  ];
  
  export const SEASONS = [
    { value: '', label: 'Any' },
    { value: 'WINTER', label: 'Winter' },
    { value: 'SPRING', label: 'Spring' },
    { value: 'SUMMER', label: 'Summer' },
    { value: 'FALL', label: 'Fall' },
  ];
  
  export const FORMATS = [
    { value: '', label: 'Any' },
    { value: 'TV', label: 'TV Show' },
    { value: 'TV_SHORT', label: 'TV Short' },
    { value: 'MOVIE', label: 'Movie' },
    { value: 'SPECIAL', label: 'Special' },
    { value: 'OVA', label: 'OVA' },
    { value: 'ONA', label: 'ONA' },
    { value: 'MUSIC', label: 'Music' },
  ];
  
  export const SORTS = [
    { value: '', label: 'Any' },
    { value: 'START_DATE_DESC', label: 'Release Date' },
    { value: 'SCORE_DESC', label: 'Score' },
    { value: 'POPULARITY_DESC', label: 'Popularity' },
    { value: 'TRENDING_DESC', label: 'Trending' },
  ];
</file>

<file path="src/constants/utils.ts">
export const SPONSOR_URL = '';
export const OPEN_NEW_ISSUE_URL = '';
export const EPISODES_INFO_URL = 'https://api.ani.zip/mappings?anilist_id=';
</file>

<file path="src/context/HistoryContext.tsx">
"use client";

import { createContext, useContext, useState, useEffect } from 'react';
import { ListAnimeData } from '@/types/anilistAPITypes';
import { getAnimeInfo } from '@/modules/anilist/anilistsAPI';
import {
  getAnimeHistory,
  getHistoryEntries,
  getLastWatchedEpisode,
  setAnimeHistory,
} from '../modules/history';

interface HistoryContextType {
  historyAnime: ListAnimeData[];
  recommendedAnime: ListAnimeData[];
  updateHistory: () => Promise<void>;
}

const HistoryContext = createContext<HistoryContextType | null>(null);

export function HistoryProvider({ children }: { children: React.ReactNode }) {
  const [historyAnime, setHistoryAnime] = useState<ListAnimeData[]>([]);
  const [recommendedAnime, setRecommendedAnime] = useState<ListAnimeData[]>([]);

  const updateRecommended = async (history: ListAnimeData[]) => {
    const animeData = history[Math.floor(Math.random() * (history.length - 1))];
    
    if (!animeData.media.recommendations) {
      animeData.media = await getAnimeInfo(animeData.media.id);
      const entry = getAnimeHistory(animeData.media.id as number);
      if (entry) {
        entry.data = animeData;
        setAnimeHistory(entry);
      }
    }

    const recommendedList = animeData.media.recommendations?.nodes.map(value => ({
      id: null,
      mediaId: null,
      progress: null,
      media: value.mediaRecommendation,
    } as ListAnimeData)) || [];

    recommendedList.push(animeData);
    setRecommendedAnime(recommendedList);
  };
  const sortNewest = (a: ListAnimeData, b: ListAnimeData) => {
    (getLastWatchedEpisode(
      (b.media.id ??
        (b.media.mediaListEntry && b.media.mediaListEntry.id)) as number,
    )?.timestamp ?? 0) -
    (getLastWatchedEpisode(
      (a.media.id ??
        (a.media.mediaListEntry && a.media.mediaListEntry.id)) as number,
    )?.timestamp ?? 0);
  }

  const updateHistory = async () => {
    const entries = getHistoryEntries();
    const historyAvailable = Object.values(entries).length > 0;
  
    if (historyAvailable) {
      const result = Object.values(entries)
        .map(value => value.data)
        .sort((a, b) => {
          const aTimestamp = getLastWatchedEpisode(
            (a.media.id ?? (a.media.mediaListEntry && a.media.mediaListEntry.id)) as number
          )?.timestamp ?? 0;
          const bTimestamp = getLastWatchedEpisode(
            (b.media.id ?? (b.media.mediaListEntry && b.media.mediaListEntry.id)) as number
          )?.timestamp ?? 0;
          return bTimestamp - aTimestamp;
        });
  
      setHistoryAnime(result);
    }
  };  

  useEffect(() => {
    updateHistory();
  }, []);

  return (
    <HistoryContext.Provider value={{ historyAnime, recommendedAnime, updateHistory }}>
      {children}
    </HistoryContext.Provider>
  );
}

export const useHistory = () => {
  const context = useContext(HistoryContext);
  if (!context) throw new Error('useHistory must be used within HistoryProvider');
  return context;
};
</file>

<file path="src/context/ListsContext.tsx">
"use client";

import { createContext, useContext, useState } from 'react';
import type { ListAnimeData, CurrentListAnime } from '@/types/anilistAPITypes';

interface ListsContextType {
  currentLists: CurrentListAnime;
  setCurrentLists: (lists: CurrentListAnime) => void;
  isListsLoading: boolean;
  setIsListsLoading: (loading: boolean) => void;
}

const ListsContext = createContext<ListsContextType | null>(null);

export function ListsProvider({ children }: { children: React.ReactNode }) {
  const [currentLists, setCurrentLists] = useState<CurrentListAnime>([]);
  const [isListsLoading, setIsListsLoading] = useState(true);

  return (
    <ListsContext.Provider value={{ currentLists, setCurrentLists, isListsLoading, setIsListsLoading }}>
      {children}
    </ListsContext.Provider>
  );
}

export const useLists = () => {
  const context = useContext(ListsContext);
  if (!context) throw new Error('useLists must be used within ListsProvider');
  return context;
};
</file>

<file path="src/hooks/use-debounce.ts">
import { useState, useEffect } from "react";

export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
</file>

<file path="src/hooks/use-local-storage.ts">
"use client";

import { useState, useEffect } from "react";


export function useLocalStorage<T>(key: string, initialValue: T) {
  // Initialize state with a function to ensure it only runs once
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Only update localStorage when storedValue changes
  useEffect(() => {
    if (typeof window !== "undefined") {
      try {
        window.localStorage.setItem(key, JSON.stringify(storedValue));
      } catch (error) {
        console.warn(`Error setting localStorage key "${key}":`, error);
      }
    }
  }, [key, storedValue]);


  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
    } catch (error) {
      console.warn(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue] as const;
}
</file>

<file path="src/hooks/use-toast.ts">
'use client';

// Inspired by react-hot-toast library
import * as React from 'react';

import type { ToastActionElement, ToastProps } from '@/components/ui/toast';

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: 'ADD_TOAST',
  UPDATE_TOAST: 'UPDATE_TOAST',
  DISMISS_TOAST: 'DISMISS_TOAST',
  REMOVE_TOAST: 'REMOVE_TOAST',
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType['ADD_TOAST'];
      toast: ToasterToast;
    }
  | {
      type: ActionType['UPDATE_TOAST'];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType['DISMISS_TOAST'];
      toastId?: ToasterToast['id'];
    }
  | {
      type: ActionType['REMOVE_TOAST'];
      toastId?: ToasterToast['id'];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: 'REMOVE_TOAST',
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'ADD_TOAST':
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case 'UPDATE_TOAST':
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      };

    case 'DISMISS_TOAST': {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      };
    }
    case 'REMOVE_TOAST':
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, 'id'>;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: 'UPDATE_TOAST',
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: 'DISMISS_TOAST', toastId: id });

  dispatch({
    type: 'ADD_TOAST',
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: 'DISMISS_TOAST', toastId }),
  };
}

export { useToast, toast };
</file>

<file path="src/hooks/use-watch-progress.ts">
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/hooks/useAuth";
import { useLocalStorage } from "@/hooks/use-local-storage";
import { updateAnimeProgress } from "@/modules/anilist/anilistsAPI";

interface WatchProgress {
  animeId: number;
  episodeNumber: number;
  timestamp: number;
  progress: number;
  duration: number;
  title: string;
  coverImage: string;
  totalEpisodes?: number;
}

export function useWatchProgress() {
  const { isAuthenticated, lists, updateLists } = useAuth();
  const [localProgress, setLocalProgress] = useLocalStorage<Record<string, WatchProgress>>("watch-progress", {});
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (isAuthenticated && lists) {
      // Convert AniList progress to local format
      const progress: Record<string, WatchProgress> = {};
      lists.forEach(item => {
        if (item.progress) {
          progress[item.media.id] = {
            animeId: item.media.id,
            episodeNumber: item.progress,
            timestamp: Date.now(),
            progress: 100,
            duration: 24 * 60,
            title: item.media.title?.english || item.media.title?.romaji || '',
            coverImage: item.media.coverImage?.large || '',
            totalEpisodes: item.media.episodes
          };
        }
      });
      setLocalProgress(progress);
    }
    setIsLoading(false);
  }, [isAuthenticated, lists]);

  const updateProgress = async (
    animeId: number,
    episodeNumber: number,
    progress: number,
    duration: number,
    title: string,
    coverImage: string,
    totalEpisodes?: number
  ) => {
    // Update local storage
    const key = animeId.toString();
    setLocalProgress(prev => ({
      ...prev,
      [key]: {
        animeId,
        episodeNumber,
        timestamp: Date.now(),
        progress,
        duration,
        title,
        coverImage,
        totalEpisodes
      }
    }));

    // Update AniList if authenticated
    if (isAuthenticated) {
      await updateAnimeProgress(animeId, episodeNumber);
      
      // Update local state
      const updatedLists = lists?.map(item =>
        item.media.id === animeId ? { ...item, progress: episodeNumber } : item
      ) || [];
      updateLists(updatedLists);
    }
  };

  const getProgress = (animeId: number): number | null => {
    if (isAuthenticated) {
      const entry = lists?.find(item => item.media.id === animeId);
      return entry?.progress || null;
    } else {
      return localProgress[animeId]?.episodeNumber || null;
    }
  };

  return {
    updateProgress,
    getProgress,
    isLoading,
  };
}
</file>

<file path="src/hooks/use-watchlist.ts">
"use client";

import { useState, useEffect, useRef } from "react";
import { useAuth } from "@/hooks/useAuth";
import { useLocalStorage } from "@/hooks/use-local-storage";
import { WatchlistEntry, WatchStatus } from "@/types/watchlist";
import { updateAnimeFromList, deleteAnimeFromList } from "@/modules/anilist/anilistsAPI";

export function useWatchlist() {
  const { isAuthenticated, lists, updateLists } = useAuth();
  const [localWatchlist, setLocalWatchlist] = useLocalStorage<WatchlistEntry[]>("watchlist", []);
  const [isLoading, setIsLoading] = useState(true);
  const initialLoadDone = useRef(false);

  useEffect(() => {
    if (!initialLoadDone.current) {
      if (isAuthenticated && lists) {
        const syncedList = lists.map(item => ({
          id: item.mediaId || item.media.id,
          status: (item.status?.toLowerCase() || "watching") as WatchStatus,
          progress: item.progress || 0,
          media: {
            id: item.media.id,
            title: item.media.title,
            coverImage: item.media.coverImage,
            episodes: item.media.episodes,
            genres: item.media.genres,
          },
          updatedAt: Date.now(),
        }));
        setLocalWatchlist(syncedList);
      }
      initialLoadDone.current = true;
      setIsLoading(false);
    }
  }, [isAuthenticated, lists, setLocalWatchlist]);

  const addToWatchlist = async (entry: WatchlistEntry) => {
    if (isAuthenticated) {
      const mediaListId = await updateAnimeFromList(
        entry.id,
        entry.status.toUpperCase(),
        undefined,
        entry.progress
      );
      
      if (mediaListId) {
        const updatedLists = lists?.map(item => 
          item.mediaId === entry.id ? { ...item, status: entry.status.toUpperCase() } : item
        ) || [];
        updateLists(updatedLists);
      }
    } else {
      const existingIndex = localWatchlist.findIndex(item => item.id === entry.id);
      if (existingIndex >= 0) {
        const newList = [...localWatchlist];
        newList[existingIndex] = entry;
        setLocalWatchlist(newList);
      } else {
        setLocalWatchlist([...localWatchlist, entry]);
      }
    }
  };

  const removeFromWatchlist = async (animeId: number) => {
    if (isAuthenticated) {
      const success = await deleteAnimeFromList(animeId);
      if (success) {
        const updatedLists = lists?.filter(item => item.mediaId !== animeId) || [];
        updateLists(updatedLists);
      }
    } else {
      setLocalWatchlist(localWatchlist.filter(item => item.id !== animeId));
    }
  };

  const getStatus = (animeId: number): WatchStatus | null => {
    if (isAuthenticated) {
      const entry = lists?.find(item => item.mediaId === animeId);
      return entry ? (entry.status?.toLowerCase() as WatchStatus) : null;
    } else {
      const entry = localWatchlist.find(item => item.id === animeId);
      return entry ? entry.status : null;
    }
  };

  return {
    watchlist: isAuthenticated ? lists : localWatchlist,
    addToWatchlist,
    removeFromWatchlist,
    getStatus,
    isLoading,
  };
}
</file>

<file path="src/hooks/useAuth.ts">
import { useState, useEffect } from "react";
import { authenticateUser, clearAuthSession, loadPersistedAuth } from "@/lib/auth";
import type { AuthState, UserProfile, AnimeListEntry } from "@/types/auth";

const initialState: AuthState = {
  isAuthenticated: false,
  user: null,
  lists: [],
  isLoading: true,
  error: null
};

export function useAuth() {
  const [state, setState] = useState<AuthState>(initialState);

  useEffect(() => {
    const loadAuth = async () => {
      // Check both access token and user data
      const accessToken = sessionStorage.getItem("access_token");
      const userData = sessionStorage.getItem("user_data");
      const listsData = sessionStorage.getItem("anime_lists");

      if (accessToken && userData) {
        setState({
          isAuthenticated: true,
          user: JSON.parse(userData),
          lists: listsData ? JSON.parse(listsData) : [],
          isLoading: false,
          error: null
        });
      } else {
        setState(prev => ({ ...prev, isLoading: false }));
      }
    };

    loadAuth();
  }, []);

  const login = async (token: string) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    
    try {
      const response = await authenticateUser(token);
      
      if (response.success && response.user && response.lists) {
        setState({
          isAuthenticated: true,
          user: response.user,
          lists: response.lists,
          isLoading: false,
          error: null
        });
        return true;
      } else {
        setState(prev => ({
          ...prev,
          isLoading: false,
          error: response.error || "Authentication failed"
        }));
        return false;
      }
    } catch (error) {
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: "An unexpected error occurred"
      }));
      return false;
    }
  };

  const logout = () => {
    clearAuthSession();
    setState({
      isAuthenticated: false,
      user: null,
      lists: [],
      isLoading: false,
      error: null
    });
  };

  const updateLists = (newLists: AnimeListEntry[]) => {
    setState(prev => ({
      ...prev,
      lists: newLists
    }));
    sessionStorage.setItem("anime_lists", JSON.stringify(newLists));
  };

  return {
    ...state,
    login,
    logout,
    updateLists
  };
}
</file>

<file path="src/lib/actions.ts">
export async function searchAnime(query: string) {
  const response = await fetch("https://graphql.anilist.co", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      query: `
        query ($search: String) {
          Page(page: 1, perPage: 10) {
            media(type: ANIME, search: $search) {
              id
              title {
                romaji
                english
              }
              coverImage {
                large
                medium
              }
              bannerImage
              description
              episodes
              status
              genres
              averageScore
              popularity
              season
              seasonYear
              format
              duration
              studios {
                nodes {
                  id
                  name
                }
              }
            }
          }
        }
      `,
      variables: { search: query },
    }),
  });

  const { data } = await response.json();
  return data?.Page?.media || [];
}
</file>

<file path="src/lib/anilist.ts">
const ANILIST_API = 'https://graphql.anilist.co';

export type Anime = {
  id: number;
  title: {
    romaji: string;
    english: string;
  };
  coverImage: {
    large: string;
    medium: string;
  };
  bannerImage: string;
  description: string;
  episodes: number;
  status: string;
  genres: string[];
  averageScore: number;
  popularity: number;
  season?: string;
  seasonYear?: number;
  format?: string;
  duration?: number;
  studios?: {
    nodes: {
      id: number;
      name: string;
    }[];
  };
};

const fetchAnimeData = async (query: string, variables = {}) => {
  try {
    const response = await fetch(ANILIST_API, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ query, variables }),
    });

    const { data } = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching anime data:', error);
    return null;
  }
};

export async function getTrendingAnime(): Promise<Anime[]> {
  const query = `
    query {
      Page(page: 1, perPage: 16) {
        media(type: ANIME, sort: TRENDING_DESC) {
          id
          title {
            romaji
            english
          }
          coverImage {
            large
            medium
          }
          bannerImage
          description
          episodes
          status
          genres
          averageScore
          popularity
        }
      }
    }
  `;

  const data = await fetchAnimeData(query);
  return data?.Page?.media || [];
}

export async function getPopularThisSeason(): Promise<Anime[]> {
  const query = `
    query {
      Page(page: 1, perPage: 12) {
        media(type: ANIME, sort: POPULARITY_DESC, season: FALL, seasonYear: 2024, status: RELEASING) {
          id
          title {
            romaji
            english
          }
          coverImage {
            large
            medium
          }
          bannerImage
          description
          episodes
          status
          genres
          averageScore
          popularity
          season
          seasonYear
        }
      }
    }
  `;

  const data = await fetchAnimeData(query);
  return data?.Page?.media || [];
}

export async function getUpcomingNextSeason(): Promise<Anime[]> {
  const query = `
    query {
      Page(page: 1, perPage: 12) {
        media(type: ANIME, sort: POPULARITY_DESC, season: WINTER, seasonYear: 2025, status: NOT_YET_RELEASED) {
          id
          title {
            romaji
            english
          }
          coverImage {
            large
            medium
          }
          bannerImage
          description
          episodes
          status
          genres
          averageScore
          popularity
          season
          seasonYear
        }
      }
    }
  `;

  const data = await fetchAnimeData(query);
  return data?.Page?.media || [];
}

export async function getTopRatedAnime(): Promise<Anime[]> {
  const query = `
    query {
      Page(page: 1, perPage: 12) {
        media(type: ANIME, sort: POPULARITY_DESC) {
          id
          title {
            romaji
            english
          }
          coverImage {
            large
            medium
          }
          bannerImage
          description
          episodes
          status
          genres
          averageScore
          popularity
        }
      }
    }
  `;

  const data = await fetchAnimeData(query);
  return data?.Page?.media || [];
}

export async function getAnimeById(id: number): Promise<Anime | null> {
  const query = `
    query ($id: Int) {
      Media(id: $id, type: ANIME) {
        id
        title {
          romaji
          english
        }
        coverImage {
          large
          medium
        }
        bannerImage
        description
        episodes
        status
        genres
        averageScore
        popularity
        season
        seasonYear
        format
        duration
        streamingEpisodes {
          thumbnail
          title
          url
        }
        studios {
          nodes {
            id
            name
          }
        }
      }
    }
  `;

  const data = await fetchAnimeData(query, { id });
  return data?.Media || null;
}


export async function getAllAnimeIds(): Promise<number[]> {
  const [trending, popular, upcoming, topRated] = await Promise.all([
    getTrendingAnime(),
    getPopularThisSeason(),
    getUpcomingNextSeason(),
    getTopRatedAnime(),
  ]);

  const allAnime = [...trending, ...popular, ...upcoming, ...topRated];
  return Array.from(new Set(allAnime.map(anime => anime.id)));
}
</file>

<file path="src/lib/auth.ts">
import { getAccessToken, getViewerId, getViewerInfo, getViewerLists } from "@/modules/anilist/anilistsAPI";
import type { AuthResponse, AnimeListEntry } from "@/types/auth";
import type { MediaListStatus } from "@/types/anilistGraphQLTypes";
import { clientData } from "@/modules/clientData";

export async function authenticateUser(token: string): Promise<AuthResponse> {
  try {
    const accessToken = await getAccessToken(token);
    if (!accessToken) {
      return { success: false, error: "Failed to obtain access token" };
    }

    sessionStorage.setItem("access_token", accessToken);

    const viewerId = await getViewerId();
    if (!viewerId) {
      return { success: false, error: "Failed to obtain user ID" };
    }

    const userData = await getViewerInfo(viewerId);
    if (!userData) {
      return { success: false, error: "Failed to fetch user data" };
    }

    // Store complete user data including avatar
    const userProfile = {
      id: userData.id,
      name: userData.name,
      avatar: {
        medium: userData.avatar?.medium
      }
    };
    
    sessionStorage.setItem("user_data", JSON.stringify(userProfile));
    sessionStorage.setItem("viewer_id", viewerId.toString());

    return {
      success: true,
      user: userProfile,
      lists: []
    };
  } catch (error) {
    console.error('Authentication error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Authentication failed"
    };
  }
}

export function clearAuthSession(): void {
  sessionStorage.removeItem("access_token");
  sessionStorage.removeItem("viewer_id");
  sessionStorage.removeItem("anime_lists");
}

export function loadPersistedAuth(): AuthResponse {
  try {
    const accessToken = sessionStorage.getItem("access_token");
    const viewerId = sessionStorage.getItem("viewer_id");
    const listsData = sessionStorage.getItem("anime_lists");

    if (!accessToken || !viewerId) {
      return { success: false };
    }

    const lists = listsData ? JSON.parse(listsData) : [];

    return {
      success: true,
      lists
    };
  } catch (error) {
    console.error("Error loading persisted auth:", error);
    return { success: false, error: "Failed to load saved session" };
  }
}

export function getAuthUrl() {

  return `https://anilist.co/api/v2/oauth/authorize?client_id=${clientData.clientId}&redirect_uri=${clientData.redirectUri}&response_type=code`;
}
</file>

<file path="src/lib/cache-service.ts">
import { PrismaClient } from '@prisma/client'
import { IVideo, IAnimeEpisode } from '@consumet/extensions'

const prisma = new PrismaClient()

export class CacheService {
    private readonly API_ENDPOINT = `${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/cache`;


    async cacheImage(url: string, animeId: number, type: 'cover' | 'banner') {
        try {
            const response = await fetch(this.API_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    url, 
                    animeId, 
                    type, 
                    action: 'cacheImage' 
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error caching image:', error);
            return null;
        }
    }

    async cacheAnimeImages(animeId: number, coverImage?: string, bannerImage?: string) {
        const response = await fetch(this.API_ENDPOINT, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                animeId, 
                coverImage, 
                bannerImage, 
                action: 'cacheAnimeImages' 
            })
        });
        return response.json();
    }

    async cacheEpisode(animeId: number, episode: number, sources: IVideo[]) {
        const response = await fetch(this.API_ENDPOINT, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                animeId, 
                episode, 
                sources, 
                action: 'cacheEpisode' 
            })
        });
        return response.json();
    }

    async getEpisodeCache(animeId: number, episode: number) {
        const response = await fetch(this.API_ENDPOINT, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ 
                animeId, 
                episode, 
                action: 'getEpisodeCache' 
            })
        });
        return response.json();
    }
    async getImageCache(url: string) {
        try {
            const response = await fetch(this.API_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    url, 
                    action: 'getImageCache' 
                })
            });
            
            if (!response.ok) {
                return { error: true };
            }
            
            return response.json();
        } catch (error) {
            console.error('Error getting image cache:', error);
            return { error: true };
        }
    }
}

export const cacheService = new CacheService();
</file>

<file path="src/lib/cache.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import { prisma } from '@/lib/prisma';
import { IAnimeEpisode, IVideo } from '@consumet/extensions';
import { cacheService } from './cache-service';

export default class ProviderCache {
    search: { [key: string]:  IVideo[] | null};
    animeIds: { [key: string]: string | null};
    episodes: { [key: string]: IAnimeEpisode[] | undefined };
  
    constructor() {
        // Initialize all cache objects
        this.search = Object.create(null);
        this.animeIds = Object.create(null);
        this.episodes = Object.create(null);
    }
  }

// Create singleton instance
const globalCache = new ProviderCache();


const handler = async (req: NextApiRequest, res: NextApiResponse) => {
    if (req.method !== 'POST') {
      return res.status(405).json({ message: 'Method not allowed' });
    }
  
    const { action } = req.body;
  
    switch (action) {
      case 'cacheImage':
        return handleCacheImage(req, res);
      case 'cacheAnimeImages':
        return handleCacheAnimeImages(req, res);
      case 'cacheEpisode':
        return handleCacheEpisode(req, res);
      case 'getEpisodeCache':
        return handleGetEpisodeCache(req, res);
      case 'getImageCache':
        return handleGetImageCache(req, res);
      default:
        return res.status(400).json({ message: 'Invalid action' });
    }

  };
  const handleCacheImage = async (url: string, animeId: number, type: 'cover' | 'banner') => {
    try {
      const response = await cacheService.getImageCache(url);
      if (!response || response.error) {
        const cacheResponse = await cacheService.cacheImage(url, animeId, type);
        if (cacheResponse) {
          console.log(`Successfully cached image for anime ${animeId}`);
        }
      }
    } catch (error) {
      console.log('Image cache handling:', error);
    }
  };
  

async function handleCacheAnimeImages(req: NextApiRequest, res: NextApiResponse) {
  const { animeId, coverImage, bannerImage } = req.body;
  try {
    const promises = [];
    if (coverImage) {
      promises.push(prisma.imageCache.upsert({
        where: { url: coverImage },
        update: { updatedAt: new Date() },
        create: { url: coverImage, animeId, type: 'cover' }
      }));
    }
    if (bannerImage) {
      promises.push(prisma.imageCache.upsert({
        where: { url: bannerImage },
        update: { updatedAt: new Date() },
        create: { url: bannerImage, animeId, type: 'banner' }
      }));
    }
    const results = await Promise.all(promises);
    return res.status(200).json(results);
  } catch (error) {
    console.error('Cache anime images error:', error);
    return res.status(500).json({ message: 'Failed to cache anime images' });
  }
}

async function handleCacheEpisode(req: NextApiRequest, res: NextApiResponse) {
  const { animeId, episode, sources } = req.body;
  try {
    const cached = await prisma.episodeCache.upsert({
      where: { 
        animeId_episode: { animeId, episode }
      },
      update: { 
        sources,
        updatedAt: new Date()
      },
      create: {
        animeId,
        episode,
        sources,
        quality: sources.map((s: IVideo) => s.quality)
      }
    });
    return res.status(200).json(cached);
  } catch (error) {
    console.error('Cache episode error:', error);
    return res.status(500).json({ message: 'Failed to cache episode' });
  }
}

async function handleGetEpisodeCache(req: NextApiRequest, res: NextApiResponse) {
  const { animeId, episode } = req.body;
  try {
    const cached = await prisma.episodeCache.findUnique({
      where: {
        animeId_episode: { animeId, episode }
      }
    });
    return res.status(200).json(cached);
  } catch (error) {
    console.error('Get episode cache error:', error);
    return res.status(500).json({ message: 'Failed to get episode cache' });
  }
}

async function handleGetImageCache(req: NextApiRequest, res: NextApiResponse) {
  const { url } = req.body;
  try {
    const cached = await prisma.imageCache.findUnique({
      where: { url }
    });
    return res.status(200).json(cached);
  } catch (error) {
    console.error('Get image cache error:', error);
    return res.status(500).json({ message: 'Failed to get image cache' });
  }
}
</file>

<file path="src/lib/prisma.ts">
import { PrismaClient } from "@prisma/client";

declare global {
  var prisma: PrismaClient | undefined;
}

export const prisma = global.prisma || new PrismaClient();

if (process.env.NODE_ENV !== "production") global.prisma = prisma;
</file>

<file path="src/lib/redis.ts">
import { Redis } from "ioredis";
import { RateLimiterRedis } from "rate-limiter-flexible";

const REDIS_URL: string | undefined = process.env.REDIS_URL;

let redis: Redis;
let rateLimiterRedis: RateLimiterRedis;
let rateLimitStrict: RateLimiterRedis;
let rateSuperStrict: RateLimiterRedis;

if (REDIS_URL) {
  redis = new Redis(REDIS_URL);
  redis.on("error", (err: Error) => {
    console.error("Redis error: ", err);
  });

  const opt = {
    storeClient: redis,
    keyPrefix: "rateLimit",
    points: 50,
    duration: 1,
  };

  const optStrict = {
    storeClient: redis,
    keyPrefix: "rateLimitStrict",
    points: 20,
    duration: 1,
  };

  const optSuperStrict = {
    storeClient: redis,
    keyPrefix: "rateLimitSuperStrict",
    points: 3,
    // duration 10 minutes
    duration: 10 * 60,
    blockDuration: 10 * 60,
  };

  rateLimiterRedis = new RateLimiterRedis(opt);
  rateLimitStrict = new RateLimiterRedis(optStrict);
  rateSuperStrict = new RateLimiterRedis(optSuperStrict);
} else {
  console.warn("REDIS_URL is not defined. Redis caching will be disabled.");
}

export { redis, rateLimiterRedis, rateLimitStrict, rateSuperStrict };
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatTime(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const remainingSeconds = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
  }
  return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
}

export function formatDate(date: string | number): string {
  return new Date(date).toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
}

export function formatNumber(num: number): string {
  return new Intl.NumberFormat("en-US", {
    notation: "compact",
    maximumFractionDigits: 1,
  }).format(num);
}

export interface AuthResponse {
  success: boolean;
  user?: any;
  lists?: any;
}

export function loadPersistedAuth(): AuthResponse {
  try {
    const accessToken = sessionStorage.getItem('access_token');
    const viewerId = sessionStorage.getItem('viewer_id');
    const userData = sessionStorage.getItem('user_data');
    const listsData = sessionStorage.getItem('anime_lists');

    if (!accessToken || !viewerId || !userData || !listsData) {
      return { success: false };
    }

    return {
      success: true,
      user: JSON.parse(userData),
      lists: JSON.parse(listsData)
    };
  } catch (error) {
    console.error("Error loading persisted auth:", error);
    return { success: false };
  }
}
</file>

<file path="src/modules/anilist/anilistsAPI.ts">
import {
  AnimeData,
  CurrentListAnime,
  ListAnimeData,
  MostPopularAnime,
  TrendingAnime,
} from '../../types/anilistAPITypes';
import { AiringPage, AiringSchedule, Media, MediaListStatus} from '../../types/anilistGraphQLTypes';
import { ClientData } from '../../types/types';
import { clientData } from '../clientData';

import { getOptions, makeRequest } from '../requests';
import { proxyRequest } from '../utils';


const CLIENT_DATA: ClientData = {
  clientId: clientData.clientId,
  redirectUri: clientData.redirectUri,
  clientSecret: clientData.clientSecret || ''
};
const PAGES: number = 20;
const METHOD: string = 'POST';
const GRAPH_QL_URL: string = 'https://graphql.anilist.co';
const HEADERS: Object = {
  'Content-Type': 'application/json',
  Accept: 'application/json',
};
const RECOMMEND_DATA: string = `
        recommendations(sort:RATING_DESC) {
          nodes {
            id
            rating
            mediaRecommendation {
              id
              idMal
              type
              title {
                  romaji
                  english
                  native
                  userPreferred
              }
              format
              status
              description
              startDate {
                  year
                  month
                  day
              }
              endDate {
                  year
                  month
                  day
              }
              season
              seasonYear
              episodes
              duration
              coverImage {
                  large
                  extraLarge
                  color
              }
              bannerImage
              genres
              synonyms
              averageScore
              meanScore
              popularity
              favourites
              isAdult
              nextAiringEpisode {
                  id
                  timeUntilAiring
                  episode
                  airingAt
              }
              mediaListEntry {
                  id
                  mediaId
                  status
                  score(format:POINT_10)
                  progress
              }
              siteUrl
              trailer {
                  id
                  site
                  thumbnail
              }
            }
          }
        }`
const MEDIA_DATA: string = `
        id
        idMal
        type
        title {
            romaji
            english
            native
            userPreferred
        }
        format
        status
        description
        startDate {
            year
            month
            day
        }
        endDate {
            year
            month
            day
        }
        season
        seasonYear
        episodes
        duration
        coverImage {
            large
            extraLarge
            color
        }
        bannerImage
        genres
        synonyms
        averageScore
        meanScore
        popularity
        favourites
        isAdult
        nextAiringEpisode {
            id
            timeUntilAiring
            episode
            airingAt
        }
        airingSchedule {
          edges {
            node {
              episode
            }
          }
        }
        mediaListEntry {
            id
            mediaId
            status
            score(format:POINT_10)
            progress
        }
        siteUrl
        trailer {
            id
            site
            thumbnail
        }
        relations {
          edges {
            id
            relationType(version: 2)
            node {
              id
              idMal
              type
              title {
                  romaji
                  english
                  native
                  userPreferred
              }
              format
              status
              description
              startDate {
                  year
                  month
                  day
              }
              endDate {
                  year
                  month
                  day
              }
              season
              seasonYear
              episodes
              duration
              coverImage {
                  large
                  extraLarge
                  color
              }
              bannerImage
              genres
              synonyms
              averageScore
              meanScore
              popularity
              favourites
              isAdult
              nextAiringEpisode {
                  id
                  timeUntilAiring
                  episode
              }
              airingSchedule {
                edges {
                  node {
                    episode
                  }
                }
              }
              mediaListEntry {
                  id
                  mediaId
                  status
                  score(format:POINT_10)
                  progress
              }
              siteUrl
              trailer {
                  id
                  site
                  thumbnail
              }
            }
          }
        }
        ${RECOMMEND_DATA}
    `;

const filterAdultMedia = (media?: Media) =>
  media && !media.isAdult;

/**
 * Retrieves the access token for the api
 *
 * @param {*} code
 * @returns access token
 */
export const getAccessToken = async (code: string): Promise<string> => {
  const url = 'https://anilist.co/api/v2/oauth/token';

  const data = {
    grant_type: 'authorization_code',
    client_id: CLIENT_DATA.clientId,
    client_secret: CLIENT_DATA.clientSecret,
    redirect_uri: CLIENT_DATA.redirectUri,
    code: code,
  };

  console.log('Auth request data:', {
    ...data,
     // Don't log the secret
  });

  const respData = await proxyRequest(url, 'POST', {
    'Content-Type': 'application/json',
    Accept: 'application/json',
  }, data);

  return respData.access_token;
};

/**
 * Gets the anilist viewer (user) id
 *
 * @returns viewer id
 */
export const getViewerId = async (): Promise<number> => {
var query = `
        query {
            Viewer {
                id
            }
        }
    `;

var headers = {
  Authorization: 'Bearer ' + sessionStorage.getItem("access_token"),
  'Content-Type': 'application/json',
  Accept: 'application/json',
};

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Viewer.id;
};

/**
 * Gets the viewer (user) info
 *
 * @param {*} viewerId
 * @returns object with viewer info
 */
export const getViewerInfo = async (viewerId: number | null) => {
  var query = `
          query($userId : Int) {
              User(id: $userId, sort: ID) {
                  id
                  name
                  avatar {
                      medium
                  }
                  options {
                    displayAdultContent
                  }
              }
          }
      `;

  var headers = {
    Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  var variables = {
    userId: viewerId,
  };

  const options = getOptions(query, variables);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.User;
};

/**
 * Gets viewer lists (current, completed...)
 *
 * @param {*} viewerId
 * @param {*} statuses
 * @returns object with anime entries
 */
export const getViewerLists = async (
  viewerId: number,
  ...statuses: MediaListStatus[]
): Promise<CurrentListAnime> => {
  var query = `
          query($userId : Int, $statuses: [MediaListStatus]) {
              MediaListCollection(userId : $userId, type: ANIME, status_in: $statuses, sort: UPDATED_TIME_DESC) {
                  lists {
                      isCustomList
                      name
                      status
                      entries {
                          id
                          mediaId
                          progress
                          media {
                              ${MEDIA_DATA}
                          }
                      }
                  }
              }
          }
      `;

  var headers = {
    Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  var variables = {
    userId: viewerId,
    statuses: statuses
  };

  const options = getOptions(query, variables);

  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  const lists = respData.data.MediaListCollection.lists.length === 0
  ? []
  : (respData.data.MediaListCollection.lists as Array<any>);

  return lists.map(value => value.entries).flat();
};

/**
 * Gets a viewer list (current, completed...)
 *
 * @param {*} viewerId
 * @param {*} status
 * @returns object with anime entries
 */
export const getViewerList = async (
  viewerId: number,
  status: MediaListStatus,
): Promise<CurrentListAnime> => {
  var query = `
          query($userId : Int) {
              MediaListCollection(userId : $userId, type: ANIME, status : ${status}, sort: UPDATED_TIME_DESC) {
                  lists {
                      isCustomList
                      name
                      entries {
                          id
                          mediaId
                          progress
                          media {
                              ${MEDIA_DATA}
                          }
                      }
                  }
              }
          }
      `;

  var headers = {
    Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  var variables = {
    userId: viewerId,
  };

  const options = getOptions(query, variables);

  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.MediaListCollection.lists.length === 0
    ? []
    : respData.data.MediaListCollection.lists[0].entries;
};

// NOT WORKING
export const getFollowingUsers = async (viewerId: any) => {
  var query = `
          query($userId : Int) {
              User(id: $userId, sort: ID) {
                  id
                  name
                  avatar {
                      large
                  }
              }
          }
      `;

  var headers = {
    Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  var variables = {
    userId: viewerId,
  };

  const options = getOptions(query, variables);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);
};

const sanitizeString = (input: string) => JSON.stringify(input).slice(1, -1).replace(/[{};`\\"'\!]/g, '');

/**
 * Gets a list of anime from a list of titles.
 *
 * @param titles
 * @returns anime list
 */
export const getAnimesFromTitles = async (titles: string[]) => {
  let query_variables: string[] = [];
  let variables: { [key: string]: string } = {};
  let search_text: string[] = [];

  const results: ListAnimeData[] = [];
  const headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
  };

  for (let index = 0; index < titles.length; index++) {
      const value = titles[index];
      const id: string = `anime${query_variables.length}`;

      query_variables.push(`$${id}: String`);
      search_text.push(`    ${id}: Media(search: $${id}, type: ANIME) { ${MEDIA_DATA} }`);
      variables[id] = sanitizeString(value).replaceAll('Part', '');

      if (query_variables.length > 2 || index === titles.length - 1) {
          const query = `
              query(${query_variables.join(", ")}) {
              ${search_text.join("\n")}
              }
          `;
          try {
            const options = getOptions(query, variables);
            const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

            for (let i = 0; i < query_variables.length; i++) {
                const id = `anime${i}`;
                results.push({
                    id: null,
                    mediaId: null,
                    progress: null,
                    media: respData.data[id],
                });
            }
          } catch (error) {
            console.log('Batch search error:', error);
          }

          query_variables = [];
          variables = {};
          search_text = [];
      }
  }

  return results;
};


/**
 * Gets the info from an anime
 *
 * @param {*} animeId
 * @returns object with anime info
 */
// Update the getAnimeInfo function to handle server-side and client-side auth
export const getAnimeInfo = async (animeId: number): Promise<Media> => {
  const query = `
    query($id: Int) {
      Media(id: $id, type: ANIME) {
        ${MEDIA_DATA}
      }
    }
  `;

  const headers: {[key: string]: string} = {
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  // Only add auth header if we're on the client and have a token
  if (typeof window !== 'undefined' && sessionStorage.getItem('access_token')) {
    headers.Authorization = `Bearer ${sessionStorage.getItem('access_token')}`;
  }

  const variables = {
    id: animeId,
  };

  const options = getOptions(query, variables);
  // console.log('Making request with:', {
  //   method: METHOD,
  //   url: GRAPH_QL_URL,
  //   headers,
  //   options
  // });
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Media as Media;
};

/**
 * get aired anime
 *
 * @param viewerId
 * @param airingAt
 * @returns a list of aired anime
 */

export const getAiredAnime = async (
  viewerId: number | null,
  amount: number = PAGES,
  timeOffset: number = 43200,
  airingAt: number = Date.now() / 1000,
  page: number = 1,
) => {
  airingAt = Math.floor(airingAt);
  const airingAfter = Math.floor(airingAt - timeOffset);

  const query = `
  query {
    Page(page: ${page}, perPage: ${amount}) {
      pageInfo {
        hasNextPage
      },
      airingSchedules(airingAt_greater: ${airingAfter}, airingAt_lesser: ${airingAt}) {
        episode,
        timeUntilAiring,
        airingAt,
        media {
          ${MEDIA_DATA}
        }
      }
    }
  }`;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);
  const pageData = respData.data.Page as AiringPage;

  pageData.airingSchedules = pageData.airingSchedules.reverse();

  const adultContent = sessionStorage.getItem('adult_content') as unknown as boolean;
  if (!adultContent)
    pageData.airingSchedules = pageData.airingSchedules.filter((value) => filterAdultMedia(value.media));

  return pageData
};

/**
 * gets airing schedule
 *
 * @param viewerId
 * @returns
 */

export const getAiringSchedule = async (
  viewerId: number | null,
  airingAt: number = Math.floor(Date.now() / 1000)
) => {
  const query = `
  query {
    Page(page: 1, perPage: ${PAGES}) {
      pageInfo {
        hasNextPage
      },
      airingSchedules(airingAt_greater: ${airingAt}) {
        episode,
        timeUntilAiring,
        airingAt,
        media {
          ${MEDIA_DATA}
        }
      }
    }
  }`;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);
  const pageData = respData.data.Page as AiringPage;

  const adultContent = sessionStorage.getItem('adult_content') as unknown as boolean;
  if (!adultContent)
    pageData.airingSchedules = pageData.airingSchedules.filter((value) => filterAdultMedia(value.media));

  return pageData.airingSchedules as AiringSchedule[];
};

/**
 * Gets the current trending animes on anilist
 * pass viewerId to make an authenticated request
 *
 * @param {*} viewerId
 * @returns object with trending animes
 */
export const getTrendingAnime = async (
  viewerId: number | null,
): Promise<TrendingAnime> => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(sort: TRENDING_DESC, type: ANIME) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);
  return respData.data.Page;
};

/**
 * Gets the current most popular animes on anilist
 * pass viewerId to make an authenticated request
 *
 * @param {*} viewerId
 * @returns object with most popular animes
 */
export const getMostPopularAnime = async (
  viewerId: number | null,
): Promise<MostPopularAnime> => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(sort: POPULARITY_DESC, type: ANIME) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Page;
};

/**
 * Gets the next anime releases
 *
 * @returns object with next anime releases
 */
export const getNextReleases = async (viewerId: number | null) => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(status: NOT_YET_RELEASED, sort: POPULARITY_DESC, type: ANIME) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Page;
};

/**
 * Gets searched anime with filters
 *
 * @param {*} args
 * @returns object with the searched filtered anime
 */
export const searchFilteredAnime = async (
  args: string,
  viewerId: number | null,
  page: number = 1
): Promise<AnimeData> => {
  var query = `
      {
          Page(page: ${page}, perPage: 50) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(${args}) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Page;
};

/**
 * Gets the next anime releases
 *
 * @returns object with next anime releases
 */
export const releasingAnimes = async () => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(status: RELEASING, sort: POPULARITY_DESC, type: ANIME) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, HEADERS, options);

  return respData.data.Page;
};

/**
 * Gets the current trending animes filtered by a genre
 * pass viewerId to make an authenticated request
 *
 * @param {*} genre
 * @param {*} viewerId
 * @returns object with animes entries filtered by genre
 */
export const getAnimesByGenre = async (genre: any, viewerId: number | null) => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  hasNextPage
              }
              media(genre: "${genre}", sort: TRENDING_DESC, type: ANIME) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  if (viewerId) {
    var headers: any = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  } else {
    var headers: any = {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };
  }

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  return respData.data.Page;
};

/**
 * Gets anime entries from a search query
 *
 * @param {*} input
 * @returns object with searched animes
 */
export const getSearchedAnimes = async (input: any) => {
  var query = `
      {
          Page(page: 1, perPage: ${PAGES}) {
              pageInfo {
                  total
                  currentPage
                  lastPage
                  hasNextPage
                  perPage
              }
              media(search: "${input}", type: ANIME, sort: SEARCH_MATCH) {
                  ${MEDIA_DATA}
              }
          }
      }
      `;

  const options = getOptions(query);
  const respData = await makeRequest(METHOD, GRAPH_QL_URL, HEADERS, options);

  return respData.data.Page.media;
};

/* MUTATIONS */

/**
 * Updates a media entry list
 *
 * @param mediaId
 * @param status
 * @param scoreRaw
 * @param progress
 * @returns media list entry id
 */
export const updateAnimeFromList = async (
  mediaId: any,
  status?: any,
  scoreRaw?: any,
  progress?: any,
): Promise<number | null> => {
  try {
    var query = `
          mutation($mediaId: Int${progress ? ', $progress: Int' : ''}${scoreRaw ? ', $scoreRaw: Int' : ''}${status ? ', $status: MediaListStatus' : ''}) {
              SaveMediaListEntry(mediaId: $mediaId${progress ? ', progress: $progress' : ''}${scoreRaw ? ', scoreRaw: $scoreRaw' : ''}${status ? ', status: $status' : ''}) {
                  id
              }
          }
      `;

    var headers = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };

    var variables: any = {
      mediaId: mediaId,
    };

    if (status !== undefined) variables.status = status;
    if (scoreRaw !== undefined) variables.scoreRaw = scoreRaw;
    if (progress !== undefined) variables.progress = progress;

    const options = getOptions(query, variables);
    const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

    console.log(
      `Anime list updated (status: ${status},score: ${scoreRaw},progress: ${progress}) for list ${mediaId}`,
    );

    return respData.data.SaveMediaListEntry.id;
  } catch (error) {
    console.log(error);
    return null;
  }
};

export const deleteAnimeFromList = async (id: any): Promise<boolean> => {
  try {
    var query = `
          mutation($id: Int){
              DeleteMediaListEntry(id: $id){
                  deleted
              }
          }
      `;

    console.log('delte: ', id);

    var headers = {
      Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
      'Content-Type': 'application/json',
      Accept: 'application/json',
    };

    var variables = {
      id: id,
    };

    const options = getOptions(query, variables);
    const respData = await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

    return respData
  } catch (error) {
    console.log(error);
    return false;
  }
};

/**
 * Updates the progress of an anime on list
 *
 * @param {*} mediaId
 * @param {*} progress
 */
export const updateAnimeProgress = async (
  mediaId: number,
  progress: number,
) => {
  var query = `
          mutation($mediaId: Int, $progress: Int) {
              SaveMediaListEntry(mediaId: $mediaId, progress: $progress) {
                  id
                  progress
              }
          }
      `;

  var headers = {
    Authorization: 'Bearer ' + sessionStorage.getItem('access_token'),
    'Content-Type': 'application/json',
    Accept: 'application/json',
  };

  var variables = {
    mediaId: mediaId,
    progress: progress,
  };

  const options = getOptions(query, variables);
  await makeRequest(METHOD, GRAPH_QL_URL, headers, options);

  console.log(`Progress updated (${progress}) for anime ${mediaId}`);
};
</file>

<file path="src/modules/animeCustomTitles.ts">
/*
    Some anime are difficult to pull automatically, so the
    correct titles for those (I hope rare) exceptions are written here.

    "AnimeId": { title: '`AnimeCustomTitle`', index: 0 } // problem faced

    where title is the anime title and index the element to take
*/

type AnimeCustomTitles = {
    [languageCode: string]: {
      [animeId: string]: {
        title: string;
        index: number;
      };
    };
  };
  
  export const animeCustomTitles: AnimeCustomTitles = {
    US: {
      // '235': { title: `Detective Conan Remastered`, index: 0 },
      '132052': { title: 'Kakkou no Iinazuke', index: 1 }, // same releaseDate with another one
      '168623': { title: 'Dahlia in Bloom', index: 0 }, // anilist has wrong name (Madougushi Dahlia wa Utsumukanai -> Madougushi Dahliya wa Utsumukanai)
    },
    INT: {},
    IT: {},
    ES: {},
    HU: {},
  };
</file>

<file path="src/modules/aniskip.ts">
import { skip } from "node:test";
import { SkipEvent, SkipEventTypes } from "../types/aniskipTypes";
import { makeRequest } from "./requests";

const AniSkip = {
  baseUrl: "https://api.aniskip.com/",
  getSkipEvents: async function(
    malId: number,
    episodeNumber: number,
    episodeLength: number = 0
  ) {
    try {
      const data = await makeRequest('GET', `${this.baseUrl}v2/skip-times/${malId}/${episodeNumber}?types=op&types=ed&types=recap&episodeLength=${Math.floor(episodeLength)}`);

      if(!data.found)
        return [];

      return data.results as SkipEvent[];
    } catch {
      return [];
    }
  },
  getCurrentEvent: function(
    time: number,
    skipEvents: SkipEvent[],
  ) {
    if(!skipEvents || skipEvents.length === 0)
      return;

    for(const skipEvent of skipEvents) {
      const interval = skipEvent.interval;

      if(interval.startTime <= time && interval.endTime > time)
        return skipEvent
    }
  },
  getEventName: function(
    skipEvent: SkipEvent
  ) {
    for(const [name, value] of Object.entries(SkipEventTypes)) {
      if(value !== skipEvent.skipType)
        continue;

      return name;
    }
  }
}


export default AniSkip;
</file>

<file path="src/modules/clientData.ts">
import { ClientData } from "../types/types";

export const clientData = {
  clientId: parseInt(process.env.NEXT_PUBLIC_CLIENT_ID || '0', 10),
  redirectUri: process.env.NEXT_PUBLIC_REDIRECT_URI || '',
  clientSecret: 'SXVsEkfa1hG0br0qC1uQjJCesB3CxjRnfVmq0KSq',
};
</file>

<file path="src/modules/history.ts">
import { History, AnimeHistoryEntry, EpisodeHistoryEntry, HistoryEntries } from "../types/historyTypes";

let history: History = (typeof localStorage !== 'undefined' && localStorage.getItem('history')) ? JSON.parse(localStorage.getItem('history') || '{}') : { entries: {} };

/** * Get the history entry for the anime's id.
 *
 * @param animeId
 * @returns anime history
 */
export const getAnimeHistory = (
  animeId: number
): AnimeHistoryEntry | undefined => history.entries[animeId];

/**
 * Get all entries from local history.
 *
 * @returns history entries
 */
export const getHistoryEntries = (): HistoryEntries => history.entries;

/**
 * Get local history.
 *
 * @returns local history.
 */
export const getHistory = (): History => history;

/**
 * Get history entry for a specific episode
 *
 * @param animeId
 * @param episodeNumber
 * @returns history entry
 */
export const getEpisodeHistory = (
  animeId: number,
  episodeNumber: number
): EpisodeHistoryEntry | undefined => getAnimeHistory(animeId)?.history[episodeNumber]


/**
 * Set local history.
 *
 * @param newHistory
 */
export const setHistory = (
  newHistory: History
) => {
  history = newHistory;
  localStorage.setItem('history', JSON.stringify(newHistory));
}

/**
 * Update the anime's entry
 *
 * @param animeHistory
 */
export const setAnimeHistory = (
  animeHistory: AnimeHistoryEntry
) => {
  const listAnimeData = animeHistory.data;
  const animeId = (listAnimeData.media.id || listAnimeData.media.mediaListEntry && listAnimeData.media.mediaListEntry.id) as number

  history.entries[animeId] = animeHistory;

  localStorage.setItem('history', JSON.stringify(history));
}
/**
 * Get the last watched episode from an anime.
 *
 * @param animeId
 * @returns last watched episode
 */
export const getLastWatchedEpisode = (
  animeId: number
): EpisodeHistoryEntry | undefined => {
  const animeHistory = getAnimeHistory(animeId) as AnimeHistoryEntry;

  if(animeHistory === undefined)
    return;

  return Object.values(animeHistory?.history).reduce((latest, current) => {
    return current.timestamp > latest.timestamp ? current : latest;
  }, Object.values(animeHistory.history)[0]);
}
</file>

<file path="src/modules/providers/animedrive.ts">
import { IVideo } from '@consumet/extensions';
import AnimeDrive from '@consumet/extensions/dist/providers/anime/animedrive';
import ProviderCache from './cache';
import { NextApiRequest, NextApiResponse } from 'next';


export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { type, query } = req.query

  switch(type) {
    case 'search':
      const results = await consumet.search(query as string)
      return res.status(200).json(results)
    
    case 'info':
      const info = await consumet.fetchAnimeInfo(query as string)
      return res.status(200).json(info)
    
    case 'sources':
      const sources = await consumet.fetchEpisodeSources(query as string)
      return res.status(200).json(sources)
  }
}
const cache = new ProviderCache();
const consumet = new AnimeDrive();

export const getEpisodeUrl = async (
  animeTitles: string[],
  index: number,
  episode: number,
  dubbed: boolean,
): Promise<IVideo[] | null> => {
  console.log(
    `%c Episode ${episode}, looking for ${consumet.name} source...`,
    `color: #6b8cff`,
  );

  for (const animeSearch of animeTitles) {
    const result = await searchEpisodeUrl(animeSearch, index, episode, dubbed);
    if (result) {
      return result;
    }
  }

  return null;
};

/**
 * Gets the episode url and isM3U8 flag
 *
 * @param {*} animeSearch
 * @param {*} episode anime episode to look for
 * @param {*} dubbed dubbed version or not
 * @returns IVideo sources if found, null otherwise
 */
async function searchEpisodeUrl(
  animeSearch: string,
  index: number,
  episode: number,
  dubbed: boolean
): Promise<IVideo[] | null> {
  const cacheId = `${animeSearch}-${episode}`;
  if(cache.search[cacheId] !== undefined)
    return cache.search[cacheId];

  const animeId = await getAnimeId(
    dubbed ? 0 : index,
    dubbed ? `${animeSearch} (Dub)` : animeSearch,
  );

  if (animeId) {
    const animeEpisodeId = await getAnimeEpisodeId(animeId, episode);
    if (animeEpisodeId) {
      const data = await consumet.fetchEpisodeSources(animeEpisodeId);

      console.log(`%c ${animeSearch}`, `color: #45AD67`);
      return (
        cache.search[cacheId] = data.sources
      );
    }
  }

  console.log(`%c ${animeSearch}`, `color: #E5A639`);
  return (
    cache.search[cacheId] = null
  );
}

/**
 * Gets the anime id
 *
 * @param {*} animeSearch
 * @returns anime id if found, otherwise null
 */
export const getAnimeId = async (
  index: number,
  animeSearch: string,
): Promise<string | null> => {
  if(cache.animeIds[animeSearch] !== undefined)
    return cache.animeIds[animeSearch];

  const data = await consumet.search(animeSearch);
  return (
    cache.animeIds[animeSearch] = data.results[index]?.id ?? null
  );
};

/**
 * Gets the anime episode id
 *
 * @param {*} animeId
 * @param {*} episode
 * @returns anime episode id if found, otherwise null
 */
export const getAnimeEpisodeId = async (
  animeId: string,
  episode: number,
): Promise<string | null> => {
  if(cache.episodes[animeId] !== undefined) {
    const found = cache.episodes[animeId]?.find((ep) => ep.number == episode)

    if(found)
      return found.id;
  }

  const data = await consumet.fetchAnimeInfo(animeId);
  return (
    cache.episodes[animeId] = data?.episodes
  )?.[episode - 1]?.id ?? null;
};
</file>

<file path="src/modules/providers/animesaturn.ts">
import { IVideo } from '@consumet/extensions';
import AnimeSaturn from '@consumet/extensions/dist/providers/anime/animesaturn';

const consumet = new AnimeSaturn();

/**
 * 
 * @param animeTitles 
 * @param episode 
 * @param dubbed 
 * @returns 
 */
export const getEpisodeUrl = async (
  animeTitles: string[],
  episode: number,
  dubbed: boolean,
): Promise<IVideo | null> => {
  console.log(`%c Episode ${episode}, looking for ${consumet.name} source...`, `color: #6b8cff`);

  for (const animeSearch of animeTitles) {
    const result = await searchEpisodeUrl(animeSearch, episode, dubbed);
    if (result) {
      return result;
    }
  }

  return null;
}

/**
 * Gets the episode url and isM3U8 flag
 *
 * @param {*} animeTitles array of anime titles
 * @param {*} episode anime episode to look for
 * @param {*} dubbed dubbed version or not
 * @returns consumet IVideo if url is found, otherwise null
 */
async function searchEpisodeUrl(animeSearch: string, episode: number, dubbed: boolean): Promise<IVideo | null> {
  const animeId = await getAnimeId(dubbed ? `${animeSearch} (ITA)` : animeSearch);

  if (animeId) {
    const animeEpisodeId = await getAnimeEpisodeId(animeId, episode);
    if (animeEpisodeId) {
      const data = await consumet.fetchEpisodeSources(animeEpisodeId);
      console.log(`%c ${animeSearch}`, `color: #45AD67`);
      return data.sources[1]; // [1] is streamtape
    }
  }

  console.log(`%c ${animeSearch}`, `color: #E5A639`);
  return null;
}

/**
 * Gets the anime id
 *
 * @param {*} animeSearch
 * @returns anime id if found, otherwise null
 */
export const getAnimeId = async (
  animeSearch: string,
): Promise<string | null> => {
  const data = await consumet.search(animeSearch);
  return data.results[0]?.id ?? null;
};

/**
 * Gets the anime episode id
 *
 * @param {*} animeId
 * @param {*} episode
 * @returns anime episode id if found, otherwise null
 */
export const getAnimeEpisodeId = async (
  animeId: string,
  episode: number,
): Promise<string | null> => {
  const data = await consumet.fetchAnimeInfo(animeId);
  return data?.episodes?.[episode - 1]?.id ?? null;
};
</file>

<file path="src/modules/providers/animeunity.ts">
import { IVideo } from '@consumet/extensions';
import AnimeUnity from '@consumet/extensions/dist/providers/anime/animeunity';
import ProviderCache from './cache';
import { getCacheId } from '../utils';
import { NextApiRequest, NextApiResponse } from 'next';

const consumet = new AnimeUnity();
const cache = new ProviderCache();

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { type, query } = req.query

  switch(type) {
    case 'search':
      const results = await consumet.search(query as string)
      return res.status(200).json(results)
    
    case 'info':
      const info = await consumet.fetchAnimeInfo(query as string)
      return res.status(200).json(info)
    
    case 'sources':
      const sources = await consumet.fetchEpisodeSources(query as string)
      return res.status(200).json(sources)
  }
}


/**
 *
 * @param animeTitles
 * @param episode
 * @param dubbed
 * @returns
 */
export const getEpisodeUrl = async (
  animeTitles: string[],
  index: number,
  episode: number,
  dubbed: boolean,
  releaseDate: number,
): Promise<IVideo[] | null> => {
  console.log(
    `%c Episode ${episode}, looking for ${consumet.name} source...`,
    `color: #0c7475`,
  );

  for (const animeSearch of animeTitles) {
    const result = await searchEpisodeUrl(
      animeSearch,
      index,
      episode,
      dubbed,
      releaseDate,
    );
    if (result) {
      return result;
    }
  }

  return null;
};

/**
 * Gets the episode url and isM3U8 flag
 *
 * @param {*} animeSearch
 * @param {*} episode anime episode to look for
 * @param {*} dubbed dubbed version or not
 * @returns consumet IVideo if url is found, otherwise null
 */
async function searchEpisodeUrl(
  animeSearch: string,
  index: number,
  episode: number,
  dubbed: boolean,
  releaseDate: number,
): Promise<IVideo[] | null> {
  const cacheId = getCacheId(animeSearch, episode, dubbed);

  if(cache.search[cacheId] !== undefined)
    return cache.search[cacheId];

  const animeId = await getAnimeId(
    index,
    dubbed ? `${animeSearch} (ITA)` : animeSearch,
    dubbed,
    releaseDate,
  );

  if (animeId) {
    const animeEpisodeId = await getAnimeEpisodeId(animeId, episode);
    if (animeEpisodeId) {
      const data = await consumet.fetchEpisodeSources(animeEpisodeId);
      console.log(`%c ${animeSearch}`, `color: #45AD67`);

      return (
        cache.search[cacheId] = data.sources
      );
    }
  }

  console.log(`%c ${animeSearch}`, `color: #E5A639`);
  return (
    cache.search[cacheId] = null
  );
}

/**
 * Gets the anime id
 *
 * @param {*} animeSearch
 * @returns anime id if found, otherwise null
 */
export const getAnimeId = async (
  index: number,
  animeSearch: string,
  dubbed: boolean,
  releaseDate: number,
): Promise<string | null> => {
  if(cache.animeIds[animeSearch] !== undefined)
    return cache.animeIds[animeSearch];

  const data = await consumet.search(animeSearch);

  const filteredResults = data.results.filter((result) =>
    dubbed
      ? (result.title as string).includes('(ITA)')
      : !(result.title as string).includes('(ITA)'),
  );

  return (
    cache.animeIds[animeSearch] = filteredResults.filter(
      (result) => result.releaseDate == releaseDate.toString(),
    )[index]?.id ?? null
  );
  // return data.results[index]?.id ?? null;
};

/**
 * Gets the anime episode id
 *
 * @param {*} animeId
 * @param {*} episode
 * @returns anime episode id if found, otherwise null
 */
export const getAnimeEpisodeId = async (
  animeId: string,
  episode: number,
): Promise<string | null> => {
  if(cache.episodes[animeId] !== undefined) {
    const found = cache.episodes[animeId]?.find((ep) => ep.number == episode)

    if(found)
      return found.id;
  }
  const data = await consumet.fetchAnimeInfo(
    animeId,
    episode > 120 ? Math.floor(episode / 120) + 1 : 1,
  );

  return (
    cache.episodes[animeId] = data?.episodes
  )?.find((ep) => ep.number == episode)?.id ?? null;
};
</file>

<file path="src/modules/providers/api.ts">
import { IVideo } from '@consumet/extensions';
import { ListAnimeData } from '@/types/anilistAPITypes';
import { animeCustomTitles } from '../animeCustomTitles';
import { getAvailableEpisodes, getParsedAnimeTitles } from '../utils';
import { getEpisodeUrl as gogoanime } from './gogoanime';
import { getEpisodeUrl as hianime } from './hianime';
import { CachedLink } from '@/components/shared/cached-links'

const API_BASE = '/api/anime'


export const fetchFromProvider = async (provider: string, type: string, query: string) => {
  const response = await fetch(`${API_BASE}/${provider}?type=${type}&query=${encodeURIComponent(query)}`)
  return response.json()
}

export const getUniversalEpisodeUrl = async (
  listAnimeData: ListAnimeData,
  episode: number,
): Promise<IVideo[] | null> => {
  const lang = localStorage.getItem('source_flag') || 'INT';
  const dubbed = localStorage.getItem('dubbed') === 'true';
  const customTitle = animeCustomTitles[lang] && animeCustomTitles[lang][listAnimeData.media?.id!];
  const animeTitles = getParsedAnimeTitles(listAnimeData.media);
  
  if (customTitle) {
    animeTitles.unshift(customTitle.title);
  }

  const providers = [
    {
      name: 'Gogoanime',
      fetch: async () => {
        const sources = await gogoanime(
          animeTitles, 
          customTitle?.index || 0, 
          episode, 
          dubbed, 
          listAnimeData.media.startDate?.year ?? 0
        );
        
        // Preload next chunk while current is playing
        if (sources?.[0]?.url) {
          sources.forEach(source => {
            const preloadLink = document.createElement('link');
            preloadLink.rel = 'preload';
            preloadLink.as = 'fetch';
            preloadLink.href = source.url;
            document.head.appendChild(preloadLink);
          });
        }

        // if (episode < totalEpisodes) {
        //   getUniversalEpisodeUrl(listAnimeData, episode + 1);
        // }
        
        return sources?.sort((a, b) => {
          const qualityA = parseInt(a.quality?.replace('p', '') ?? '0');
          const qualityB = parseInt(b.quality?.replace('p', '') ?? '0');
          return qualityB - qualityA;
        });
      }
    },

  ];


  for (const provider of providers) {
    try {
      const sources = await provider.fetch();
      if (sources && sources.length > 0) {
        console.log(`Found ${sources.length} quality options from ${provider.name}`);
        return sources;
      }
    } catch (error) {
      console.error(`Failed to fetch from ${provider.name}:`, error);
      continue;
    }
  }

  return null;
}


export const getBestQualityVideo = (videos: IVideo[]): IVideo => {
  const qualityOrder = ['1080p', '720p', '480p', '360p', 'default', 'backup'];

  videos.sort((a, b) => {
    const indexA = qualityOrder.indexOf(a.quality || 'default');
    const indexB = qualityOrder.indexOf(b.quality || 'default');

    if (indexA < indexB) return -1;
    if (indexA > indexB) return 1;
    return 0;
  });

  return videos[0];
};
</file>

<file path="src/modules/providers/cache.ts">
import { IVideo, IAnimeEpisode } from "@consumet/extensions"

export default class ProviderCache {
  search: { [key: string]:  IVideo[] | null};
  animeIds: { [key: string]: string | null};
  episodes: { [key: string]: IAnimeEpisode[] | undefined };

  constructor() {
    this.search = {};
    this.animeIds = {};
    this.episodes = {};
  }
}
</file>

<file path="src/modules/providers/gogoanime.ts">
import { IVideo } from '@consumet/extensions';
import Gogoanime from '@consumet/extensions/dist/providers/anime/gogoanime';
import ProviderCache from './cache';
import { getCacheId, proxyRequest } from '../utils';
import { NextApiRequest, NextApiResponse } from 'next';

const cache = new ProviderCache();
const consumet = new Gogoanime();


export const getEpisodeUrl = async (
  animeTitles: string[],
  index: number,
  episode: number,
  dubbed: boolean,
  releaseDate: number,
): Promise<IVideo[] | null> => {
  console.log(
    `%c Episode ${episode}, looking for ${consumet.name} source...`,
    `color: #ffc119`,
  );

  for (const animeSearch of animeTitles) {
    const result = await searchEpisodeUrl(
      animeSearch,
      index,
      episode,
      dubbed,
      releaseDate,
    );
    if (result) {
      return result;
    }
  }

  return null;
};

/**
 * Gets the episode url and isM3U8 flag
 *
 * @param {*} animeSearch
 * @param {*} episode anime episode to look for
 * @param {*} dubbed dubbed version or not
 * @returns IVideo sources if found, null otherwise
 */
async function searchEpisodeUrl(
  animeSearch: string,
  index: number,
  episode: number,
  dubbed: boolean,
  releaseDate: number,
): Promise<IVideo[] | null> {
  const cacheId = getCacheId(animeSearch, episode, dubbed);

  if(cache.search[cacheId] !== undefined)
    return cache.search[cacheId];

  try {
    const animeId = await getAnimeId(
      index,
      dubbed ? `${animeSearch} (Dub)` : animeSearch,
      dubbed,
      releaseDate,
    );

    if (animeId) {
      const animeEpisodeId = await getAnimeEpisodeId(animeId, episode);
      if (animeEpisodeId) {
        // Request all qualities
        const [gogocdn, streamsb, vidstreaming] = await Promise.all([
          proxyRequest(`https://apiconsumet-gamma.vercel.app/anime/gogoanime/watch/${animeEpisodeId}?server=gogocdn`),
          proxyRequest(`https://apiconsumet-gamma.vercel.app/anime/gogoanime/watch/${animeEpisodeId}?server=streamsb`),
          proxyRequest(`https://apiconsumet-gamma.vercel.app/anime/gogoanime/watch/${animeEpisodeId}?server=vidstreaming`)
        ]);

        const sources = [
          ...(gogocdn?.sources || []),
          ...(streamsb?.sources || []),
          ...(vidstreaming?.sources || [])
        ];

        console.log(`Found sources for ${animeSearch}:`, sources);
        return (cache.search[cacheId] = sources);
      }
    }
  } catch (error) {
    console.error("Error fetching episode:", error);
    return null;
  }

  return (cache.search[cacheId] = null);
}




/**
 * Gets the anime id
 *
 * @param {*} animeSearch
 * @returns anime id if found, otherwise null
 */
export const getAnimeId = async (
  index: number,
  animeSearch: string,
  dubbed: boolean,
  releaseDate: number,
): Promise<string | null> => {
  if(cache.animeIds[animeSearch] !== undefined)
    return cache.animeIds[animeSearch];

  const data = await proxyRequest(`https://apiconsumet-gamma.vercel.app/anime/gogoanime/${animeSearch}?page=1`);

  const filteredResults = data.results.filter((result: { title: string; }) =>
    dubbed
      ? (result.title as string).includes('(Dub)')
      : !(result.title as string).includes('(Dub)'),
  );

  const result = (
    cache.animeIds[animeSearch] = filteredResults.filter(
      (result: { releaseDate: string; title: string; }) => result.releaseDate == releaseDate.toString() ||
        result.title == animeSearch,
    )[index]?.id ?? null
  );

  return result;
};

/**
 * Gets the anime episode id
 *
 * @param {*} animeId
 * @param {*} episode
 * @returns anime episode id if found, otherwise null
 */
export const getAnimeEpisodeId = async (
  animeId: string,
  episode: number,
): Promise<string | null> => {
  if(cache.episodes[animeId] !== undefined) {
    const found = cache.episodes[animeId]?.find((ep) => ep.number == episode)

    if(found)
      return found.id;
  }

  const data = await proxyRequest(`https://apiconsumet-gamma.vercel.app/anime/gogoanime/info/${animeId}`);
  return (
    cache.episodes[animeId] = data?.episodes
  )?.find((ep: { number: number; }) => ep.number == episode)?.id ?? null;
};
</file>

<file path="src/modules/providers/hianime.ts">
import { IVideo } from '@consumet/extensions';
import ProviderCache from './cache';
import Zoro from '@consumet/extensions/dist/providers/anime/zoro';
import axios from 'axios';
import { getCacheId } from '../utils';

const cache = new ProviderCache();
const consumet = new Zoro();
const apiUrl = 'https://aniwatch-api-ch0nker.vercel.app'
import { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { type, query, episode } = req.query

  switch(type) {
    case 'search':
      const results = await consumet.search(query as string)
      return res.status(200).json(results)
    
    case 'info':
      const info = await consumet.fetchAnimeInfo(query as string)
      return res.status(200).json(info)
    
    case 'sources':
      const sources = await consumet.fetchEpisodeSources(query as string)
      return res.status(200).json(sources)
  }
}
export const getEpisodeUrl = async (
animeTitles: string[], index: number, episode: number, dubbed: boolean, p0: number,
): Promise<IVideo[] | null> => {
  console.log('HiAnime search params:', {
    titles: animeTitles,
    index,
    episode,
    dubbed
  });

  for (const animeSearch of animeTitles) {
    const result = await searchEpisodeUrl(
      animeSearch,
      index,
      episode,
      dubbed
    );
    if (result) {
      console.log('HiAnime found source:', result);
      return result;
    }
  }

  return null;
};

/**
 * Gets the episode url and isM3U8 flag
 *
 * @param {*} animeSearch
 * @param {*} episode anime episode to look for
 * @param {*} dubbed dubbed version or not
 * @returns IVideo sources if found, null otherwise
 */
async function searchEpisodeUrl(
  animeSearch: string,
  index: number,
  episode: number,
  dubbed: boolean,
): Promise<IVideo[] | null> {
  const cacheId = getCacheId(animeSearch, episode, dubbed);

  if(cache.search[cacheId] !== undefined)
    return cache.search[cacheId];

  const animeId = await getAnimeId(
    index,
    dubbed ? `${animeSearch} (Dub)` : animeSearch,
    dubbed,
  );

  if (animeId) {
    const animeEpisodeId = await getAnimeEpisodeId(animeId, episode);
    console.log('episodeId',animeEpisodeId)
    if (animeEpisodeId) {
      try {
        const data = await consumet.fetchEpisodeSources(animeEpisodeId);
        console.log(`%c ${animeSearch}`, `color: #45AD67`);
        return (
          cache.search[cacheId] = data.sources.map((value) => {
              value.tracks = data.subtitles;
              value.skipEvents = {
                intro: data.intro,
                outro: data.outro
              };

              return value;
          }) ?? null
        );
      } catch {
        /* consumet fails to get raw servers so this needed. damn */
        const episodeId = animeEpisodeId.replace('$episode$', '?ep=').split('$')[0];

        const servers = (await axios.get(
          `${apiUrl}/anime/servers?episodeId=${episodeId}`
        )).data;
        const episodeInfo = await axios.get(
          `${apiUrl}/anime/episode-srcs?id=${episodeId}&server=hd-1&category=${dubbed ?
            'dub' :
            servers.sub.length > 0 ? 'sub' : 'raw'
          }`
        );

        return (
          cache.search[cacheId] = (episodeInfo.data.sources as IVideo[]).map((value) => {
              value.tracks = (episodeInfo.data.tracks as any[]).map(value => ({
                url: value.file,
                lang: value.label
              }));

              value.skipEvents = {
                intro: episodeInfo.data.intro,
                outro: episodeInfo.data.outro
              };

              console.log(value.tracks)

              return value;
          }) ?? null
        )
      }
    }
  }

  cache.search[cacheId] = null;
  console.log(`%c ${animeSearch}`, `color: #E5A639`);
  return null;
}

/**
 * Gets the anime id
 *
 * @param {*} animeSearch
 * @returns anime id if found, otherwise null
 */
export const getAnimeId = async (
  index: number,
  animeSearch: string,
  dubbed: boolean,
): Promise<string | null> => {
  if(cache.animeIds[animeSearch] !== undefined)
    return cache.animeIds[animeSearch];

  const data = await consumet.search(animeSearch);

  const filteredResults = data.results.filter((result) =>
    dubbed
      ? (result.title as string).includes('(Dub)')
      : !(result.title as string).includes('(Dub)'),
  );

  const normalizedSearch = animeSearch.toLowerCase();

  const result = (
    cache.animeIds[animeSearch] = filteredResults.filter(
      result =>
        (result.title.toString()).toLowerCase() === normalizedSearch ||
        (result.japaneseTitle.toString()).toLowerCase() === normalizedSearch
    )[index]?.id ?? null
  );

  return result;
};




/**
 * Gets the anime episode id
 *
 * @param {*} animeId
 * @param {*} episode
 * @returns anime episode id if found, otherwise null
 */
export const getAnimeEpisodeId = async (
  animeId: string,
  episode: number,
): Promise<string | null> => {
  if(cache.episodes[animeId] !== undefined) {
    const found = cache.episodes[animeId]?.find((ep) => ep.number == episode)

    if(found)
      return found.id;
  }

  const data = await consumet.fetchAnimeInfo(animeId);
  return (
    cache.episodes[animeId] = data?.episodes
  )?.find((ep) => ep.number == episode)?.id ?? null;
};
</file>

<file path="src/modules/providers/monoschinos.ts">
// import { IVideo } from '@consumet/extensions';
// import MonosChinos from '@consumet/extensions/dist/providers/anime/monoschinos';

// import ProviderCache from './cache';

// const consumet = new MonosChinos()

// const cache = new ProviderCache();

// export const getEpisodeUrl = async (
//   animeTitles: string[],
//   index: number,
//   episode: number,
//   dubbed: boolean,
//   releaseDate: number,
//   totalEpisodes?: number
// ): Promise<IVideo[] | null> => {
//   console.log(
//     `%c Episode ${episode}, looking for ${consumet.name} source...`,
//     `color: #e70071`,
//   );

//   // all broken
//   return null 

//   // dubbed is not implemented :(
//   if (dubbed) return null

//   for (const animeSearch of animeTitles) {
//     const result = await searchEpisodeUrl(
//       animeSearch,
//       index,
//       episode,
//       dubbed,
//       releaseDate,
//       totalEpisodes
//     );
//     if (result) {
//       return result;
//     }
//   }

//   return null;
// };

// /**
//  * Gets the episode url and isM3U8 flag
//  *
//  * @param {*} animeSearch
//  * @param {*} episode anime episode to look for
//  * @param {*} dubbed dubbed version or not
//  * @returns IVideo sources if found, null otherwise
//  */
// async function searchEpisodeUrl(
//   animeSearch: string,
//   index: number,
//   episode: number,
//   dubbed: boolean,
//   releaseDate: number,
//   totalEpisodes?: number
// ): Promise<IVideo[] | null> {
//   const cacheId = `${animeSearch}-${episode}`;

//   if(cache.search[cacheId] !== undefined)
//     return cache.search[cacheId];

//   const animeId = await getAnimeId(
//     index,
//     dubbed ? `${animeSearch} (???????)` : animeSearch,
//     dubbed,
//     releaseDate,
//   );

//   if (animeId) {
//     const animeEpisodeId = await getAnimeEpisodeId(animeId, episode, totalEpisodes);
//     if (animeEpisodeId) {
//       const data = await consumet.fetchEpisodeSources(animeEpisodeId);
//       console.log(`%c ${animeSearch}`, `color: #45AD67`);
//       const result = (
//         cache.search[cacheId] = data.sources
//       );
//       return result;
//     }
//   }

//   cache.search[cacheId] = null;
//   console.log(`%c ${animeSearch}`, `color: #E5A639`);
//   return null;
// }

// /**
//  * Gets the anime id
//  *
//  * @param {*} animeSearch
//  * @returns anime id if found, otherwise null
//  */
// export const getAnimeId = async (
//   index: number,
//   animeSearch: string,
//   dubbed: boolean,
//   releaseDate: number,
// ): Promise<string | null> => {
//   if(cache.animeIds[animeSearch] !== undefined)
//     return cache.animeIds[animeSearch];

//   const data = await consumet.search(animeSearch);

//   const filteredResults = data.results.filter((result) =>
//     dubbed
//       ? (result.title as string).includes('(Dub)')
//       : !(result.title as string).includes('(Dub)'),
//   );

//   const result = (
//     cache.animeIds[animeSearch] = filteredResults.filter(
//       (result) => result.releaseDate == releaseDate.toString() ||
//         result.title == animeSearch,
//     )[index]?.id ?? null
//   );

//   return result;
// };

// /**
//  * Gets the anime episode id
//  *
//  * @param {*} animeId
//  * @param {*} episode
//  * @returns anime episode id if found, otherwise null
//  */
// export const getAnimeEpisodeId = async (
//   animeId: string,
//   episode: number,
//   totalEpisodes?: number
// ): Promise<string | null> => {
//   if(cache.episodes[animeId] !== undefined) {
//     const found = cache.episodes[animeId]?.find((ep) => ep.number == episode)

//     if(found)
//       return found.id;
//   }

//   const data = await consumet.fetchAnimeInfo(animeId, totalEpisodes);
//   return (
//     cache.episodes[animeId] = data?.episodes
//   )?.find((ep) => ep.number == episode)?.id ?? null;
// };
</file>

<file path="src/modules/requests.ts">
import axios from 'axios';

var remainingRequests = 90;
var resetTime = 0;
var lockUntil = 0;

const delay = async (seconds: number) => new Promise((resolve) => setTimeout(resolve, seconds * 1000));

const handleRateLimiting = async (current: number) => {
  if (current < lockUntil)
    await delay(lockUntil - current);

  if (current >= resetTime)
    remainingRequests = 90;

  if (remainingRequests <= 0)
    await delay(60);
};

const handleResponseHeaders = (headers: any) => {
  if (headers['x-ratelimit-remaining'])
    remainingRequests = parseInt(headers['x-ratelimit-remaining']);

  if (headers['x-ratelimit-reset'])
    resetTime = parseInt(headers['x-ratelimit-reset']);
};

/**
 * Builds the data options for the request
 *
 * @param {*} query
 * @param {*} variables
 * @returns object with the data options
 */
export const getOptions = (query: any = {}, variables: any = {}) => {
  return JSON.stringify({
    query: query,
    variables: variables,
  });
};

/**
 * Makes a Promise based HTTP request with Axios
 *
 * @param {*} method
 * @param {*} url
 * @param {*} headers
 * @param {*} options
 * @returns object with the fetched data
 * @throws error if the request was not successful
 */

export const makeRequest = async (
  method: 'GET' | 'POST' | string,
  url: string,
  headers: any = {},
  options: any = {},
): Promise<any> => {
  if (url === 'https://graphql.anilist.co') {
    const current = Date.now() / 1000;

    await handleRateLimiting(current);

    try {
      const response = await axios({
        method: method,
        url: url,
        headers: headers,
        data: options,
      });

      handleResponseHeaders(response.headers);

      return response.data;
    } catch (error) {
      let response = (error as { response?: { status: number, headers: { [key: string]: any } } }).response;

      if (response && response.status === 429) {
        const retryAfter = parseInt(response.headers['retry-after'] || '60');
        lockUntil = current + retryAfter;
        await delay(retryAfter);
        return makeRequest(method, url, headers, options);
      }

      throw error;
    }
  }

  const response = await axios({
    method: method,
    url: url,
    headers: headers,
    data: options,
  });

  return response.data;
};
</file>

<file path="src/modules/utils.ts">
import { Media } from "@/types/anilistGraphQLTypes";

export async function proxyRequest(url: string, method: string = 'GET', headers: object = {}, data?: any) {
  const response = await fetch('/api/anime/proxy', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      url,
      method,
      headers,
      data
    })
  });
  return response.json();
}

export function getParsedAnimeTitles(media: Media): string[] {
  const titles: string[] = [];

  // Add all available titles
  if (media.title?.english) titles.push(media.title.english);
  if (media.title?.romaji) titles.push(media.title.romaji);
  if (media.title?.native) titles.push(media.title.native);
  
  // Add synonyms if available
  if (media.synonyms) {
    titles.push(...media.synonyms);
  }

  // Clean and normalize titles
  return titles
    .filter(Boolean) // Remove empty/null values
    .map(title => title.trim())
    .filter((title, index, self) => self.indexOf(title) === index); // Remove duplicates
}

export function formatTime(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const remainingSeconds = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
  }
  return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
}

export function getCacheId(
  animeSearch: string,
  episode: number,
  dubbed: boolean,
): string {
  return `${animeSearch}-${episode}-${dubbed ? 'dub' : 'sub'}`;
}

export function getAvailableEpisodes(media: Media): number | null {
  if (media.episodes != null) {
    return media.episodes;
  }
  
  if (media.nextAiringEpisode != null) {
    return media.nextAiringEpisode.episode - 1;
  }

  if (media.airingSchedule?.edges?.[0]?.node?.episode) {
    return media.airingSchedule.edges[0].node.episode;
  }

  return null;
}

export function formatDate(date: string | number): string {
  return new Date(date).toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
}

export function formatNumber(num: number): string {
  return new Intl.NumberFormat("en-US", {
    notation: "compact",
    maximumFractionDigits: 1,
  }).format(num);
}
</file>

<file path="src/pages/api/anime/[provider]/[...params].ts">
import { NextApiRequest, NextApiResponse } from 'next';
import Gogoanime from '@consumet/extensions/dist/providers/anime/gogoanime';

const consumet = new Gogoanime();

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { provider, params } = req.query;
  
  if (provider === 'gogoanime' && Array.isArray(params)) {
    try {
      switch(params[0]) {
        case 'search':
          const results = await consumet.search(params[1]);
          return res.status(200).json(results);
        
        case 'info':
          const info = await consumet.fetchAnimeInfo(params[1]);
          return res.status(200).json(info);
        
        case 'watch':
          const sources = await consumet.fetchEpisodeSources(params[1]);
          return res.status(200).json(sources);
      }
    } catch (error) {
      return res.status(500).json({ error: 'Failed to fetch data' });
    }
  }

  return res.status(404).json({ error: 'Provider not found' });
}
</file>

<file path="src/pages/api/anime/proxy.ts">
import { NextApiRequest, NextApiResponse } from 'next';
import axios from 'axios';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
    if (req.method === 'OPTIONS') {
      res.setHeader('Access-Control-Allow-Credentials', 'true');
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
      res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
      res.setHeader('Access-Control-Max-Age', '86400');
      return res.status(200).end();
    }
  
    if (req.method !== 'POST') {
      return res.status(405).json({ error: 'Method not allowed' });
    }
  
    const { url, method = 'GET', headers = {}, data } = req.body;
    
    try {
      const response = await axios({
        url,
        method,
        headers: {
          ...headers,
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
          'Accept': 'application/json, text/plain, */*',
          'Accept-Language': 'en-US,en;q=0.9',
          'Origin': process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',
          'Referer': process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'
        },
        data, // Include the request data
        validateStatus: (status) => status < 500
      });
  
      res.setHeader('Access-Control-Allow-Credentials', 'true');
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
      res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
      
      res.status(response.status).json(response.data);
    } catch (error) {
      console.error('Proxy error:', error);
      res.status(500).json({ 
        error: 'Proxy request failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
</file>

<file path="src/services/auth.ts">
import { getAccessToken, getViewerId, getViewerInfo, getViewerLists } from "@/modules/anilist/anilistsAPI";
import type { MediaListStatus } from "@/types/anilistGraphQLTypes";

export interface UserData {
  id: number;
  name: string;
  avatar?: {
    medium?: string;
  };
}

export interface AuthResponse {
  success: boolean;
  error?: string;
  userData?: UserData;
  lists?: Array<{
    id: number | null;
    mediaId: number | null;
    progress?: number | null;
    media: {
      id: number;
      title: {
        english?: string;
        romaji?: string;
      };
      coverImage?: {
        large?: string;
      };
    };
  }>;
}

export async function handleAuthentication(token: string): Promise<AuthResponse> {
  try {
    // Get access token
    const accessToken = await getAccessToken(token);
    if (!accessToken) {
      return { success: false, error: "Failed to obtain access token" };
    }

    // Store access token
    if (typeof window !== 'undefined') {
      sessionStorage.setItem('access_token', accessToken);
    }
    
    // Get user ID
    const id = await getViewerId();
    if (!id) {
      return { success: false, error: "Failed to obtain user ID" };
    }

    // Store user ID
    if (typeof window !== 'undefined') {
      sessionStorage.setItem('viewer_id', id.toString());
    }
    
    // Get user data
    const userData = await getViewerInfo(id);
    if (!userData) {
      return { success: false, error: "Failed to fetch user data" };
    }

    // Get user lists
    const lists = await getViewerLists(
      id, 
      'CURRENT' as MediaListStatus,
      'REPEATING' as MediaListStatus,
      'PAUSED' as MediaListStatus
    );

    // Store lists
    if (typeof window !== 'undefined' && lists) {
      const serializedLists = lists.map(item => ({
        id: item.id,
        mediaId: item.mediaId,
        progress: item.progress,
        media: {
          id: item.media.id,
          title: {
            english: item.media.title?.english,
            romaji: item.media.title?.romaji
          },
          coverImage: {
            large: item.media.coverImage?.large
          }
        }
      }));
      sessionStorage.setItem("anime_lists", JSON.stringify(serializedLists));
    }

    return {
      success: true,
      userData: {
        id: userData.id,
        name: userData.name,
        avatar: {
          medium: userData.avatar?.medium
        }
      },
      lists
    };
  } catch (error) {
    console.error('Authentication error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Authentication failed"
    };
  }
}

export function clearAuthData(): void {
  if (typeof window !== 'undefined') {
    sessionStorage.removeItem("access_token");
    sessionStorage.removeItem("viewer_id");
    sessionStorage.removeItem("anime_lists");
  }
}
</file>

<file path="src/types/anilistAPITypes.tsx">
import { Media, PageInfo } from "./anilistGraphQLTypes"

export type UserInfo = {
  id: number
  name: string
  avatar?: {
    large?: string
    medium?: string
  }
}

export type AnimeData = {
  media?: Media[]
  pageInfo?: PageInfo
}

export type ListAnimeData = {
  [x: string]: any
  id: number | null
  mediaId: number | null
  progress?: number | null
  media: Media
}

export type TrendingAnime = AnimeData
export type MostPopularAnime = AnimeData
export type CurrentListAnime = ListAnimeData[]

export { Media }
</file>

<file path="src/types/anilistGraphQLTypes.tsx">
export type MediaTitle = {
    romaji?: string;
    english?: string;
    native?: string;
    userPreferred?: string;
  };
  
  export type MediaFormat =
    | 'TV'
    | 'TV_SHORT'
    | 'MOVIE'
    | 'SPECIAL'
    | 'OVA'
    | 'ONA'
    | 'MUSIC'
    | 'MANGA'
    | 'NOVEL'
    | 'ONE_SHOT'
    // Lazy related stuff
    | 'SEQUEL'
    | 'PREQUEL'
    | 'ALTERNATIVE'
    | 'SIDE_STORY'
    | 'CHARACTER'
    | 'SUMMARY';
  
  export type MediaStatus =
    | 'FINISHED'
    | 'RELEASING'
    | 'NOT_YET_RELEASED'
    | 'CANCELLED'
    | 'HIATUS';
  
  export type FuzzyDate = {
    year?: number;
    month?: number;
    day?: number;
  };
  
  export type MediaSeason = 'WINTER' | 'SPRING' | 'SUMMER' | 'FALL';
  
  export type MediaCoverImage = {
    extraLarge?: string;
    large?: string;
    medium?: string;
    color?: string;
  };
  
  export type AiringPage = {
    airingSchedules: AiringSchedule[];
    pageInfo: PageInfo;
  };
  
  export type AiringSchedule = {
    id: number;
    airingAt: number;
    timeUntilAiring: number;
    episode: number;
    mediaId: number;
    media?: Media;
  };
  
  export type AiringScheduleConnection = {
    edges?: Array<{
      node?: {
        episode: number;
      };
    }>;
  };
  
  export type MediaListStatus =
    | 'CURRENT'
    | 'PLANNING'
    | 'COMPLETED'
    | 'DROPPED'
    | 'PAUSED'
    | 'REPEATING';
  
  export type MediaList = {
    id: number;
    mediaId: number;
    status?: MediaListStatus;
    score?: number;
    progress?: number;
  };
  
  export type MediaTrailer = {
    id?: string;
    site?: string;
    thumbnail?: string;
  };
  
  export type PageInfo = {
    total: number;
    currentPage: number;
    hasNextPage: boolean;
  };
  
  export const RelationTypes = {
    Source: 'SOURCE',
    Alternative: 'ALTERNATIVE',
    Other: 'OTHER',
    Prequel: 'PREQUEL',
    Sequel: 'SEQUEL',
    Character: 'CHARACTER',
    SideStory: 'SIDE_STORY',
    Parent: 'PARENT',
    Adaptation: 'ADAPTATION',
    SpinOff: 'SPIN_OFF',
    Compilation: 'COMPILATION',
    Contains: 'CONTAINS',
  };
  
  export type RelationType = (typeof RelationTypes)[keyof typeof RelationTypes];
  
  export type Relation = {
    id: number;
    relationType: RelationType;
    node: Media;
  };
  
  export type RelationConnection = {
    edges: Relation[];
  };
  
  export type Recommend = {
    id: number;
    mediaRecommendation: Media;
  };
  
  export type RecommendConnection = {
    nodes: Recommend[];
  };
  
  export const MediaTypes = {
    Anime: 'ANIME',
    Manga: 'MANGA',
  };
  
  export type MediaType = (typeof MediaTypes)[keyof typeof MediaTypes];
  
  export type Media = {
    id?: number;
    type?: MediaType;
    idMal?: number;
    title?: MediaTitle;
    format?: MediaFormat;
    status?: MediaStatus;
    description?: string;
    startDate?: FuzzyDate;
    endDate?: FuzzyDate;
    season?: MediaSeason;
    seasonYear?: number;
    episodes: number;
    duration?: number;
    coverImage?: MediaCoverImage;
    bannerImage?: string;
    genres?: string[];
    synonyms?: string[];
    averageScore?: number;
    meanScore?: number;
    popularity?: number;
    favourites?: number;
    isAdult?: boolean;
    nextAiringEpisode?: AiringSchedule;
    airingSchedule?: AiringScheduleConnection;
    mediaListEntry?: MediaList;
    siteUrl?: string;
    trailer?: MediaTrailer;
    relations?: RelationConnection;
    recommendations?: RecommendConnection;
  };
</file>

<file path="src/types/aniskipTypes.tsx">
export const SkipEventTypes = {
    Intro: 'op',
    Outro: 'ed',
    Recap: 'recap'
  }
  
  export type SkipEventType = typeof SkipEventTypes[keyof typeof SkipEventTypes];
  
  export interface SkipEvent {
    episodeLength: number,
    interval: {
      startTime: number,
      endTime: number,
    },
    skipId: string,
    skipType: SkipEventType
  }
</file>

<file path="src/types/auth.ts">
export interface UserProfile {
  id: number;
  name: string;
  avatar?: {
    medium?: string;
  };
}

export interface AnimeListEntry {
  status: string;
  id: number | null;
  mediaId: number | null;
  progress: number | null;
  media: {
    genres: any;
    id: number;
    title: {
      english?: string;
      romaji?: string;
    };
    coverImage?: {
      large?: string;
    };
    episodes?: number;
    status?: string;
  };
}

export interface AuthState {
  isAuthenticated: boolean;
  user: UserProfile | null;
  lists: AnimeListEntry[];
  isLoading: boolean;
  error: string | null;
}

export interface AuthResponse {
  success: boolean;
  user?: UserProfile;
  lists?: AnimeListEntry[];
  error?: string;
}
</file>

<file path="src/types/historyTypes.tsx">
import { ListAnimeData } from "./anilistAPITypes"
import { EpisodeInfo } from "./types"

export interface EpisodeHistoryEntry {
  time: number
  timestamp: number
  duration?: number
  data: EpisodeInfo
}

export interface EpisodeHistoryEntries {
  [episodeNumber: number]: EpisodeHistoryEntry
}

export interface AnimeHistoryEntry {
  history: EpisodeHistoryEntries
  data: ListAnimeData
}

export interface HistoryEntries {
  [animeId: number]: AnimeHistoryEntry
}
export interface History {
  entries: HistoryEntries
}
</file>

<file path="src/types/search.ts">
export interface SearchFilters {
  query?: string;
  genres?: string[];
  seasons?: string[];
  year?: string;
  format?: string;
  sort?: string;
}

export interface SearchState extends SearchFilters {
  page: number;
  hasMore: boolean;
  isLoading: boolean;
  error: string | null;
}
</file>

<file path="src/types/types.tsx">
export type EpisodeInfo = {
    image?: string;
    title?: {
      en?: string
    }
    summary?: string
    airdate?: string
    length?: string | number
    episodeNumber?: number
    episode?: string
  };
  
  interface EpisodeHistoryEntry {
    timestamp: number;
    time: number;
    data: {
      progress: number;
    }
  }
  
  export type EpisodeHistoryEntries = {
    [key: number]: EpisodeHistoryEntry;
  }
  
  
  export type ClientData = {
    clientId: number;
    redirectUri: string;
    clientSecret: string;
  };
</file>

<file path="src/types/watchlist.ts">
export type WatchStatus = "watching" | "completed" | "on_hold" | "dropped" | "plan_to_watch";

export interface WatchlistEntry {
  id: number;
  status: WatchStatus;
  progress: number;
  score?: number;
  media: {
    id: number;
    title: {
      english?: string;
      romaji?: string;
    };
    coverImage?: {
      large?: string;
    };
    episodes?: number;
    genres?: string[];
  };
  updatedAt: number;
}
</file>

</repository_files>

This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-11-03T22:01:53.336Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</file_summary>

<repository_structure>
components/announcer.tsx
components/layouts/default/audio-layout.tsx
components/layouts/default/context.ts
components/layouts/default/hooks.ts
components/layouts/default/icons.tsx
components/layouts/default/index.ts
components/layouts/default/media-layout.tsx
components/layouts/default/slots.tsx
components/layouts/default/ui.ts
components/layouts/default/ui/announcer.tsx
components/layouts/default/ui/buttons.tsx
components/layouts/default/ui/captions.tsx
components/layouts/default/ui/controls.tsx
components/layouts/default/ui/keyboard-display.tsx
components/layouts/default/ui/menus/accessibility-menu.tsx
components/layouts/default/ui/menus/audio-menu.tsx
components/layouts/default/ui/menus/captions-menu.tsx
components/layouts/default/ui/menus/chapters-menu.tsx
components/layouts/default/ui/menus/font-menu.tsx
components/layouts/default/ui/menus/items/menu-checkbox.tsx
components/layouts/default/ui/menus/items/menu-items.tsx
components/layouts/default/ui/menus/items/menu-slider.tsx
components/layouts/default/ui/menus/playback-menu.tsx
components/layouts/default/ui/menus/settings-menu.tsx
components/layouts/default/ui/menus/utils.ts
components/layouts/default/ui/sliders.tsx
components/layouts/default/ui/time.tsx
components/layouts/default/ui/title.tsx
components/layouts/default/ui/tooltip.tsx
components/layouts/default/video-layout.tsx
components/layouts/plyr/context.ts
components/layouts/plyr/icons.tsx
components/layouts/plyr/icons/plyr-airplay.js
components/layouts/plyr/icons/plyr-captions-off.js
components/layouts/plyr/icons/plyr-captions-on.js
components/layouts/plyr/icons/plyr-download.js
components/layouts/plyr/icons/plyr-enter-fullscreen.js
components/layouts/plyr/icons/plyr-exit-fullscreen.js
components/layouts/plyr/icons/plyr-fast-forward.js
components/layouts/plyr/icons/plyr-muted.js
components/layouts/plyr/icons/plyr-pause.js
components/layouts/plyr/icons/plyr-pip.js
components/layouts/plyr/icons/plyr-play.js
components/layouts/plyr/icons/plyr-restart.js
components/layouts/plyr/icons/plyr-rewind.js
components/layouts/plyr/icons/plyr-settings.js
components/layouts/plyr/icons/plyr-volume.js
components/layouts/plyr/index.ts
components/layouts/plyr/layout.tsx
components/layouts/plyr/props.ts
components/layouts/plyr/slots.tsx
components/layouts/remotion-ui.ts
components/layouts/utils.ts
components/player-callbacks.ts
components/player.tsx
components/primitives/instances.ts
components/primitives/nodes.tsx
components/primitives/slot.tsx
components/provider.tsx
components/text-track.tsx
components/ui/buttons/airplay-button.tsx
components/ui/buttons/caption-button.tsx
components/ui/buttons/fullscreen-button.tsx
components/ui/buttons/google-cast-button.tsx
components/ui/buttons/live-button.tsx
components/ui/buttons/mute-button.tsx
components/ui/buttons/pip-button.tsx
components/ui/buttons/play-button.tsx
components/ui/buttons/seek-button.tsx
components/ui/buttons/toggle-button.tsx
components/ui/caption.tsx
components/ui/captions.tsx
components/ui/chapter-title.tsx
components/ui/controls.tsx
components/ui/gesture.tsx
components/ui/menu.tsx
components/ui/poster.tsx
components/ui/radio-group.tsx
components/ui/sliders/audio-gain-slider.tsx
components/ui/sliders/quality-slider.tsx
components/ui/sliders/slider-callbacks.ts
components/ui/sliders/slider-value.tsx
components/ui/sliders/slider.tsx
components/ui/sliders/speed-slider.tsx
components/ui/sliders/time-slider.tsx
components/ui/sliders/volume-slider.tsx
components/ui/spinner.tsx
components/ui/thumbnail.tsx
components/ui/time.tsx
components/ui/title.tsx
components/ui/tooltip.tsx
globals.d.ts
hooks/create-text-track.ts
hooks/options/use-audio-gain-options.ts
hooks/options/use-audio-options.ts
hooks/options/use-caption-options.ts
hooks/options/use-chapter-options.ts
hooks/options/use-playback-rate-options.ts
hooks/options/use-video-quality-options.ts
hooks/use-active-text-cues.ts
hooks/use-active-text-track.ts
hooks/use-chapter-title.ts
hooks/use-dom.ts
hooks/use-media-context.ts
hooks/use-media-player.ts
hooks/use-media-provider.ts
hooks/use-media-remote.ts
hooks/use-media-state.ts
hooks/use-signals.ts
hooks/use-slider-preview.ts
hooks/use-slider-state.ts
hooks/use-state.ts
hooks/use-text-cues.ts
hooks/use-thumbnails.ts
icon.ts
index.ts
providers/remotion/index.ts
providers/remotion/layout-engine.ts
providers/remotion/loader.ts
providers/remotion/playback-engine.ts
providers/remotion/provider.tsx
providers/remotion/type-check.ts
providers/remotion/types.ts
providers/remotion/ui/context.tsx
providers/remotion/ui/error-boundary.tsx
providers/remotion/ui/poster.tsx
providers/remotion/ui/slider-thumbnail.tsx
providers/remotion/ui/thumbnail.tsx
providers/remotion/validate.ts
source.ts
utils.ts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="components/announcer.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { MediaAnnouncerInstance } from './primitives/instances';
import { Primitive } from './primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * MediaAnnouncer
 * -----------------------------------------------------------------------------------------------*/

const MediaAnnouncerBridge = createReactComponent(MediaAnnouncerInstance, {
  events: ['onChange'],
});

export interface MediaAnnouncerProps extends ReactElementProps<MediaAnnouncerInstance> {
  ref?: React.Ref<HTMLElement>;
}

/**
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/display/announcer}
 * @example
 * ```tsx
 * <MediaAnnouncer />
 * ```
 */
const MediaAnnouncer = React.forwardRef<HTMLElement, MediaAnnouncerProps>(
  ({ style, children, ...props }, forwardRef) => {
    return (
      <MediaAnnouncerBridge {...(props as Omit<MediaAnnouncerProps, 'ref'>)}>
        {(props) => (
          <Primitive.div
            {...props}
            style={{ display: 'contents', ...style }}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.div>
        )}
      </MediaAnnouncerBridge>
    );
  },
);

MediaAnnouncer.displayName = 'MediaAnnouncer';
export { MediaAnnouncer };
</file>

<file path="components/layouts/default/audio-layout.tsx">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';
import { listenEvent, toggleClass } from 'maverick.js/std';

import { useChapterTitle } from '../../../hooks/use-chapter-title';
import { useResizeObserver, useTransitionActive } from '../../../hooks/use-dom';
import { useMediaContext } from '../../../hooks/use-media-context';
import { useMediaState } from '../../../hooks/use-media-state';
import { createComputed } from '../../../hooks/use-signals';
import * as Controls from '../../ui/controls';
import { useLayoutName } from '../utils';
import { i18n, useDefaultLayoutContext } from './context';
import { createDefaultMediaLayout, type DefaultLayoutProps } from './media-layout';
import {
  slot,
  useDefaultAudioLayoutSlots,
  type DefaultAudioLayoutSlots,
  type DefaultLayoutMenuSlotName,
  type Slots,
} from './slots';
import { DefaultAnnouncer } from './ui/announcer';
import {
  DefaultCaptionButton,
  DefaultDownloadButton,
  DefaultPlayButton,
  DefaultSeekButton,
} from './ui/buttons';
import { DefaultCaptions } from './ui/captions';
import { DefaultControlsSpacer } from './ui/controls';
import { DefaultChaptersMenu } from './ui/menus/chapters-menu';
import { DefaultSettingsMenu } from './ui/menus/settings-menu';
import { DefaultTimeSlider, DefaultVolumePopup } from './ui/sliders';
import { DefaultTimeInvert } from './ui/time';

/* -------------------------------------------------------------------------------------------------
 * DefaultAudioLayout
 * -----------------------------------------------------------------------------------------------*/

const MediaLayout = createDefaultMediaLayout({
  type: 'audio',
  smLayoutWhen({ width }) {
    return width < 576;
  },
  renderLayout: () => <AudioLayout />,
});

export interface DefaultAudioLayoutProps extends DefaultLayoutProps<DefaultAudioLayoutSlots> {}

/**
 * The audio layout is our production-ready UI that's displayed when the media view type is set to
 * 'audio'. It includes support for audio tracks, slider chapters, captions, live streams
 * and more out of the box.
 *
 * @attr data-match - Whether this layout is being used.
 * @attr data-sm - The small layout is active
 * @attr data-lg - The large layout is active.
 * @attr data-size - The active layout size (sm or lg).
 * @example
 * ```tsx
 * <MediaPlayer src="audio.mp3">
 *   <MediaProvider />
 *   <DefaultAudioLayout icons={defaultLayoutIcons} />
 * </MediaPlayer>
 * ```
 */
function DefaultAudioLayout(props: DefaultAudioLayoutProps) {
  const [scrubbing, setScrubbing] = React.useState(false),
    $pointer = useMediaState('pointer');

  const onStartScrubbing = React.useCallback((event: React.SyntheticEvent) => {
    const { target } = event,
      hasTimeSlider = !!(target instanceof HTMLElement && target.closest('.vds-time-slider'));
    if (!hasTimeSlider) return;
    event.nativeEvent.stopImmediatePropagation();
    setScrubbing(true);
  }, []);

  const onStopScrubbing = React.useCallback(() => {
    setScrubbing(false);
  }, []);

  React.useEffect(() => {
    if (scrubbing) return listenEvent(window, 'pointerdown', onStopScrubbing);
  }, [scrubbing, onStopScrubbing]);

  return (
    <MediaLayout
      {...props}
      data-scrubbing={scrubbing ? '' : null}
      onPointerDown={scrubbing ? (e) => e.stopPropagation() : undefined}
      onPointerDownCapture={$pointer === 'coarse' && !scrubbing ? onStartScrubbing : undefined}
    />
  );
}

DefaultAudioLayout.displayName = 'DefaultAudioLayout';
export { DefaultAudioLayout };

/* -------------------------------------------------------------------------------------------------
 * AudioLayout
 * -----------------------------------------------------------------------------------------------*/

function AudioLayout() {
  const slots = useDefaultAudioLayoutSlots();

  useLayoutName('audio');

  return (
    <>
      <DefaultAnnouncer />
      <DefaultCaptions />
      <Controls.Root className="vds-controls">
        <Controls.Group className="vds-controls-group">
          {slot(slots, 'seekBackwardButton', <DefaultSeekButton backward tooltip="top start" />)}
          {slot(slots, 'playButton', <DefaultPlayButton tooltip="top center" />)}
          {slot(slots, 'seekForwardButton', <DefaultSeekButton tooltip="top center" />)}
          <DefaultAudioTitle />
          {slot(slots, 'timeSlider', <DefaultTimeSlider />)}
          <DefaultTimeInvert slots={slots} />
          <DefaultVolumePopup orientation="vertical" tooltip="top" slots={slots} />
          {slot(slots, 'captionButton', <DefaultCaptionButton tooltip="top center" />)}
          {slot(slots, 'downloadButton', <DefaultDownloadButton />)}
          <DefaultAudioMenus slots={slots} />
        </Controls.Group>
      </Controls.Root>
    </>
  );
}

AudioLayout.displayName = 'AudioLayout';

/* -------------------------------------------------------------------------------------------------
 * DefaultAudioMenus
 * -----------------------------------------------------------------------------------------------*/

function DefaultAudioMenus({ slots }: { slots?: Slots<DefaultLayoutMenuSlotName> }) {
  const { isSmallLayout, noModal } = useDefaultLayoutContext(),
    placement = noModal ? 'top end' : !isSmallLayout ? 'top end' : null;
  return (
    <>
      {slot(
        slots,
        'chaptersMenu',
        <DefaultChaptersMenu tooltip="top" placement={placement} portalClass="vds-audio-layout" />,
      )}
      {slot(
        slots,
        'settingsMenu',
        <DefaultSettingsMenu
          tooltip="top end"
          placement={placement}
          portalClass="vds-audio-layout"
          slots={slots}
        />,
      )}
    </>
  );
}

DefaultAudioMenus.displayName = 'DefaultAudioMenus';

/* -------------------------------------------------------------------------------------------------
 * DefaultAudioTitle
 * -----------------------------------------------------------------------------------------------*/

function DefaultAudioTitle() {
  const [rootEl, setRootEl] = React.useState<HTMLElement | null>(null),
    media = useMediaContext(),
    { translations } = useDefaultLayoutContext(),
    [isTextOverflowing, setIsTextOverflowing] = React.useState(false);

  const isContinued = createComputed(() => {
    const { started, currentTime } = media.$state;
    return started() || currentTime() > 0;
  });

  const $title = useSignal(
    createComputed(() => {
      const { title, ended } = media.$state;
      if (!title()) return '';
      const word = ended() ? 'Replay' : isContinued() ? 'Continue' : 'Play';
      return `${i18n(translations, word)}: ${title()}`;
    }),
  );

  const chapterTitle = useChapterTitle(),
    $isContinued = useSignal(isContinued),
    $chapterTitle = $isContinued ? chapterTitle : '',
    isTransitionActive = useTransitionActive(rootEl);

  React.useEffect(() => {
    if (isTransitionActive && document.activeElement === document.body) {
      media.player.el?.focus({ preventScroll: true });
    }
  }, []);

  const onResize = React.useCallback(() => {
    const el = rootEl,
      isOverflowing = !!el && !isTransitionActive && el.clientWidth < el.children[0]!.clientWidth;
    if (el) toggleClass(el, 'vds-marquee', isOverflowing);
    setIsTextOverflowing(isOverflowing);
  }, [rootEl, isTransitionActive]);

  useResizeObserver(rootEl, onResize);

  return $title ? (
    <span className="vds-title" title={$title} ref={setRootEl}>
      <AudioTitle title={$title} chapterTitle={$chapterTitle} />
      {isTextOverflowing && !isTransitionActive ? (
        <AudioTitle title={$title} chapterTitle={$chapterTitle} />
      ) : null}
    </span>
  ) : (
    <DefaultControlsSpacer />
  );
}

DefaultAudioTitle.displayName = 'DefaultAudioTitle';

function AudioTitle({ title, chapterTitle }: { title: string; chapterTitle: string }) {
  const slots = useDefaultAudioLayoutSlots();
  return (
    <span className="vds-title-text">
      {slot(slots, 'title', title)}
      {slot(slots, 'chapterTitle', <span className="vds-chapter-title">{chapterTitle}</span>)}
    </span>
  );
}

AudioTitle.displayName = 'AudioTitle';
</file>

<file path="components/layouts/default/context.ts">
import * as React from 'react';

import type { ReadSignal, WriteSignal } from 'maverick.js';

import type { DefaultLayoutProps } from './media-layout';

export const DefaultLayoutContext = React.createContext<DefaultLayoutContext>({} as any);
DefaultLayoutContext.displayName = 'DefaultLayoutContext';

interface DefaultLayoutContext extends DefaultLayoutProps {
  layoutEl: ReadSignal<HTMLElement | null>;
  isSmallLayout: boolean;
  userPrefersAnnouncements: WriteSignal<boolean>;
  userPrefersKeyboardAnimations: WriteSignal<boolean>;
}

export function useDefaultLayoutContext() {
  return React.useContext(DefaultLayoutContext);
}

export function useDefaultLayoutWord(word: string) {
  const { translations } = useDefaultLayoutContext();
  return i18n(translations, word);
}

export function i18n(translations: any, word: string) {
  return translations?.[word] ?? word;
}
</file>

<file path="components/layouts/default/hooks.ts">
import { useColorSchemePreference } from '../../../hooks/use-dom';
import type { DefaultLayoutProps } from './media-layout';

export function useColorSchemeClass(colorScheme: DefaultLayoutProps['colorScheme']) {
  const systemColorPreference = useColorSchemePreference();
  if (colorScheme === 'default') {
    return null;
  } else if (colorScheme === 'system') {
    return systemColorPreference;
  } else {
    return colorScheme;
  }
}
</file>

<file path="components/layouts/default/icons.tsx">
import * as React from 'react';

import accessibilityIconPaths from 'media-icons/dist/icons/accessibility.js';
import airPlayIconPaths from 'media-icons/dist/icons/airplay.js';
import arrowDownIconPaths from 'media-icons/dist/icons/arrow-down.js';
import arrowLeftIconPaths from 'media-icons/dist/icons/arrow-left.js';
import arrowUpIconPaths from 'media-icons/dist/icons/arrow-up.js';
import chaptersIconPaths from 'media-icons/dist/icons/chapters.js';
import checkIconPaths from 'media-icons/dist/icons/check.js';
import arrowRightIconPaths from 'media-icons/dist/icons/chevron-right.js';
import googleCastIconPaths from 'media-icons/dist/icons/chromecast.js';
import ccOnIconPaths from 'media-icons/dist/icons/closed-captions-on.js';
import ccIconPaths from 'media-icons/dist/icons/closed-captions.js';
import downloadIconPaths from 'media-icons/dist/icons/download.js';
import eyeIconPaths from 'media-icons/dist/icons/eye.js';
import fastBackwardIconPaths from 'media-icons/dist/icons/fast-backward.js';
import fastForwardIconPaths from 'media-icons/dist/icons/fast-forward.js';
import exitFullscreenIconPaths from 'media-icons/dist/icons/fullscreen-exit.js';
import enterFullscreenIconPaths from 'media-icons/dist/icons/fullscreen.js';
import musicIconPaths from 'media-icons/dist/icons/music.js';
import muteIconPaths from 'media-icons/dist/icons/mute.js';
import noEyeIconPaths from 'media-icons/dist/icons/no-eye.js';
import pauseIconPaths from 'media-icons/dist/icons/pause.js';
import exitPIPIconPaths from 'media-icons/dist/icons/picture-in-picture-exit.js';
import enterPIPIconPaths from 'media-icons/dist/icons/picture-in-picture.js';
import playIconPaths from 'media-icons/dist/icons/play.js';
import playbackIconPaths from 'media-icons/dist/icons/playback-speed-circle.js';
import replayIconPaths from 'media-icons/dist/icons/replay.js';
import seekBackwardIconPaths from 'media-icons/dist/icons/seek-backward-10.js';
import seekForwardIconPaths from 'media-icons/dist/icons/seek-forward-10.js';
import settingsIconPaths from 'media-icons/dist/icons/settings.js';
import volumeHighIconPaths from 'media-icons/dist/icons/volume-high.js';
import volumeLowIconPaths from 'media-icons/dist/icons/volume-low.js';

import { Icon } from '../../../icon';

function createIcon(paths: string) {
  function DefaultLayoutIcon(props: DefaultLayoutIconProps) {
    return <Icon paths={paths} {...props} />;
  }

  DefaultLayoutIcon.displayName = 'DefaultLayoutIcon';
  return DefaultLayoutIcon;
}

export const defaultLayoutIcons: DefaultLayoutIcons = {
  AirPlayButton: {
    Default: createIcon(airPlayIconPaths),
  },
  GoogleCastButton: {
    Default: createIcon(googleCastIconPaths),
  },
  PlayButton: {
    Play: createIcon(playIconPaths),
    Pause: createIcon(pauseIconPaths),
    Replay: createIcon(replayIconPaths),
  },
  MuteButton: {
    Mute: createIcon(muteIconPaths),
    VolumeLow: createIcon(volumeLowIconPaths),
    VolumeHigh: createIcon(volumeHighIconPaths),
  },
  CaptionButton: {
    On: createIcon(ccOnIconPaths),
    Off: createIcon(ccIconPaths),
  },
  PIPButton: {
    Enter: createIcon(enterPIPIconPaths),
    Exit: createIcon(exitPIPIconPaths),
  },
  FullscreenButton: {
    Enter: createIcon(enterFullscreenIconPaths),
    Exit: createIcon(exitFullscreenIconPaths),
  },
  SeekButton: {
    Backward: createIcon(seekBackwardIconPaths),
    Forward: createIcon(seekForwardIconPaths),
  },
  DownloadButton: {
    Default: createIcon(downloadIconPaths),
  },
  Menu: {
    Accessibility: createIcon(accessibilityIconPaths),
    ArrowLeft: createIcon(arrowLeftIconPaths),
    ArrowRight: createIcon(arrowRightIconPaths),
    Audio: createIcon(musicIconPaths),
    Chapters: createIcon(chaptersIconPaths),
    Captions: createIcon(ccIconPaths),
    Playback: createIcon(playbackIconPaths),
    Settings: createIcon(settingsIconPaths),
    AudioBoostUp: createIcon(volumeHighIconPaths),
    AudioBoostDown: createIcon(volumeLowIconPaths),
    SpeedUp: createIcon(fastForwardIconPaths),
    SpeedDown: createIcon(fastBackwardIconPaths),
    QualityUp: createIcon(arrowUpIconPaths),
    QualityDown: createIcon(arrowDownIconPaths),
    FontSizeUp: createIcon(arrowUpIconPaths),
    FontSizeDown: createIcon(arrowDownIconPaths),
    OpacityUp: createIcon(eyeIconPaths),
    OpacityDown: createIcon(noEyeIconPaths),
    RadioCheck: createIcon(checkIconPaths),
  },
  KeyboardDisplay: {
    Play: createIcon(playIconPaths),
    Pause: createIcon(pauseIconPaths),
    Mute: createIcon(muteIconPaths),
    VolumeUp: createIcon(volumeHighIconPaths),
    VolumeDown: createIcon(volumeLowIconPaths),
    EnterFullscreen: createIcon(enterFullscreenIconPaths),
    ExitFullscreen: createIcon(exitFullscreenIconPaths),
    EnterPiP: createIcon(enterPIPIconPaths),
    ExitPiP: createIcon(exitPIPIconPaths),
    CaptionsOn: createIcon(ccOnIconPaths),
    CaptionsOff: createIcon(ccIconPaths),
    SeekForward: createIcon(fastForwardIconPaths),
    SeekBackward: createIcon(fastBackwardIconPaths),
  },
};

export interface DefaultLayoutIconProps
  extends React.PropsWithoutRef<React.SVGProps<SVGSVGElement>> {}

export interface DefaultLayoutIcon {
  (props: DefaultLayoutIconProps): React.ReactNode;
}

export interface DefaultAirPlayButtonIcons {
  Default: DefaultLayoutIcon;
  Connecting?: DefaultLayoutIcon;
  Connected?: DefaultLayoutIcon;
}

export interface DefaultGoogleCastButtonIcons {
  Default: DefaultLayoutIcon;
  Connecting?: DefaultLayoutIcon;
  Connected?: DefaultLayoutIcon;
}

export interface DefaultPlayButtonIcons {
  Play: DefaultLayoutIcon;
  Pause: DefaultLayoutIcon;
  Replay: DefaultLayoutIcon;
}

export interface DefaultMuteButtonIcons {
  Mute: DefaultLayoutIcon;
  VolumeLow: DefaultLayoutIcon;
  VolumeHigh: DefaultLayoutIcon;
}

export interface DefaultCaptionButtonIcons {
  On: DefaultLayoutIcon;
  Off: DefaultLayoutIcon;
}

export interface DefaultPIPButtonIcons {
  Enter: DefaultLayoutIcon;
  Exit: DefaultLayoutIcon;
}

export interface DefaultFullscreenButtonIcons {
  Enter: DefaultLayoutIcon;
  Exit: DefaultLayoutIcon;
}

export interface DefaultSeekButtonIcons {
  Backward: DefaultLayoutIcon;
  Forward: DefaultLayoutIcon;
}

export interface DefaultDownloadButtonIcons {
  Default: DefaultLayoutIcon;
}

export interface DefaultMenuIcons {
  Accessibility: DefaultLayoutIcon;
  ArrowLeft: DefaultLayoutIcon;
  ArrowRight: DefaultLayoutIcon;
  Audio: DefaultLayoutIcon;
  AudioBoostUp: DefaultLayoutIcon;
  AudioBoostDown: DefaultLayoutIcon;
  Chapters: DefaultLayoutIcon;
  Captions: DefaultLayoutIcon;
  Playback: DefaultLayoutIcon;
  Settings: DefaultLayoutIcon;
  SpeedUp: DefaultLayoutIcon;
  SpeedDown: DefaultLayoutIcon;
  QualityUp: DefaultLayoutIcon;
  QualityDown: DefaultLayoutIcon;
  FontSizeUp: DefaultLayoutIcon;
  FontSizeDown: DefaultLayoutIcon;
  OpacityUp: DefaultLayoutIcon;
  OpacityDown: DefaultLayoutIcon;
  RadioCheck: DefaultLayoutIcon;
}

export interface DefaultKeyboardDisplayIcons {
  Play: DefaultLayoutIcon;
  Pause: DefaultLayoutIcon;
  Mute: DefaultLayoutIcon;
  VolumeUp: DefaultLayoutIcon;
  VolumeDown: DefaultLayoutIcon;
  EnterFullscreen: DefaultLayoutIcon;
  ExitFullscreen: DefaultLayoutIcon;
  EnterPiP: DefaultLayoutIcon;
  ExitPiP: DefaultLayoutIcon;
  CaptionsOn: DefaultLayoutIcon;
  CaptionsOff: DefaultLayoutIcon;
  SeekForward: DefaultLayoutIcon;
  SeekBackward: DefaultLayoutIcon;
}

export interface DefaultLayoutIcons {
  AirPlayButton: DefaultAirPlayButtonIcons;
  GoogleCastButton: DefaultGoogleCastButtonIcons;
  PlayButton: DefaultPlayButtonIcons;
  MuteButton: DefaultMuteButtonIcons;
  CaptionButton: DefaultCaptionButtonIcons;
  PIPButton: DefaultPIPButtonIcons;
  FullscreenButton: DefaultFullscreenButtonIcons;
  SeekButton: DefaultSeekButtonIcons;
  DownloadButton?: DefaultDownloadButtonIcons;
  Menu: DefaultMenuIcons;
  KeyboardDisplay?: Partial<DefaultKeyboardDisplayIcons>;
}
</file>

<file path="components/layouts/default/index.ts">
export type {
  DefaultLayoutSlots,
  DefaultAudioLayoutSlots,
  DefaultVideoLayoutSlots,
  DefaultLayoutSlotName,
  DefaultLayoutMenuSlotName,
} from './slots';
export type { DefaultLayoutTranslations, DefaultLayoutWord } from 'vidstack';
export type { DefaultLayoutProps } from './media-layout';
export * from './context';
export * from './ui';
</file>

<file path="components/layouts/default/media-layout.tsx">
import * as React from 'react';

import { composeRefs, useSignal } from 'maverick.js/react';
import { isBoolean } from 'maverick.js/std';
import {
  type DefaultLayoutTranslations,
  type FileDownloadInfo,
  type MediaPlayerQuery,
  type MediaStreamType,
  type ThumbnailSrc,
} from 'vidstack';

import { useMediaContext } from '../../../hooks/use-media-context';
import { useMediaState } from '../../../hooks/use-media-state';
import { createComputed, createSignal } from '../../../hooks/use-signals';
import type { PrimitivePropsWithRef } from '../../primitives/nodes';
import { DefaultLayoutContext } from './context';
import { useColorSchemeClass } from './hooks';
import type { DefaultLayoutIcons } from './icons';

/* -------------------------------------------------------------------------------------------------
 * DefaultMediaLayout
 * -----------------------------------------------------------------------------------------------*/

export interface DefaultLayoutProps<Slots = unknown> extends PrimitivePropsWithRef<'div'> {
  children?: React.ReactNode;
  /**
   * The icons to be rendered and displayed inside the layout.
   */
  icons: DefaultLayoutIcons;
  /**
   * Whether light or dark color theme should be active. Defaults to user operating system
   * preference.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme}
   */
  colorScheme?: 'light' | 'dark' | 'system' | 'default';
  /**
   * Sets the download URL and filename for the download button.
   */
  download?: FileDownloadInfo;
  /**
   * Specifies the number of milliseconds to wait before tooltips are visible after interacting
   * with a control.
   *
   * @defaultValue 700
   */
  showTooltipDelay?: number;
  /**
   * Specifies the number of milliseconds to wait before menus are visible after opening them.
   *
   * @defaultValue 0
   */
  showMenuDelay?: number;
  /**
   * Whether the bitrate should be hidden in the settings quality menu next to each option.
   *
   * @defaultValue false
   */
  hideQualityBitrate?: boolean;
  /**
   * Determines when the small (e.g., mobile) UI should be displayed.
   *
   * @defaultValue `({ width, height }) => width < 576 || height < 380`
   */
  smallLayoutWhen?: boolean | MediaPlayerQuery;
  /**
   * The thumbnails resource.
   *
   * @see {@link https://www.vidstack.io/docs/wc/player/core-concepts/loading#thumbnails}
   */
  thumbnails?: ThumbnailSrc;
  /**
   * Translation map from english to your desired language for words used throughout the layout.
   */
  translations?: Partial<DefaultLayoutTranslations> | null;
  /**
   * A document query selector string or `HTMLElement` to mount menus inside.
   *
   * @defaultValue `document.body`
   */
  menuContainer?: string | HTMLElement | null;
  /**
   * Specifies whether menu buttons should be placed in the top or bottom controls group. This
   * only applies to the large video layout.
   */
  menuGroup?: 'top' | 'bottom';
  /**
   * Disable audio boost slider in the settings menu.
   */
  noAudioGain?: boolean;
  /**
   * The audio gain options to be displayed in the settings menu.
   */
  audioGains?: number[] | { min: number; max: number; step: number };
  /**
   * Whether modal menus should be disabled when the small layout is active. A modal menu is
   * a floating panel that floats up from the bottom of the screen (outside of the player). It's
   * enabled by default as it provides a better user experience for touch devices.
   */
  noModal?: boolean;
  /**
   * Whether to disable scrubbing by touch swiping left or right on the player canvas.
   */
  noScrubGesture?: boolean;
  /**
   * The minimum width of the slider to start displaying slider chapters when available.
   */
  sliderChaptersMinWidth?: number;
  /**
   * Whether the time slider should be disabled.
   */
  disableTimeSlider?: boolean;
  /**
   * Whether all gestures such as press to play or seek should not be active.
   */
  noGestures?: boolean;
  /**
   * Whether keyboard actions should not be displayed.
   */
  noKeyboardAnimations?: boolean;
  /**
   * The playback rate options to be displayed in the settings menu.
   */
  playbackRates?: number[] | { min: number; max: number; step: number };
  /**
   * The number of seconds to seek forward or backward when pressing the seek button or using
   * keyboard shortcuts.
   */
  seekStep?: number;
  /**
   * Provide additional content to be inserted in specific positions.
   */
  slots?: Slots;
}

export interface CreateDefaultMediaLayout {
  type: 'audio' | 'video';
  smLayoutWhen: MediaPlayerQuery;
  renderLayout: (props: {
    streamType: MediaStreamType;
    isLoadLayout: boolean;
    isSmallLayout: boolean;
  }) => React.ReactNode;
}

export function createDefaultMediaLayout({
  type,
  smLayoutWhen,
  renderLayout,
}: CreateDefaultMediaLayout) {
  const Layout = React.forwardRef<HTMLDivElement, DefaultLayoutProps>(
    (
      {
        children,
        className,
        disableTimeSlider = false,
        hideQualityBitrate = false,
        icons,
        colorScheme = 'system',
        download = null,
        menuContainer = null,
        menuGroup = 'bottom',
        noAudioGain = false,
        audioGains = { min: 0, max: 300, step: 25 },
        noGestures = false,
        noKeyboardAnimations = false,
        noModal = false,
        noScrubGesture,
        playbackRates = { min: 0, max: 2, step: 0.25 },
        seekStep = 10,
        showMenuDelay,
        showTooltipDelay = 700,
        sliderChaptersMinWidth = 325,
        slots,
        smallLayoutWhen = smLayoutWhen,
        thumbnails = null,
        translations,
        ...props
      },
      forwardRef,
    ) => {
      const media = useMediaContext(),
        $load = useSignal(media.$props.load),
        $canLoad = useMediaState('canLoad'),
        $viewType = useMediaState('viewType'),
        $streamType = useMediaState('streamType'),
        $smallWhen = createComputed(() => {
          return isBoolean(smallLayoutWhen) ? smallLayoutWhen : smallLayoutWhen(media.player.state);
        }, [smallLayoutWhen]),
        userPrefersAnnouncements = createSignal(true),
        userPrefersKeyboardAnimations = createSignal(true),
        isMatch = $viewType === type,
        isSmallLayout = $smallWhen(),
        isForcedLayout = isBoolean(smallLayoutWhen),
        isLoadLayout = $load === 'play' && !$canLoad,
        canRender = $canLoad || isForcedLayout || isLoadLayout,
        colorSchemeClass = useColorSchemeClass(colorScheme),
        layoutEl = createSignal<HTMLElement | null>(null);

      useSignal($smallWhen);

      return (
        <div
          {...props}
          className={
            `vds-${type}-layout` +
            (colorSchemeClass ? ` ${colorSchemeClass}` : '') +
            (className ? ` ${className}` : '')
          }
          data-match={isMatch ? '' : null}
          data-sm={isSmallLayout ? '' : null}
          data-lg={!isSmallLayout ? '' : null}
          data-size={isSmallLayout ? 'sm' : 'lg'}
          data-no-scrub-gesture={noScrubGesture ? '' : null}
          ref={composeRefs(layoutEl.set as any, forwardRef)}
        >
          {canRender && isMatch ? (
            <DefaultLayoutContext.Provider
              value={{
                disableTimeSlider,
                hideQualityBitrate,
                icons: icons,
                colorScheme,
                download,
                isSmallLayout,
                menuContainer,
                menuGroup,
                noAudioGain,
                audioGains,
                layoutEl,
                noGestures,
                noKeyboardAnimations,
                noModal,
                noScrubGesture,
                showMenuDelay,
                showTooltipDelay,
                sliderChaptersMinWidth,
                slots,
                seekStep,
                playbackRates,
                thumbnails,
                translations,
                userPrefersAnnouncements,
                userPrefersKeyboardAnimations,
              }}
            >
              {renderLayout({ streamType: $streamType, isSmallLayout, isLoadLayout })}
              {children}
            </DefaultLayoutContext.Provider>
          ) : null}
        </div>
      );
    },
  );

  Layout.displayName = 'DefaultMediaLayout';
  return Layout;
}
</file>

<file path="components/layouts/default/slots.tsx">
import * as React from 'react';

import { isUndefined, uppercaseFirstChar } from 'maverick.js/std';

import { DefaultLayoutContext } from './context';

export type SlotPositions<Name extends string> =
  | `before${Capitalize<Name>}`
  | Name
  | `after${Capitalize<Name>}`;

export type Slots<Names extends string> = {
  [slotName in SlotPositions<Names>]?: React.ReactNode;
};

export type DefaultLayoutSlotName =
  | 'bufferingIndicator'
  | 'captionButton'
  | 'captions'
  | 'title'
  | 'chapterTitle'
  | 'currentTime'
  | 'endTime'
  | 'fullscreenButton'
  | 'liveButton'
  | 'livePlayButton'
  | 'muteButton'
  | 'pipButton'
  | 'airPlayButton'
  | 'googleCastButton'
  | 'downloadButton'
  | 'playButton'
  | 'loadButton'
  | 'seekBackwardButton'
  | 'seekForwardButton'
  | 'startDuration'
  | 'timeSlider'
  | 'volumeSlider'
  | 'topControlsGroupStart'
  | 'topControlsGroupCenter'
  | 'topControlsGroupEnd'
  | 'centerControlsGroupStart'
  | 'centerControlsGroupCenter'
  | 'centerControlsGroupEnd'
  | DefaultLayoutMenuSlotName;

export type DefaultLayoutMenuSlotName =
  | 'chaptersMenu'
  | 'settingsMenu'
  /** @deprecated - use `settingsMenuItemsStart` */
  | 'settingsMenuStartItems'
  /** @deprecated - use `settingsMenuItemsEnd` */
  | 'settingsMenuEndItems'
  | 'settingsMenuItemsStart'
  | 'settingsMenuItemsEnd'
  | 'playbackMenuItemsStart'
  | 'playbackMenuItemsEnd'
  | 'playbackMenuLoop'
  | 'accessibilityMenuItemsStart'
  | 'accessibilityMenuItemsEnd'
  | 'audioMenuItemsStart'
  | 'audioMenuItemsEnd'
  | 'captionsMenuItemsStart'
  | 'captionsMenuItemsEnd';

export interface DefaultLayoutSlots extends Slots<DefaultLayoutSlotName> {}

export interface DefaultAudioLayoutSlots extends DefaultLayoutSlots {}

export interface DefaultVideoLayoutSlots extends DefaultLayoutSlots {
  smallLayout?: DefaultLayoutSlots;
  largeLayout?: DefaultLayoutSlots;
}

export function useDefaultAudioLayoutSlots() {
  return React.useContext(DefaultLayoutContext).slots as DefaultAudioLayoutSlots | undefined;
}

export function useDefaultVideoLayoutSlots() {
  return React.useContext(DefaultLayoutContext).slots as DefaultVideoLayoutSlots | undefined;
}

export function slot<T>(
  slots: T | undefined,
  name: keyof T,
  defaultValue: React.ReactNode,
): React.ReactNode {
  const slot = slots?.[name],
    capitalizedName = uppercaseFirstChar(name as string);
  return (
    <>
      {slots?.[`before${capitalizedName}`]}
      {isUndefined(slot) ? defaultValue : slot}
      {slots?.[`after${capitalizedName}`]}
    </>
  );
}
</file>

<file path="components/layouts/default/ui.ts">
export * from './audio-layout';
export * from './video-layout';
export * from './ui/menus/items/menu-checkbox';
export * from './ui/menus/items/menu-items';
export * from './ui/menus/items/menu-slider';
export * from './ui/tooltip';
export * from './icons';
export { DefaultKeyboardDisplay, type DefaultKeyboardDisplayProps } from './ui/keyboard-display';
</file>

<file path="components/layouts/default/ui/announcer.tsx">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';

import { MediaAnnouncer } from '../../../announcer';
import { useDefaultLayoutContext } from '../context';

/* -------------------------------------------------------------------------------------------------
 * DefaultAnnouncer
 * -----------------------------------------------------------------------------------------------*/

function DefaultAnnouncer() {
  const { userPrefersAnnouncements, translations } = useDefaultLayoutContext(),
    $userPrefersAnnouncements = useSignal(userPrefersAnnouncements);

  if (!$userPrefersAnnouncements) return null;

  return <MediaAnnouncer translations={translations} />;
}

DefaultAnnouncer.displayName = 'DefaultAnnouncer';
export { DefaultAnnouncer };
</file>

<file path="components/layouts/default/ui/buttons.tsx">
import * as React from 'react';

import { isString, uppercaseFirstChar } from 'maverick.js/std';
import { getDownloadFile, isTrackCaptionKind } from 'vidstack';

import { useMediaState } from '../../../../hooks/use-media-state';
import { appendParamsToURL } from '../../../../utils';
import { AirPlayButton } from '../../../ui/buttons/airplay-button';
import { CaptionButton } from '../../../ui/buttons/caption-button';
import { FullscreenButton } from '../../../ui/buttons/fullscreen-button';
import { GoogleCastButton } from '../../../ui/buttons/google-cast-button';
import { LiveButton } from '../../../ui/buttons/live-button';
import { MuteButton } from '../../../ui/buttons/mute-button';
import { PIPButton } from '../../../ui/buttons/pip-button';
import { PlayButton } from '../../../ui/buttons/play-button';
import { SeekButton } from '../../../ui/buttons/seek-button';
import * as Tooltip from '../../../ui/tooltip';
import { useDefaultLayoutContext, useDefaultLayoutWord } from '../context';
import { DefaultTooltip } from './tooltip';

/* -------------------------------------------------------------------------------------------------
 * Types
 * -----------------------------------------------------------------------------------------------*/

interface DefaultMediaButtonProps {
  tooltip: Tooltip.ContentProps['placement'];
}

/* -------------------------------------------------------------------------------------------------
 * DefaultPlayButton
 * -----------------------------------------------------------------------------------------------*/

function DefaultPlayButton({ tooltip }: DefaultMediaButtonProps) {
  const { icons: Icons } = useDefaultLayoutContext(),
    playText = useDefaultLayoutWord('Play'),
    pauseText = useDefaultLayoutWord('Pause'),
    $paused = useMediaState('paused'),
    $ended = useMediaState('ended');
  return (
    <DefaultTooltip content={$paused ? playText : pauseText} placement={tooltip}>
      <PlayButton className="vds-play-button vds-button" aria-label={playText}>
        {$ended ? (
          <Icons.PlayButton.Replay className="vds-icon" />
        ) : $paused ? (
          <Icons.PlayButton.Play className="vds-icon" />
        ) : (
          <Icons.PlayButton.Pause className="vds-icon" />
        )}
      </PlayButton>
    </DefaultTooltip>
  );
}

DefaultPlayButton.displayName = 'DefaultPlayButton';
export { DefaultPlayButton };

/* -------------------------------------------------------------------------------------------------
 * DefaultMuteButton
 * -----------------------------------------------------------------------------------------------*/

const DefaultMuteButton = React.forwardRef<HTMLButtonElement, DefaultMediaButtonProps>(
  ({ tooltip }, forwardRef) => {
    const { icons: Icons } = useDefaultLayoutContext(),
      muteText = useDefaultLayoutWord('Mute'),
      unmuteText = useDefaultLayoutWord('Unmute'),
      $muted = useMediaState('muted'),
      $volume = useMediaState('volume');
    return (
      <DefaultTooltip content={$muted ? unmuteText : muteText} placement={tooltip}>
        <MuteButton className="vds-mute-button vds-button" aria-label={muteText} ref={forwardRef}>
          {$muted || $volume == 0 ? (
            <Icons.MuteButton.Mute className="vds-icon" />
          ) : $volume < 0.5 ? (
            <Icons.MuteButton.VolumeLow className="vds-icon" />
          ) : (
            <Icons.MuteButton.VolumeHigh className="vds-icon" />
          )}
        </MuteButton>
      </DefaultTooltip>
    );
  },
);

DefaultMuteButton.displayName = 'DefaultMuteButton';
export { DefaultMuteButton };

/* -------------------------------------------------------------------------------------------------
 * DefaultCaptionButton
 * -----------------------------------------------------------------------------------------------*/

function DefaultCaptionButton({ tooltip }: DefaultMediaButtonProps) {
  const { icons: Icons } = useDefaultLayoutContext(),
    captionsText = useDefaultLayoutWord('Captions'),
    onText = useDefaultLayoutWord('Closed-Captions On'),
    offText = useDefaultLayoutWord('Closed-Captions Off'),
    $track = useMediaState('textTrack'),
    isOn = $track && isTrackCaptionKind($track);
  return (
    <DefaultTooltip content={isOn ? onText : offText} placement={tooltip}>
      <CaptionButton className="vds-caption-button vds-button" aria-label={captionsText}>
        {isOn ? (
          <Icons.CaptionButton.On className="vds-icon" />
        ) : (
          <Icons.CaptionButton.Off className="vds-icon" />
        )}
      </CaptionButton>
    </DefaultTooltip>
  );
}

DefaultCaptionButton.displayName = 'DefaultCaptionButton';
export { DefaultCaptionButton };

/* -------------------------------------------------------------------------------------------------
 * DefaultPIPButton
 * -----------------------------------------------------------------------------------------------*/

function DefaultPIPButton({ tooltip }: DefaultMediaButtonProps) {
  const { icons: Icons } = useDefaultLayoutContext(),
    pipText = useDefaultLayoutWord('PiP'),
    enterText = useDefaultLayoutWord('Enter PiP'),
    exitText = useDefaultLayoutWord('Exit PiP'),
    $pip = useMediaState('pictureInPicture');
  return (
    <DefaultTooltip content={$pip ? exitText : enterText} placement={tooltip}>
      <PIPButton className="vds-pip-button vds-button" aria-label={pipText}>
        {$pip ? (
          <Icons.PIPButton.Exit className="vds-icon" />
        ) : (
          <Icons.PIPButton.Enter className="vds-icon" />
        )}
      </PIPButton>
    </DefaultTooltip>
  );
}

DefaultPIPButton.displayName = 'DefaultPIPButton';
export { DefaultPIPButton };

/* -------------------------------------------------------------------------------------------------
 * DefaultFullscreenButton
 * -----------------------------------------------------------------------------------------------*/

function DefaultFullscreenButton({ tooltip }: DefaultMediaButtonProps) {
  const { icons: Icons } = useDefaultLayoutContext(),
    fullscreenText = useDefaultLayoutWord('Fullscreen'),
    enterText = useDefaultLayoutWord('Enter Fullscreen'),
    exitText = useDefaultLayoutWord('Exit Fullscreen'),
    $fullscreen = useMediaState('fullscreen');
  return (
    <DefaultTooltip content={$fullscreen ? exitText : enterText} placement={tooltip}>
      <FullscreenButton className="vds-fullscreen-button vds-button" aria-label={fullscreenText}>
        {$fullscreen ? (
          <Icons.FullscreenButton.Exit className="vds-icon" />
        ) : (
          <Icons.FullscreenButton.Enter className="vds-icon" />
        )}
      </FullscreenButton>
    </DefaultTooltip>
  );
}

DefaultFullscreenButton.displayName = 'DefaultFullscreenButton';
export { DefaultFullscreenButton };

/* -------------------------------------------------------------------------------------------------
 * DefaultSeekButton
 * -----------------------------------------------------------------------------------------------*/

function DefaultSeekButton({
  backward,
  tooltip,
}: DefaultMediaButtonProps & { backward?: boolean }) {
  const { icons: Icons, seekStep } = useDefaultLayoutContext(),
    seekForwardText = useDefaultLayoutWord('Seek Forward'),
    seekBackwardText = useDefaultLayoutWord('Seek Backward'),
    seconds = (backward ? -1 : 1) * seekStep!,
    label = seconds >= 0 ? seekForwardText : seekBackwardText;
  return (
    <DefaultTooltip content={label} placement={tooltip}>
      <SeekButton className="vds-seek-button vds-button" seconds={seconds} aria-label={label}>
        {seconds >= 0 ? (
          <Icons.SeekButton.Forward className="vds-icon" />
        ) : (
          <Icons.SeekButton.Backward className="vds-icon" />
        )}
      </SeekButton>
    </DefaultTooltip>
  );
}

DefaultSeekButton.displayName = 'DefaultSeekButton';
export { DefaultSeekButton };

/* -------------------------------------------------------------------------------------------------
 * DefaultAirPlayButton
 * -----------------------------------------------------------------------------------------------*/

function DefaultAirPlayButton({ tooltip }: DefaultMediaButtonProps) {
  const { icons: Icons } = useDefaultLayoutContext(),
    airPlayText = useDefaultLayoutWord('AirPlay'),
    $state = useMediaState('remotePlaybackState'),
    stateText = useDefaultLayoutWord(uppercaseFirstChar($state) as Capitalize<RemotePlaybackState>),
    label = `${airPlayText} ${stateText}`,
    Icon =
      ($state === 'connecting'
        ? Icons.AirPlayButton.Connecting
        : $state === 'connected'
          ? Icons.AirPlayButton.Connected
          : null) ?? Icons.AirPlayButton.Default;
  return (
    <DefaultTooltip content={airPlayText} placement={tooltip}>
      <AirPlayButton className="vds-airplay-button vds-button" aria-label={label}>
        <Icon className="vds-icon" />
      </AirPlayButton>
    </DefaultTooltip>
  );
}

DefaultAirPlayButton.displayName = 'DefaultAirPlayButton';
export { DefaultAirPlayButton };

/* -------------------------------------------------------------------------------------------------
 * DefaultGoogleCastButton
 * -----------------------------------------------------------------------------------------------*/

function DefaultGoogleCastButton({ tooltip }: DefaultMediaButtonProps) {
  const { icons: Icons } = useDefaultLayoutContext(),
    googleCastText = useDefaultLayoutWord('Google Cast'),
    $state = useMediaState('remotePlaybackState'),
    stateText = useDefaultLayoutWord(uppercaseFirstChar($state) as Capitalize<RemotePlaybackState>),
    label = `${googleCastText} ${stateText}`,
    Icon =
      ($state === 'connecting'
        ? Icons.GoogleCastButton.Connecting
        : $state === 'connected'
          ? Icons.GoogleCastButton.Connected
          : null) ?? Icons.GoogleCastButton.Default;
  return (
    <DefaultTooltip content={googleCastText} placement={tooltip}>
      <GoogleCastButton className="vds-google-cast-button vds-button" aria-label={label}>
        <Icon className="vds-icon" />
      </GoogleCastButton>
    </DefaultTooltip>
  );
}

DefaultGoogleCastButton.displayName = 'DefaultGoogleCastButton';
export { DefaultGoogleCastButton };

/* -------------------------------------------------------------------------------------------------
 * DefaultLiveButton
 * -----------------------------------------------------------------------------------------------*/

function DefaultLiveButton() {
  const $live = useMediaState('live'),
    label = useDefaultLayoutWord('Skip To Live'),
    liveText = useDefaultLayoutWord('LIVE');
  return $live ? (
    <LiveButton className="vds-live-button" aria-label={label}>
      <span className="vds-live-button-text">{liveText}</span>
    </LiveButton>
  ) : null;
}

DefaultLiveButton.displayName = 'DefaultLiveButton';
export { DefaultLiveButton };

/* -------------------------------------------------------------------------------------------------
 * DefaultDownloadButton
 * -----------------------------------------------------------------------------------------------*/

function DefaultDownloadButton() {
  const { download, icons: Icons } = useDefaultLayoutContext(),
    $src = useMediaState('source'),
    $title = useMediaState('title'),
    file = getDownloadFile({
      title: $title,
      src: $src,
      download,
    }),
    downloadText = useDefaultLayoutWord('Download');

  return isString(file?.url) ? (
    <DefaultTooltip content={downloadText} placement="top">
      <a
        role="button"
        className="vds-download-button vds-button"
        aria-label={downloadText}
        href={appendParamsToURL(file.url, { download: file.name })}
        download={file.name}
        target="_blank"
      >
        {Icons.DownloadButton ? <Icons.DownloadButton.Default className="vds-icon" /> : null}
      </a>
    </DefaultTooltip>
  ) : null;
}

DefaultDownloadButton.displayName = 'DefaultDownloadButton';
export { DefaultDownloadButton };
</file>

<file path="components/layouts/default/ui/captions.tsx">
import * as React from 'react';

import { Captions } from '../../../ui/captions';
import { useDefaultLayoutWord } from '../context';

/* -------------------------------------------------------------------------------------------------
 * DefaultCaptions
 * -----------------------------------------------------------------------------------------------*/

function DefaultCaptions() {
  const exampleText = useDefaultLayoutWord('Captions look like this');
  return <Captions className="vds-captions" exampleText={exampleText} />;
}

DefaultCaptions.displayName = 'DefaultCaptions';
export { DefaultCaptions };
</file>

<file path="components/layouts/default/ui/controls.tsx">
import * as React from 'react';

/* -------------------------------------------------------------------------------------------------
 * DefaultControlsSpacer
 * -----------------------------------------------------------------------------------------------*/

function DefaultControlsSpacer() {
  return <div className="vds-controls-spacer" />;
}

DefaultControlsSpacer.displayName = 'DefaultControlsSpacer';
export { DefaultControlsSpacer };
</file>

<file path="components/layouts/default/ui/keyboard-display.tsx">
import * as React from 'react';

import { useContext } from 'maverick.js';
import { useSignal } from 'maverick.js/react';
import { camelToKebabCase } from 'maverick.js/std';
import { mediaContext } from 'vidstack';

import { useMediaState } from '../../../../hooks/use-media-state';
import { createComputed, createEffect } from '../../../../hooks/use-signals';
import { Primitive, type PrimitivePropsWithRef } from '../../../primitives/nodes';
import type { DefaultKeyboardDisplayIcons } from '../icons';

export interface DefaultKeyboardDisplayProps
  extends Omit<PrimitivePropsWithRef<'div'>, 'disabled'> {
  icons: Partial<DefaultKeyboardDisplayIcons>;
}

const DefaultKeyboardDisplay = React.forwardRef<HTMLElement, DefaultKeyboardDisplayProps>(
  ({ icons: Icons, ...props }, forwardRef) => {
    const [visible, setVisible] = React.useState(false),
      [Icon, setIcon] = React.useState<any>(null),
      [count, setCount] = React.useState(0),
      $lastKeyboardAction = useMediaState('lastKeyboardAction');

    React.useEffect(() => {
      setCount((n) => n + 1);
    }, [$lastKeyboardAction]);

    const actionDataAttr = React.useMemo(() => {
      const action = $lastKeyboardAction?.action;
      return action && visible ? camelToKebabCase(action) : null;
    }, [visible, $lastKeyboardAction]);

    const className = React.useMemo(
      () =>
        `vds-kb-action${!visible ? ' hidden' : ''}${props.className ? ` ${props.className}` : ''}`,
      [visible],
    );

    const $$text = createComputed(getText),
      $text = useSignal($$text);

    createEffect(() => {
      const Icon = getIcon(Icons);
      setIcon(() => Icon);
    }, [Icons]);

    React.useEffect(() => {
      setVisible(!!$lastKeyboardAction);
      const id = setTimeout(() => setVisible(false), 500);
      return () => {
        setVisible(false);
        window.clearTimeout(id);
      };
    }, [$lastKeyboardAction]);

    return Icon ? (
      <Primitive.div
        {...props}
        className={className}
        data-action={actionDataAttr}
        ref={forwardRef as React.Ref<any>}
      >
        <div className="vds-kb-text-wrapper">
          <div className="vds-kb-text">{$text}</div>
        </div>
        <div className="vds-kb-bezel" key={count}>
          <div className="vds-kb-icon">
            <Icon />
          </div>
        </div>
      </Primitive.div>
    ) : null;
  },
);

DefaultKeyboardDisplay.displayName = 'DefaultKeyboardDisplay';
export { DefaultKeyboardDisplay };

function getText() {
  const { $state } = useContext(mediaContext),
    action = $state.lastKeyboardAction()?.action,
    audioGain = $state.audioGain() ?? 1;
  switch (action) {
    case 'toggleMuted':
      return $state.muted() ? '0%' : getVolumeText($state.volume(), audioGain);
    case 'volumeUp':
    case 'volumeDown':
      return getVolumeText($state.volume(), audioGain);
    default:
      return '';
  }
}

function getVolumeText(volume: number, gain: number) {
  return `${Math.round(volume * gain * 100)}%`;
}

function getIcon(Icons: Partial<DefaultKeyboardDisplayIcons>) {
  const { $state } = useContext(mediaContext),
    action = $state.lastKeyboardAction()?.action;
  switch (action) {
    case 'togglePaused':
      return !$state.paused() ? Icons.Play : Icons.Pause;
    case 'toggleMuted':
      return $state.muted() || $state.volume() === 0
        ? Icons.Mute
        : $state.volume() >= 0.5
          ? Icons.VolumeUp
          : Icons.VolumeDown;
    case 'toggleFullscreen':
      return $state.fullscreen() ? Icons.EnterFullscreen : Icons.ExitFullscreen;
    case 'togglePictureInPicture':
      return $state.pictureInPicture() ? Icons.EnterPiP : Icons.ExitPiP;
    case 'toggleCaptions':
      return $state.hasCaptions()
        ? $state.textTrack()
          ? Icons.CaptionsOn
          : Icons.CaptionsOff
        : null;
    case 'volumeUp':
      return Icons.VolumeUp;
    case 'volumeDown':
      return Icons.VolumeDown;
    case 'seekForward':
      return Icons.SeekForward;
    case 'seekBackward':
      return Icons.SeekBackward;
    default:
      return null;
  }
}
</file>

<file path="components/layouts/default/ui/menus/accessibility-menu.tsx">
import * as React from 'react';

import { useMediaState } from '../../../../../hooks/use-media-state';
import * as Menu from '../../../../ui/menu';
import { useDefaultLayoutContext, useDefaultLayoutWord } from '../../context';
import { slot, type DefaultLayoutMenuSlotName, type Slots } from '../../slots';
import { DefaultFontMenu } from './font-menu';
import { DefaultMenuCheckbox } from './items/menu-checkbox';
import { DefaultMenuButton, DefaultMenuItem, DefaultMenuSection } from './items/menu-items';

/* -------------------------------------------------------------------------------------------------
 * DefaultAccessibilityMenu
 * -----------------------------------------------------------------------------------------------*/

interface DefaultAccessibilityMenuProps {
  slots?: Slots<DefaultLayoutMenuSlotName>;
}

function DefaultAccessibilityMenu({ slots }: DefaultAccessibilityMenuProps) {
  const label = useDefaultLayoutWord('Accessibility'),
    { icons: Icons } = useDefaultLayoutContext();

  return (
    <Menu.Root className="vds-accessibility-menu vds-menu">
      <DefaultMenuButton label={label} Icon={Icons.Menu.Accessibility} />
      <Menu.Content className="vds-menu-items">
        {slot(slots, 'accessibilityMenuItemsStart', null)}

        <DefaultMenuSection>
          <DefaultAnnouncementsMenuCheckbox />
          <DefaultKeyboardAnimationsMenuCheckbox />
        </DefaultMenuSection>

        <DefaultMenuSection>
          <DefaultFontMenu />
        </DefaultMenuSection>

        {slot(slots, 'accessibilityMenuItemsEnd', null)}
      </Menu.Content>
    </Menu.Root>
  );
}

DefaultAccessibilityMenu.displayName = 'DefaultAccessibilityMenu';
export { DefaultAccessibilityMenu };

/* -------------------------------------------------------------------------------------------------
 * DefaultAnnouncementsMenuCheckbox
 * -----------------------------------------------------------------------------------------------*/

function DefaultAnnouncementsMenuCheckbox() {
  const { userPrefersAnnouncements } = useDefaultLayoutContext(),
    label = useDefaultLayoutWord('Announcements');

  function onChange(checked: boolean) {
    userPrefersAnnouncements.set(checked);
  }

  return (
    <DefaultMenuItem label={label}>
      <DefaultMenuCheckbox
        label={label}
        defaultChecked
        storageKey="vds-player::announcements"
        onChange={onChange}
      />
    </DefaultMenuItem>
  );
}

DefaultAnnouncementsMenuCheckbox.displayName = 'DefaultAnnouncementsMenuCheckbox';

/* -------------------------------------------------------------------------------------------------
 * DefaultKeyboardAnimationsMenuCheckbox
 * -----------------------------------------------------------------------------------------------*/

function DefaultKeyboardAnimationsMenuCheckbox() {
  const $viewType = useMediaState('viewType'),
    { userPrefersKeyboardAnimations, noKeyboardAnimations } = useDefaultLayoutContext(),
    label = useDefaultLayoutWord('Keyboard Animations');

  if ($viewType !== 'video' || noKeyboardAnimations) return null;

  function onChange(checked: boolean) {
    userPrefersKeyboardAnimations.set(checked);
  }

  return (
    <DefaultMenuItem label={label}>
      <DefaultMenuCheckbox
        label={label}
        defaultChecked
        storageKey="vds-player::keyboard-animations"
        onChange={onChange}
      />
    </DefaultMenuItem>
  );
}

DefaultKeyboardAnimationsMenuCheckbox.displayName = 'DefaultKeyboardAnimationsMenuCheckbox';
</file>

<file path="components/layouts/default/ui/menus/audio-menu.tsx">
import * as React from 'react';

import { isArray } from 'maverick.js/std';

import { useAudioOptions } from '../../../../../hooks/options/use-audio-options';
import { useMediaState } from '../../../../../hooks/use-media-state';
import * as Menu from '../../../../ui/menu';
import * as AudioGainSlider from '../../../../ui/sliders/audio-gain-slider';
import { useDefaultLayoutContext, useDefaultLayoutWord } from '../../context';
import { slot, type DefaultLayoutMenuSlotName, type Slots } from '../../slots';
import { DefaultMenuButton, DefaultMenuSection } from './items/menu-items';
import { DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps } from './items/menu-slider';

/* -------------------------------------------------------------------------------------------------
 * DefaultAudioMenu
 * -----------------------------------------------------------------------------------------------*/

interface DefaultAudioMenuProps {
  slots?: Slots<DefaultLayoutMenuSlotName>;
}

function DefaultAudioMenu({ slots }: DefaultAudioMenuProps) {
  const label = useDefaultLayoutWord('Audio'),
    $canSetAudioGain = useMediaState('canSetAudioGain'),
    $audioTracks = useMediaState('audioTracks'),
    { noAudioGain, icons: Icons } = useDefaultLayoutContext(),
    hasGainSlider = $canSetAudioGain && !noAudioGain,
    $disabled = !hasGainSlider && $audioTracks.length <= 1;

  if ($disabled) return null;

  return (
    <Menu.Root className="vds-audio-menu vds-menu">
      <DefaultMenuButton label={label} Icon={Icons.Menu.Audio} />
      <Menu.Content className="vds-menu-items">
        {slot(slots, 'audioMenuItemsStart', null)}
        <DefaultAudioTracksMenu />
        {hasGainSlider ? <DefaultAudioBoostMenuSection /> : null}
        {slot(slots, 'audioMenuItemsEnd', null)}
      </Menu.Content>
    </Menu.Root>
  );
}

DefaultAudioMenu.displayName = 'DefaultAudioMenu';
export { DefaultAudioMenu };

/* -------------------------------------------------------------------------------------------------
 * DefaultAudioBoostSection
 * -----------------------------------------------------------------------------------------------*/

function DefaultAudioBoostMenuSection() {
  const $audioGain = useMediaState('audioGain'),
    label = useDefaultLayoutWord('Boost'),
    value = Math.round((($audioGain ?? 1) - 1) * 100) + '%',
    $canSetAudioGain = useMediaState('canSetAudioGain'),
    { noAudioGain, icons: Icons } = useDefaultLayoutContext(),
    $disabled = !$canSetAudioGain || noAudioGain,
    min = useGainMin(),
    max = useGainMax();

  if ($disabled) return null;

  return (
    <DefaultMenuSection label={label} value={value}>
      <DefaultMenuSliderItem
        UpIcon={Icons.Menu.AudioBoostUp}
        DownIcon={Icons.Menu.AudioBoostDown}
        isMin={(($audioGain ?? 1) - 1) * 100 <= min}
        isMax={(($audioGain ?? 1) - 1) * 100 === max}
      >
        <DefaultAudioGainSlider />
      </DefaultMenuSliderItem>
    </DefaultMenuSection>
  );
}

DefaultAudioBoostMenuSection.displayName = 'DefaultAudioBoostMenuSection';

function useGainMin() {
  const { audioGains } = useDefaultLayoutContext(),
    min = isArray(audioGains) ? audioGains[0] : audioGains?.min;
  return min ?? 0;
}

function useGainMax() {
  const { audioGains } = useDefaultLayoutContext(),
    max = isArray(audioGains) ? audioGains[audioGains.length - 1] : audioGains?.max;
  return max ?? 300;
}

function useGainStep() {
  const { audioGains } = useDefaultLayoutContext(),
    step = isArray(audioGains) ? audioGains[1] - audioGains[0] : audioGains?.step;
  return step || 25;
}

/* -------------------------------------------------------------------------------------------------
 * DefaultAudioGainSlider
 * -----------------------------------------------------------------------------------------------*/

function DefaultAudioGainSlider() {
  const label = useDefaultLayoutWord('Audio Boost'),
    min = useGainMin(),
    max = useGainMax(),
    step = useGainStep();
  return (
    <AudioGainSlider.Root
      className="vds-audio-gain-slider vds-slider"
      aria-label={label}
      min={min}
      max={max}
      step={step}
      keyStep={step}
    >
      <DefaultSliderParts />
      <DefaultSliderSteps />
    </AudioGainSlider.Root>
  );
}

DefaultAudioGainSlider.displayName = 'DefaultAudioGainSlider';

/* -------------------------------------------------------------------------------------------------
 * DefaultAudioTracksMenu
 * -----------------------------------------------------------------------------------------------*/

function DefaultAudioTracksMenu() {
  const { icons: Icons } = useDefaultLayoutContext(),
    label = useDefaultLayoutWord('Track'),
    defaultText = useDefaultLayoutWord('Default'),
    $track = useMediaState('audioTrack'),
    options = useAudioOptions();

  if (options.disabled) return null;

  return (
    <Menu.Root className="vds-audio-track-menu vds-menu">
      <DefaultMenuButton
        label={label}
        hint={$track?.label ?? defaultText}
        disabled={options.disabled}
        Icon={Icons.Menu.Audio}
      />
      <Menu.Content className="vds-menu-items">
        <Menu.RadioGroup
          className="vds-audio-radio-group vds-radio-group"
          value={options.selectedValue}
        >
          {options.map(({ label, value, select }) => (
            <Menu.Radio
              className="vds-audio-radio vds-radio"
              value={value}
              onSelect={select}
              key={value}
            >
              <Icons.Menu.RadioCheck className="vds-icon" />
              <span className="vds-radio-label">{label}</span>
            </Menu.Radio>
          ))}
        </Menu.RadioGroup>
      </Menu.Content>
    </Menu.Root>
  );
}

DefaultAudioTracksMenu.displayName = 'DefaultAudioTracksMenu';
</file>

<file path="components/layouts/default/ui/menus/captions-menu.tsx">
import * as React from 'react';

import { useCaptionOptions } from '../../../../../hooks/options/use-caption-options';
import * as Menu from '../../../../ui/menu';
import { useDefaultLayoutContext, useDefaultLayoutWord } from '../../context';
import { slot, type DefaultLayoutMenuSlotName, type Slots } from '../../slots';
import { DefaultMenuButton } from './items/menu-items';

/* -------------------------------------------------------------------------------------------------
 * DefaultCaptionMenu
 * -----------------------------------------------------------------------------------------------*/

interface DefaultCaptionMenuProps {
  slots?: Slots<DefaultLayoutMenuSlotName>;
}

function DefaultCaptionMenu({ slots }: DefaultCaptionMenuProps) {
  const { icons: Icons } = useDefaultLayoutContext(),
    label = useDefaultLayoutWord('Captions'),
    offText = useDefaultLayoutWord('Off'),
    options = useCaptionOptions({ off: offText }),
    hint = options.selectedTrack?.label ?? offText;

  if (options.disabled) return null;

  return (
    <Menu.Root className="vds-captions-menu vds-menu">
      <DefaultMenuButton
        label={label}
        hint={hint}
        disabled={options.disabled}
        Icon={Icons.Menu.Captions}
      />
      <Menu.Content className="vds-menu-items">
        {slot(slots, 'captionsMenuItemsStart', null)}

        <Menu.RadioGroup
          className="vds-captions-radio-group vds-radio-group"
          value={options.selectedValue}
        >
          {options.map(({ label, value, select }) => (
            <Menu.Radio
              className="vds-caption-radio vds-radio"
              value={value}
              onSelect={select}
              key={value}
            >
              <Icons.Menu.RadioCheck className="vds-icon" />
              <span className="vds-radio-label">{label}</span>
            </Menu.Radio>
          ))}
        </Menu.RadioGroup>

        {slot(slots, 'captionsMenuItemsEnd', null)}
      </Menu.Content>
    </Menu.Root>
  );
}

DefaultCaptionMenu.displayName = 'DefaultCaptionMenu';
export { DefaultCaptionMenu };
</file>

<file path="components/layouts/default/ui/menus/chapters-menu.tsx">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';
import { flushSync } from 'react-dom';

import { useChapterOptions } from '../../../../../hooks/options/use-chapter-options';
import { useMediaState } from '../../../../../hooks/use-media-state';
import { isRemotionSrc } from '../../../../../providers/remotion/type-check';
import * as Menu from '../../../../ui/menu';
import * as Thumbnail from '../../../../ui/thumbnail';
import { RemotionThumbnail } from '../../../remotion-ui';
import { useDefaultLayoutContext, useDefaultLayoutWord } from '../../context';
import { useColorSchemeClass } from '../../hooks';
import { DefaultTooltip } from '../tooltip';
import type { DefaultMediaMenuProps } from './settings-menu';
import { useParentDialogEl } from './utils';

/* -------------------------------------------------------------------------------------------------
 * DefaultChaptersMenu
 * -----------------------------------------------------------------------------------------------*/

function DefaultChaptersMenu({ tooltip, placement, portalClass = '' }: DefaultMediaMenuProps) {
  const {
      showMenuDelay,
      noModal,
      isSmallLayout,
      icons: Icons,
      menuGroup,
      menuContainer,
      colorScheme,
    } = useDefaultLayoutContext(),
    chaptersText = useDefaultLayoutWord('Chapters'),
    options = useChapterOptions(),
    disabled = !options.length,
    { thumbnails } = useDefaultLayoutContext(),
    $src = useMediaState('currentSrc'),
    $viewType = useMediaState('viewType'),
    $offset = !isSmallLayout && menuGroup === 'bottom' && $viewType === 'video' ? 26 : 0,
    $RemotionThumbnail = useSignal(RemotionThumbnail),
    colorSchemeClass = useColorSchemeClass(colorScheme),
    [isOpen, setIsOpen] = React.useState(false),
    dialogEl = useParentDialogEl();

  if (disabled) return null;

  function onOpen() {
    flushSync(() => {
      setIsOpen(true);
    });
  }

  function onClose() {
    setIsOpen(false);
  }

  const Content = (
    <Menu.Content
      className="vds-chapters-menu-items vds-menu-items"
      placement={placement}
      offset={$offset}
    >
      {isOpen ? (
        <Menu.RadioGroup
          className="vds-chapters-radio-group vds-radio-group"
          value={options.selectedValue}
          data-thumbnails={thumbnails ? '' : null}
        >
          {options.map(
            ({ cue, label, value, startTimeText, durationText, select, setProgressVar }) => (
              <Menu.Radio
                className="vds-chapter-radio vds-radio"
                value={value}
                key={value}
                onSelect={select}
                ref={setProgressVar}
              >
                {thumbnails ? (
                  <Thumbnail.Root src={thumbnails} className="vds-thumbnail" time={cue.startTime}>
                    <Thumbnail.Img />
                  </Thumbnail.Root>
                ) : $RemotionThumbnail && isRemotionSrc($src) ? (
                  <$RemotionThumbnail className="vds-thumbnail" frame={cue.startTime * $src.fps!} />
                ) : null}
                <div className="vds-chapter-radio-content">
                  <span className="vds-chapter-radio-label">{label}</span>
                  <span className="vds-chapter-radio-start-time">{startTimeText}</span>
                  <span className="vds-chapter-radio-duration">{durationText}</span>
                </div>
              </Menu.Radio>
            ),
          )}
        </Menu.RadioGroup>
      ) : null}
    </Menu.Content>
  );

  return (
    <Menu.Root
      className="vds-chapters-menu vds-menu"
      showDelay={showMenuDelay}
      onOpen={onOpen}
      onClose={onClose}
    >
      <DefaultTooltip content={chaptersText} placement={tooltip}>
        <Menu.Button
          className="vds-menu-button vds-button"
          disabled={disabled}
          aria-label={chaptersText}
        >
          <Icons.Menu.Chapters className="vds-icon" />
        </Menu.Button>
      </DefaultTooltip>
      {noModal || !isSmallLayout ? (
        Content
      ) : (
        <Menu.Portal
          container={menuContainer ?? dialogEl}
          className={portalClass + (colorSchemeClass ? ` ${colorSchemeClass}` : '')}
          disabled="fullscreen"
          data-sm={isSmallLayout ? '' : null}
          data-lg={!isSmallLayout ? '' : null}
          data-size={isSmallLayout ? 'sm' : 'lg'}
        >
          {Content}
        </Menu.Portal>
      )}
    </Menu.Root>
  );
}

DefaultChaptersMenu.displayName = 'DefaultChaptersMenu';
export { DefaultChaptersMenu };
</file>

<file path="components/layouts/default/ui/menus/font-menu.tsx">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';
import { camelToKebabCase } from 'maverick.js/std';
import {
  FONT_COLOR_OPTION,
  FONT_FAMILY_OPTION,
  FONT_OPACITY_OPTION,
  FONT_SIGNALS,
  FONT_SIZE_OPTION,
  FONT_TEXT_SHADOW_OPTION,
  onFontReset,
  type DefaultFontSettingProps,
  type FontRadioOption,
  type FontSliderOption,
} from 'vidstack/exports/font.ts';

import { useMediaPlayer } from '../../../../../hooks/use-media-player';
import { useMediaState } from '../../../../../hooks/use-media-state';
import * as Menu from '../../../../ui/menu';
import * as Slider from '../../../../ui/sliders/slider';
import { i18n, useDefaultLayoutContext, useDefaultLayoutWord } from '../../context';
import type { DefaultLayoutIcon } from '../../icons';
import {
  createRadioOptions,
  DefaultMenuButton,
  DefaultMenuItem,
  DefaultMenuRadioGroup,
  DefaultMenuSection,
} from './items/menu-items';
import { DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps } from './items/menu-slider';

/* -------------------------------------------------------------------------------------------------
 * DefaultFontMenu
 * -----------------------------------------------------------------------------------------------*/

function DefaultFontMenu() {
  const label = useDefaultLayoutWord('Caption Styles'),
    $hasCaptions = useMediaState('hasCaptions'),
    fontSectionLabel = useDefaultLayoutWord('Font'),
    textSectionLabel = useDefaultLayoutWord('Text'),
    textBgSectionLabel = useDefaultLayoutWord('Text Background'),
    displayBgSectionLabel = useDefaultLayoutWord('Display Background');

  if (!$hasCaptions) return null;

  return (
    <Menu.Root className="vds-font-menu vds-menu">
      <DefaultMenuButton label={label} />
      <Menu.Content className="vds-font-style-items vds-menu-items">
        <DefaultMenuSection label={fontSectionLabel}>
          <DefaultFontFamilyMenu />
          <DefaultFontSizeSlider />
        </DefaultMenuSection>

        <DefaultMenuSection label={textSectionLabel}>
          <DefaultTextColorInput />
          <DefaultTextShadowMenu />
          <DefaultTextOpacitySlider />
        </DefaultMenuSection>

        <DefaultMenuSection label={textBgSectionLabel}>
          <DefaultTextBgInput />
          <DefaultTextBgOpacitySlider />
        </DefaultMenuSection>

        <DefaultMenuSection label={displayBgSectionLabel}>
          <DefaultDisplayBgInput />
          <DefaultDisplayBgOpacitySlider />
        </DefaultMenuSection>

        <DefaultMenuSection>
          <DefaultResetMenuItem />
        </DefaultMenuSection>
      </Menu.Content>
    </Menu.Root>
  );
}

DefaultFontMenu.displayName = 'DefaultFontMenu';
export { DefaultFontMenu };

/* -------------------------------------------------------------------------------------------------
 * DefaultFontFamilyMenu
 * -----------------------------------------------------------------------------------------------*/

function DefaultFontFamilyMenu() {
  return <DefaultFontSetting label="Family" type="fontFamily" option={FONT_FAMILY_OPTION} />;
}

DefaultFontFamilyMenu.displayName = 'DefaultFontFamilyMenu';

/* -------------------------------------------------------------------------------------------------
 * DefaultFontSizeSlider
 * -----------------------------------------------------------------------------------------------*/

function DefaultFontSizeSlider() {
  const { icons: Icons } = useDefaultLayoutContext(),
    option: FontSliderOption = {
      ...FONT_SIZE_OPTION,
      upIcon: Icons.Menu.FontSizeUp,
      downIcon: Icons.Menu.FontSizeDown,
    };

  return <DefaultFontSetting label="Size" type="fontSize" option={option} />;
}

DefaultFontSizeSlider.displayName = 'DefaultFontSizeSlider';

/* -------------------------------------------------------------------------------------------------
 * DefaultTextColoInput
 * -----------------------------------------------------------------------------------------------*/

function DefaultTextColorInput() {
  return <DefaultFontSetting label="Color" type="textColor" option={FONT_COLOR_OPTION} />;
}

DefaultTextColorInput.displayName = 'DefaultTextColorInput';

/* -------------------------------------------------------------------------------------------------
 * DefaultTextOpacitySlider
 * -----------------------------------------------------------------------------------------------*/

function DefaultTextOpacitySlider() {
  const { icons: Icons } = useDefaultLayoutContext(),
    option = {
      ...FONT_OPACITY_OPTION,
      upIcon: Icons.Menu.OpacityUp,
      downIcon: Icons.Menu.OpacityDown,
    };
  return <DefaultFontSetting label="Opacity" type="textOpacity" option={option} />;
}

DefaultTextOpacitySlider.displayName = 'DefaultTextOpacitySlider';

/* -------------------------------------------------------------------------------------------------
 * DefaultTextShadowMenu
 * -----------------------------------------------------------------------------------------------*/

function DefaultTextShadowMenu() {
  return <DefaultFontSetting label="Shadow" type="textShadow" option={FONT_TEXT_SHADOW_OPTION} />;
}

DefaultTextShadowMenu.displayName = 'DefaultTextShadowMenu';

/* -------------------------------------------------------------------------------------------------
 * DefaultTextBgInput
 * -----------------------------------------------------------------------------------------------*/

function DefaultTextBgInput() {
  return <DefaultFontSetting label="Color" type="textBg" option={FONT_COLOR_OPTION} />;
}

DefaultTextBgInput.displayName = 'DefaultTextBgInput';

/* -------------------------------------------------------------------------------------------------
 * DefaultTextBgOpacitySlider
 * -----------------------------------------------------------------------------------------------*/

function DefaultTextBgOpacitySlider() {
  const { icons: Icons } = useDefaultLayoutContext(),
    option = {
      ...FONT_OPACITY_OPTION,
      upIcon: Icons.Menu.OpacityUp,
      downIcon: Icons.Menu.OpacityDown,
    };

  return <DefaultFontSetting label="Opacity" type="textBgOpacity" option={option} />;
}

DefaultTextBgOpacitySlider.displayName = 'DefaultTextBgOpacitySlider';

/* -------------------------------------------------------------------------------------------------
 * DefaultDisplayBgInput
 * -----------------------------------------------------------------------------------------------*/

function DefaultDisplayBgInput() {
  return <DefaultFontSetting label="Color" type="displayBg" option={FONT_COLOR_OPTION} />;
}

DefaultDisplayBgInput.displayName = 'DefaultDisplayBgInput';

/* -------------------------------------------------------------------------------------------------
 * DefaultDisplayBgOpacitySlider
 * -----------------------------------------------------------------------------------------------*/

function DefaultDisplayBgOpacitySlider() {
  const { icons: Icons } = useDefaultLayoutContext(),
    option = {
      ...FONT_OPACITY_OPTION,
      upIcon: Icons.Menu.OpacityUp,
      downIcon: Icons.Menu.OpacityDown,
    };

  return <DefaultFontSetting label="Opacity" type="displayBgOpacity" option={option} />;
}

DefaultDisplayBgOpacitySlider.displayName = 'DefaultDisplayBgOpacitySlider';

/* -------------------------------------------------------------------------------------------------
 * DefaultFontSetting
 * -----------------------------------------------------------------------------------------------*/

function DefaultFontSetting({ label, option, type }: DefaultFontSettingProps) {
  const player = useMediaPlayer(),
    $currentValue = FONT_SIGNALS[type],
    $value = useSignal($currentValue),
    translatedLabel = useDefaultLayoutWord(label);

  const notify = React.useCallback(() => {
    player?.dispatchEvent(new Event('vds-font-change'));
  }, [player]);

  const onChange = React.useCallback(
    (newValue: string) => {
      $currentValue.set(newValue);
      notify();
    },
    [$currentValue, notify],
  );

  if (option.type === 'color') {
    function onColorChange(event) {
      onChange(event.target.value);
    }

    return (
      <DefaultMenuItem label={translatedLabel}>
        <input className="vds-color-picker" type="color" value={$value} onChange={onColorChange} />
      </DefaultMenuItem>
    );
  }

  if (option.type === 'slider') {
    const { min, max, step, upIcon, downIcon } = option;

    function onSliderValueChange(value) {
      onChange(value + '%');
    }

    return (
      <DefaultMenuSliderItem
        label={translatedLabel}
        value={$value}
        UpIcon={upIcon as DefaultLayoutIcon}
        DownIcon={downIcon as DefaultLayoutIcon}
        isMin={$value === min + '%'}
        isMax={$value === max + '%'}
      >
        <Slider.Root
          className="vds-slider"
          min={min}
          max={max}
          step={step}
          keyStep={step}
          value={parseInt($value)}
          aria-label={translatedLabel}
          onValueChange={onSliderValueChange}
          onDragValueChange={onSliderValueChange}
        >
          <DefaultSliderParts />
          <DefaultSliderSteps />
        </Slider.Root>
      </DefaultMenuSliderItem>
    );
  }

  if (option.type === 'radio') {
    return (
      <DefaultFontRadioGroup
        id={camelToKebabCase(type)}
        label={translatedLabel}
        value={$value}
        values={option.values}
        onChange={onChange}
      />
    );
  }

  return null;
}

DefaultFontSetting.displayName = 'DefaultFontSetting';

/* -------------------------------------------------------------------------------------------------
 * DefaultFontRadioGroup
 * -----------------------------------------------------------------------------------------------*/

interface DefaultFontRadioGroupProps {
  id: string;
  label: string;
  value: string;
  values: FontRadioOption['values'];
  onChange: (value: string) => void;
}

function DefaultFontRadioGroup({ id, label, value, values, onChange }: DefaultFontRadioGroupProps) {
  const radioOptions = createRadioOptions(values),
    { translations } = useDefaultLayoutContext(),
    hint = React.useMemo(() => {
      const label = radioOptions.find((radio) => radio.value === value)?.label || '';
      return i18n(translations, label);
    }, [value, radioOptions]);

  return (
    <Menu.Root className={`vds-${id}-menu vds-menu`}>
      <DefaultMenuButton label={label} hint={hint} />
      <Menu.Items className="vds-menu-items">
        <DefaultMenuRadioGroup value={value} options={radioOptions} onChange={onChange} />
      </Menu.Items>
    </Menu.Root>
  );
}

DefaultFontRadioGroup.displayName = 'DefaultFontRadioGroup';

/* -------------------------------------------------------------------------------------------------
 * DefaultResetMenuItem
 * -----------------------------------------------------------------------------------------------*/

function DefaultResetMenuItem() {
  const resetText = useDefaultLayoutWord('Reset');

  return (
    <button className="vds-menu-item" role="menuitem" onClick={onFontReset}>
      <span className="vds-menu-item-label">{resetText}</span>
    </button>
  );
}

DefaultResetMenuItem.displayName = 'DefaultResetMenuItem';
</file>

<file path="components/layouts/default/ui/menus/items/menu-checkbox.tsx">
import * as React from 'react';

import { isBoolean, isKeyboardClick } from 'maverick.js/std';

export interface DefaultMenuCheckboxProps {
  label: string;
  checked?: boolean;
  storageKey?: string;
  defaultChecked?: boolean;
  onChange?(checked: boolean, trigger?: Event): void;
}

function DefaultMenuCheckbox({
  label,
  checked,
  storageKey,
  defaultChecked = false,
  onChange,
}: DefaultMenuCheckboxProps) {
  const [isChecked, setIsChecked] = React.useState(defaultChecked),
    [isActive, setIsActive] = React.useState(false);

  React.useEffect(() => {
    const savedValue = storageKey ? localStorage.getItem(storageKey) : null,
      checked = !!(savedValue ?? defaultChecked);
    setIsChecked(checked);
    onChange?.(checked);
  }, []);

  React.useEffect(() => {
    if (isBoolean(checked)) setIsChecked(checked);
  }, [checked]);

  function onPress(event?: React.PointerEvent | React.KeyboardEvent) {
    if (event && 'button' in event && event?.button === 1) return;

    const toggledCheck = !isChecked;

    setIsChecked(toggledCheck);
    if (storageKey) localStorage.setItem(storageKey, toggledCheck ? '1' : '');

    onChange?.(toggledCheck, event?.nativeEvent);

    setIsActive(false);
  }

  function onActive(event: React.PointerEvent) {
    if (event.button !== 0) return;
    setIsActive(true);
  }

  function onKeyDown(event: React.KeyboardEvent) {
    if (isKeyboardClick(event.nativeEvent)) onPress();
  }

  return (
    <div
      className="vds-menu-checkbox"
      role="menuitemcheckbox"
      tabIndex={0}
      aria-label={label}
      aria-checked={isChecked ? 'true' : 'false'}
      data-active={isActive ? '' : null}
      onPointerUp={onPress}
      onPointerDown={onActive}
      onKeyDown={onKeyDown}
    />
  );
}

DefaultMenuCheckbox.displayName = 'DefaultMenuCheckbox';
export { DefaultMenuCheckbox };
</file>

<file path="components/layouts/default/ui/menus/items/menu-items.tsx">
import * as React from 'react';

import { isArray } from 'maverick.js/std';

import * as Menu from '../../../../../ui/menu';
import { DefaultLayoutContext, useDefaultLayoutContext } from '../../../context';
import type { DefaultLayoutIcon } from '../../../icons';

/* -------------------------------------------------------------------------------------------------
 * DefaultMenuSection
 * -----------------------------------------------------------------------------------------------*/

export interface DefaultMenuSectionProps {
  label?: string;
  value?: string;
  children: React.ReactNode;
}

function DefaultMenuSection({ label, value, children }: DefaultMenuSectionProps) {
  const id = React.useId();

  if (!label) {
    return (
      <div className="vds-menu-section">
        <div className="vds-menu-section-body">{children}</div>
      </div>
    );
  }

  return (
    <section className="vds-menu-section" role="group" aria-labelledby={id}>
      <div className="vds-menu-section-title">
        <header id={id}>{label}</header>
        {value ? <div className="vds-menu-section-value">{value}</div> : null}
      </div>
      <div className="vds-menu-section-body">{children}</div>
    </section>
  );
}

DefaultMenuSection.displayName = 'DefaultMenuSection';
export { DefaultMenuSection };

/* -------------------------------------------------------------------------------------------------
 * DefaultMenuButton
 * -----------------------------------------------------------------------------------------------*/

export interface DefaultMenuButtonProps {
  label: string;
  hint?: string;
  disabled?: boolean;
  Icon?: DefaultLayoutIcon;
}

function DefaultMenuButton({ label, hint = '', Icon, disabled = false }: DefaultMenuButtonProps) {
  const { icons: Icons } = React.useContext(DefaultLayoutContext);
  return (
    <Menu.Button className="vds-menu-item" disabled={disabled}>
      <Icons.Menu.ArrowLeft className="vds-menu-close-icon vds-icon" />
      {Icon ? <Icon className="vds-menu-item-icon vds-icon" /> : null}
      <span className="vds-menu-item-label">{label}</span>
      <span className="vds-menu-item-hint">{hint}</span>
      <Icons.Menu.ArrowRight className="vds-menu-open-icon vds-icon" />
    </Menu.Button>
  );
}

DefaultMenuButton.displayName = 'DefaultMenuButton';
export { DefaultMenuButton };

/* -------------------------------------------------------------------------------------------------
 * DefaultMenuItem
 * -----------------------------------------------------------------------------------------------*/

export interface DefaultMenuItemProps {
  label: string;
  children: React.ReactNode;
}

function DefaultMenuItem({ label, children }: DefaultMenuItemProps) {
  return (
    <div className="vds-menu-item">
      <div className="vds-menu-item-label">{label}</div>
      {children}
    </div>
  );
}

DefaultMenuItem.displayName = 'DefaultMenuItem';
export { DefaultMenuItem };

/* -------------------------------------------------------------------------------------------------
 * DefaultMenuRadioGroup
 * -----------------------------------------------------------------------------------------------*/

export interface DefaultMenuRadioGroupProps {
  value: string;
  options: { label: string; value: string }[];
  onChange?(newValue: string): void;
}

function DefaultMenuRadioGroup({ value, options, onChange }: DefaultMenuRadioGroupProps) {
  const { icons: Icons } = useDefaultLayoutContext();
  return (
    <Menu.RadioGroup className="vds-radio-group" value={value} onChange={onChange}>
      {options.map((option) => (
        <Menu.Radio className="vds-radio" value={option.value} key={option.value}>
          <Icons.Menu.RadioCheck className="vds-icon" />
          <span className="vds-radio-label" data-part="label">
            {option.label}
          </span>
        </Menu.Radio>
      ))}
    </Menu.RadioGroup>
  );
}

DefaultMenuRadioGroup.displayName = 'DefaultMenuRadioGroup';
export { DefaultMenuRadioGroup };

/* -------------------------------------------------------------------------------------------------
 * Utils
 * -----------------------------------------------------------------------------------------------*/

export function createRadioOptions(
  entries: string[] | Record<string, string>,
): { label: string; value: string }[] {
  return React.useMemo(
    () =>
      isArray(entries)
        ? entries.map((entry) => ({ label: entry, value: entry.toLowerCase() }))
        : Object.keys(entries).map((label) => ({ label, value: entries[label] })),
    [entries],
  );
}
</file>

<file path="components/layouts/default/ui/menus/items/menu-slider.tsx">
import * as React from 'react';

import * as Slider from '../../../../../ui/sliders/slider';
import type { DefaultLayoutIcon } from '../../../icons';

/* -------------------------------------------------------------------------------------------------
 * DefaultMenuSliderItem
 * -----------------------------------------------------------------------------------------------*/

export interface DefaultMenuSliderItemProps {
  label?: string;
  value?: string;
  UpIcon?: DefaultLayoutIcon;
  DownIcon?: DefaultLayoutIcon;
  children: React.ReactNode;
  isMin: boolean;
  isMax: boolean;
}

function DefaultMenuSliderItem({
  label,
  value,
  UpIcon,
  DownIcon,
  children,
  isMin,
  isMax,
}: DefaultMenuSliderItemProps) {
  const hasTitle = label || value,
    Content = (
      <>
        {DownIcon ? <DownIcon className="vds-icon down" /> : null}
        {children}
        {UpIcon ? <UpIcon className="vds-icon up" /> : null}
      </>
    );

  return (
    <div
      className={`vds-menu-item vds-menu-slider-item${hasTitle ? ' group' : ''}`}
      data-min={isMin ? '' : null}
      data-max={isMax ? '' : null}
    >
      {hasTitle ? (
        <>
          <div className="vds-menu-slider-title">
            {label ? <div>{label}</div> : null}
            {value ? <div>{value}</div> : null}
          </div>
          <div className="vds-menu-slider-body">{Content}</div>
        </>
      ) : (
        Content
      )}
    </div>
  );
}

DefaultMenuSliderItem.displayName = 'DefaultMenuSliderItem';
export { DefaultMenuSliderItem };

/* -------------------------------------------------------------------------------------------------
 * DefaultSliderParts
 * -----------------------------------------------------------------------------------------------*/

function DefaultSliderParts() {
  return (
    <>
      <Slider.Track className="vds-slider-track" />
      <Slider.TrackFill className="vds-slider-track-fill vds-slider-track" />
      <Slider.Thumb className="vds-slider-thumb" />
    </>
  );
}

DefaultSliderParts.displayName = 'DefaultSliderParts';
export { DefaultSliderParts };

/* -------------------------------------------------------------------------------------------------
 * DefaultSliderSteps
 * -----------------------------------------------------------------------------------------------*/

function DefaultSliderSteps() {
  return (
    <Slider.Steps className="vds-slider-steps">
      {(step) => <div className="vds-slider-step" key={String(step)} />}
    </Slider.Steps>
  );
}

DefaultSliderSteps.displayName = 'DefaultSliderSteps';
export { DefaultSliderSteps };
</file>

<file path="components/layouts/default/ui/menus/playback-menu.tsx">
import * as React from 'react';

import { isArray } from 'maverick.js/std';
import { sortVideoQualities } from 'vidstack';

import { useMediaContext } from '../../../../../hooks/use-media-context';
import { useMediaState } from '../../../../../hooks/use-media-state';
import * as Menu from '../../../../ui/menu';
import * as QualitySlider from '../../../../ui/sliders/quality-slider';
import * as SpeedSlider from '../../../../ui/sliders/speed-slider';
import { useDefaultLayoutContext, useDefaultLayoutWord } from '../../context';
import { slot, type DefaultLayoutMenuSlotName, type Slots } from '../../slots';
import { DefaultMenuCheckbox } from './items/menu-checkbox';
import { DefaultMenuButton, DefaultMenuItem, DefaultMenuSection } from './items/menu-items';
import { DefaultMenuSliderItem, DefaultSliderParts, DefaultSliderSteps } from './items/menu-slider';

/* -------------------------------------------------------------------------------------------------
 * DefaultPlaybackMenu
 * -----------------------------------------------------------------------------------------------*/

interface DefaultPlaybackMenuProps {
  slots?: Slots<DefaultLayoutMenuSlotName>;
}

function DefaultPlaybackMenu({ slots }: DefaultPlaybackMenuProps) {
  const label = useDefaultLayoutWord('Playback'),
    { icons: Icons } = useDefaultLayoutContext();

  return (
    <Menu.Root className="vds-playback-menu vds-menu">
      <DefaultMenuButton label={label} Icon={Icons.Menu.Playback} />
      <Menu.Content className="vds-menu-items">
        {slot(slots, 'playbackMenuItemsStart', null)}

        <DefaultMenuSection>
          {slot(slots, 'playbackMenuLoop', <DefaultLoopMenuCheckbox />)}
        </DefaultMenuSection>

        <DefaultSpeedMenuSection />

        <DefaultQualityMenuSection />

        {slot(slots, 'playbackMenuItemsEnd', null)}
      </Menu.Content>
    </Menu.Root>
  );
}

DefaultPlaybackMenu.displayName = 'DefaultPlaybackMenu';
export { DefaultPlaybackMenu };

/* -------------------------------------------------------------------------------------------------
 * DefaultLoopMenuCheckbox
 * -----------------------------------------------------------------------------------------------*/

function DefaultLoopMenuCheckbox() {
  const { remote } = useMediaContext(),
    label = useDefaultLayoutWord('Loop');

  function onChange(checked: boolean, trigger?: Event) {
    remote.userPrefersLoopChange(checked, trigger);
  }

  return (
    <DefaultMenuItem label={label}>
      <DefaultMenuCheckbox label={label} storageKey="vds-player::user-loop" onChange={onChange} />
    </DefaultMenuItem>
  );
}

DefaultLoopMenuCheckbox.displayName = 'DefaultLoopMenuCheckbox';

/* -------------------------------------------------------------------------------------------------
 * DefaultAutoQualityMenuCheckbox
 * -----------------------------------------------------------------------------------------------*/

function DefaultAutoQualityMenuCheckbox() {
  const { remote, qualities } = useMediaContext(),
    $autoQuality = useMediaState('autoQuality'),
    label = useDefaultLayoutWord('Auto');

  function onChange(checked: boolean, trigger?: Event) {
    if (checked) {
      remote.requestAutoQuality(trigger);
    } else {
      remote.changeQuality(qualities.selectedIndex, trigger);
    }
  }

  return (
    <DefaultMenuItem label={label}>
      <DefaultMenuCheckbox
        label={label}
        checked={$autoQuality}
        onChange={onChange}
        defaultChecked={$autoQuality}
      />
    </DefaultMenuItem>
  );
}

DefaultAutoQualityMenuCheckbox.displayName = 'DefaultAutoQualityMenuCheckbox';

/* -------------------------------------------------------------------------------------------------
 * DefaultQualityMenuSection
 * -----------------------------------------------------------------------------------------------*/

function DefaultQualityMenuSection() {
  const { hideQualityBitrate, icons: Icons } = useDefaultLayoutContext(),
    $canSetQuality = useMediaState('canSetQuality'),
    $qualities = useMediaState('qualities'),
    $quality = useMediaState('quality'),
    label = useDefaultLayoutWord('Quality'),
    autoText = useDefaultLayoutWord('Auto'),
    sortedQualities = React.useMemo(() => sortVideoQualities($qualities), [$qualities]);

  if (!$canSetQuality || $qualities.length <= 1) return null;

  const height = $quality?.height,
    bitrate = !hideQualityBitrate ? $quality?.bitrate : null,
    bitrateText = bitrate && bitrate > 0 ? `${(bitrate / 1000000).toFixed(2)} Mbps` : null,
    value = height ? `${height}p${bitrateText ? ` (${bitrateText})` : ''}` : autoText,
    isMin = sortedQualities[0] === $quality,
    isMax = sortedQualities.at(-1) === $quality;

  return (
    <DefaultMenuSection label={label} value={value}>
      <DefaultMenuSliderItem
        UpIcon={Icons.Menu.QualityUp}
        DownIcon={Icons.Menu.QualityDown}
        isMin={isMin}
        isMax={isMax}
      >
        <DefaultQualitySlider />
      </DefaultMenuSliderItem>
      <DefaultAutoQualityMenuCheckbox />
    </DefaultMenuSection>
  );
}

DefaultQualityMenuSection.displayName = 'DefaultQualityMenuSection';

/* -------------------------------------------------------------------------------------------------
 * DefaultQualitySlider
 * -----------------------------------------------------------------------------------------------*/

function DefaultQualitySlider() {
  const label = useDefaultLayoutWord('Quality');
  return (
    <QualitySlider.Root className="vds-quality-slider vds-slider" aria-label={label}>
      <DefaultSliderParts />
      <DefaultSliderSteps />
    </QualitySlider.Root>
  );
}

DefaultQualitySlider.displayName = 'DefaultQualitySlider';

/* -------------------------------------------------------------------------------------------------
 * DefaultSpeedMenuSection
 * -----------------------------------------------------------------------------------------------*/

function DefaultSpeedMenuSection() {
  const { icons: Icons } = useDefaultLayoutContext(),
    $playbackRate = useMediaState('playbackRate'),
    $canSetPlaybackRate = useMediaState('canSetPlaybackRate'),
    label = useDefaultLayoutWord('Speed'),
    normalText = useDefaultLayoutWord('Normal'),
    min = useSpeedMin(),
    max = useSpeedMax(),
    value = $playbackRate === 1 ? normalText : $playbackRate + 'x';

  if (!$canSetPlaybackRate) return null;

  return (
    <DefaultMenuSection label={label} value={value}>
      <DefaultMenuSliderItem
        UpIcon={Icons.Menu.SpeedUp}
        DownIcon={Icons.Menu.SpeedDown}
        isMin={$playbackRate === min}
        isMax={$playbackRate === max}
      >
        <DefaultSpeedSlider />
      </DefaultMenuSliderItem>
    </DefaultMenuSection>
  );
}

function useSpeedMin() {
  const { playbackRates } = useDefaultLayoutContext(),
    rates = playbackRates;
  return (isArray(rates) ? rates[0] : rates?.min) ?? 0;
}

function useSpeedMax() {
  const { playbackRates } = useDefaultLayoutContext(),
    rates = playbackRates;
  return (isArray(rates) ? rates[rates.length - 1] : rates?.max) ?? 2;
}

function useSpeedStep() {
  const { playbackRates } = useDefaultLayoutContext(),
    rates = playbackRates;
  return (isArray(rates) ? rates[1] - rates[0] : rates?.step) || 0.25;
}

/* -------------------------------------------------------------------------------------------------
 * DefaultSpeedSlider
 * -----------------------------------------------------------------------------------------------*/

function DefaultSpeedSlider() {
  const label = useDefaultLayoutWord('Speed'),
    min = useSpeedMin(),
    max = useSpeedMax(),
    step = useSpeedStep();

  return (
    <SpeedSlider.Root
      className="vds-speed-slider vds-slider"
      aria-label={label}
      min={min}
      max={max}
      step={step}
      keyStep={step}
    >
      <DefaultSliderParts />
      <DefaultSliderSteps />
    </SpeedSlider.Root>
  );
}

DefaultSpeedSlider.displayName = 'DefaultSpeedSlider';
</file>

<file path="components/layouts/default/ui/menus/settings-menu.tsx">
import * as React from 'react';

import { flushSync } from 'react-dom';
import { updateFontCssVars } from 'vidstack/exports/font.ts';

import { useMediaState } from '../../../../../hooks/use-media-state';
import { useScoped } from '../../../../../hooks/use-signals';
import * as Menu from '../../../../ui/menu';
import type * as Tooltip from '../../../../ui/tooltip';
import { useDefaultLayoutContext, useDefaultLayoutWord } from '../../context';
import { useColorSchemeClass } from '../../hooks';
import { slot, type DefaultLayoutMenuSlotName, type Slots } from '../../slots';
import { DefaultTooltip } from '../tooltip';
import { DefaultAccessibilityMenu } from './accessibility-menu';
import { DefaultAudioMenu } from './audio-menu';
import { DefaultCaptionMenu } from './captions-menu';
import { DefaultPlaybackMenu } from './playback-menu';
import { useParentDialogEl } from './utils';

export interface DefaultMediaMenuProps {
  tooltip: Tooltip.ContentProps['placement'];
  placement: Menu.ContentProps['placement'];
  portalClass?: string;
  slots?: Slots<DefaultLayoutMenuSlotName>;
}

function DefaultSettingsMenu({
  tooltip,
  placement,
  portalClass = '',
  slots,
}: DefaultMediaMenuProps) {
  const {
      showMenuDelay,
      icons: Icons,
      isSmallLayout,
      menuContainer,
      menuGroup,
      noModal,
      colorScheme,
    } = useDefaultLayoutContext(),
    settingsText = useDefaultLayoutWord('Settings'),
    $viewType = useMediaState('viewType'),
    $offset = !isSmallLayout && menuGroup === 'bottom' && $viewType === 'video' ? 26 : 0,
    colorSchemeClass = useColorSchemeClass(colorScheme),
    [isOpen, setIsOpen] = React.useState(false),
    dialogEl = useParentDialogEl();

  useScoped(updateFontCssVars);

  function onOpen() {
    flushSync(() => {
      setIsOpen(true);
    });
  }

  function onClose() {
    setIsOpen(false);
  }

  const Content = (
    <Menu.Content
      className="vds-settings-menu-items vds-menu-items"
      placement={placement}
      offset={$offset}
    >
      {isOpen ? (
        <>
          {slot(slots, 'settingsMenuItemsStart', null)}
          {slot(slots, 'settingsMenuStartItems', null)}
          <DefaultPlaybackMenu slots={slots} />
          <DefaultAccessibilityMenu slots={slots} />
          <DefaultAudioMenu slots={slots} />
          <DefaultCaptionMenu slots={slots} />
          {slot(slots, 'settingsMenuEndItems', null)}
          {slot(slots, 'settingsMenuItemsEnd', null)}
        </>
      ) : null}
    </Menu.Content>
  );

  return (
    <Menu.Root
      className="vds-settings-menu vds-menu"
      showDelay={showMenuDelay}
      onOpen={onOpen}
      onClose={onClose}
    >
      <DefaultTooltip content={settingsText} placement={tooltip}>
        <Menu.Button className="vds-menu-button vds-button" aria-label={settingsText}>
          <Icons.Menu.Settings className="vds-icon vds-rotate-icon" />
        </Menu.Button>
      </DefaultTooltip>
      {noModal || !isSmallLayout ? (
        Content
      ) : (
        <Menu.Portal
          className={portalClass + (colorSchemeClass ? ` ${colorSchemeClass}` : '')}
          container={menuContainer ?? dialogEl}
          disabled="fullscreen"
          data-sm={isSmallLayout ? '' : null}
          data-lg={!isSmallLayout ? '' : null}
          data-size={isSmallLayout ? 'sm' : 'lg'}
          data-view-type={$viewType}
        >
          {Content}
        </Menu.Portal>
      )}
    </Menu.Root>
  );
}

DefaultSettingsMenu.displayName = 'DefaultSettingsMenu';
export { DefaultSettingsMenu };
</file>

<file path="components/layouts/default/ui/menus/utils.ts">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';

import { useDefaultLayoutContext } from '../../context';

export function useParentDialogEl() {
  const { layoutEl } = useDefaultLayoutContext(),
    $layoutEl = useSignal(layoutEl);

  return React.useMemo(() => $layoutEl?.closest('dialog'), [$layoutEl]);
}
</file>

<file path="components/layouts/default/ui/sliders.tsx">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';
import type { SliderOrientation, TooltipPlacement } from 'vidstack';

import { useActive, useResizeObserver } from '../../../../hooks/use-dom';
import { useMediaState } from '../../../../hooks/use-media-state';
import { isRemotionSrc } from '../../../../providers/remotion/type-check';
import type { TimeSliderInstance } from '../../../primitives/instances';
import * as TimeSlider from '../../../ui/sliders/time-slider';
import * as VolumeSlider from '../../../ui/sliders/volume-slider';
import { RemotionSliderThumbnail } from '../../remotion-ui';
import { useDefaultLayoutContext, useDefaultLayoutWord } from '../context';
import { slot, type DefaultLayoutSlots } from '../slots';
import { DefaultMuteButton } from './buttons';

/* -------------------------------------------------------------------------------------------------
 * DefaultVolumePopup
 * -----------------------------------------------------------------------------------------------*/

export interface DefaultVolumePopupProps {
  slots?: DefaultLayoutSlots;
  tooltip: TooltipPlacement;
  orientation: SliderOrientation;
}

function DefaultVolumePopup({ tooltip, orientation, slots }: DefaultVolumePopupProps) {
  const $pointer = useMediaState('pointer'),
    $muted = useMediaState('muted'),
    $canSetVolume = useMediaState('canSetVolume'),
    [rootEl, setRootEl] = React.useState<HTMLElement | null>(null),
    isRootActive = useActive(rootEl),
    muteButton = slot(slots, 'muteButton', <DefaultMuteButton tooltip={tooltip} />);

  if (!$canSetVolume) {
    return muteButton;
  }

  return $pointer === 'coarse' && !$muted ? null : (
    <div className="vds-volume" data-active={isRootActive ? '' : null} ref={setRootEl}>
      {muteButton}
      <div className="vds-volume-popup">
        {slot(slots, 'volumeSlider', <DefaultVolumeSlider orientation={orientation} />)}
      </div>
    </div>
  );
}

DefaultVolumePopup.displayName = 'DefaultVolumePopup';
export { DefaultVolumePopup };

/* -------------------------------------------------------------------------------------------------
 * DefaultVolumeSlider
 * -----------------------------------------------------------------------------------------------*/

function DefaultVolumeSlider(props: VolumeSlider.RootProps) {
  const label = useDefaultLayoutWord('Volume');
  return (
    <VolumeSlider.Root className="vds-volume-slider vds-slider" aria-label={label} {...props}>
      <VolumeSlider.Track className="vds-slider-track" />
      <VolumeSlider.TrackFill className="vds-slider-track-fill vds-slider-track" />
      <VolumeSlider.Thumb className="vds-slider-thumb" />
      <VolumeSlider.Preview className="vds-slider-preview" noClamp>
        <VolumeSlider.Value className="vds-slider-value" />
      </VolumeSlider.Preview>
    </VolumeSlider.Root>
  );
}

DefaultVolumeSlider.displayName = 'DefaultVolumeSlider';
export { DefaultVolumeSlider };

/* -------------------------------------------------------------------------------------------------
 * DefaultTimeSlider
 * -----------------------------------------------------------------------------------------------*/

function DefaultTimeSlider() {
  const [instance, setInstance] = React.useState<TimeSliderInstance | null>(null),
    [width, setWidth] = React.useState(0),
    $src = useMediaState('currentSrc'),
    { thumbnails, sliderChaptersMinWidth, disableTimeSlider, seekStep, noScrubGesture } =
      useDefaultLayoutContext(),
    label = useDefaultLayoutWord('Seek'),
    $RemotionSliderThumbnail = useSignal(RemotionSliderThumbnail);

  const onResize = React.useCallback(() => {
    const el = instance?.el;
    el && setWidth(el.clientWidth);
  }, [instance]);

  useResizeObserver(instance?.el, onResize);

  return (
    <TimeSlider.Root
      className="vds-time-slider vds-slider"
      aria-label={label}
      disabled={disableTimeSlider}
      noSwipeGesture={noScrubGesture}
      keyStep={seekStep}
      ref={setInstance}
    >
      <TimeSlider.Chapters
        className="vds-slider-chapters"
        disabled={width < sliderChaptersMinWidth!}
      >
        {(cues, forwardRef) =>
          cues.map((cue) => (
            <div className="vds-slider-chapter" key={cue.startTime} ref={forwardRef}>
              <TimeSlider.Track className="vds-slider-track" />
              <TimeSlider.TrackFill className="vds-slider-track-fill vds-slider-track" />
              <TimeSlider.Progress className="vds-slider-progress vds-slider-track" />
            </div>
          ))
        }
      </TimeSlider.Chapters>
      <TimeSlider.Thumb className="vds-slider-thumb" />
      <TimeSlider.Preview className="vds-slider-preview">
        {thumbnails ? (
          <TimeSlider.Thumbnail.Root
            src={thumbnails}
            className="vds-slider-thumbnail vds-thumbnail"
          >
            <TimeSlider.Thumbnail.Img />
          </TimeSlider.Thumbnail.Root>
        ) : $RemotionSliderThumbnail && isRemotionSrc($src) ? (
          <$RemotionSliderThumbnail className="vds-slider-thumbnail vds-thumbnail" />
        ) : null}
        <TimeSlider.ChapterTitle className="vds-slider-chapter-title" />
        <TimeSlider.Value className="vds-slider-value" />
      </TimeSlider.Preview>
    </TimeSlider.Root>
  );
}

DefaultTimeSlider.displayName = 'DefaultTimeSlider';
export { DefaultTimeSlider };
</file>

<file path="components/layouts/default/ui/time.tsx">
import * as React from 'react';

/* -------------------------------------------------------------------------------------------------
 * DefaultTimeGroup
 * -----------------------------------------------------------------------------------------------*/

import { useMediaState } from '../../../../hooks/use-media-state';
import { Time } from '../../../ui/time';
import { slot } from '../slots';
import { DefaultLiveButton } from './buttons';

interface DefaultTimeGroupSlots {
  currentTime?: React.ReactNode;
  timeSeparator?: React.ReactNode;
  endTime?: React.ReactNode;
}

function DefaultTimeGroup({ slots }: { slots?: DefaultTimeGroupSlots }) {
  const $duration = useMediaState('duration');

  if (!$duration) return null;

  return (
    <div className="vds-time-group">
      {slot(slots, 'currentTime', <Time className="vds-time" type="current" />)}
      {slot(slots, 'timeSeparator', <div className="vds-time-divider">/</div>)}
      {slot(slots, 'endTime', <Time className="vds-time" type="duration" />)}
    </div>
  );
}

DefaultTimeGroup.displayName = 'DefaultTimeGroup';
export { DefaultTimeGroup };

/* -------------------------------------------------------------------------------------------------
 * DefaultTimeInfo
 * -----------------------------------------------------------------------------------------------*/

interface DefaultTimeInfoSlots extends DefaultTimeGroupSlots {
  liveButton?: React.ReactNode;
}

function DefaultTimeInfo({ slots }: { slots?: DefaultTimeInfoSlots }) {
  const $live = useMediaState('live');
  return $live ? (
    slot(slots, 'liveButton', <DefaultLiveButton />)
  ) : (
    <DefaultTimeGroup slots={slots} />
  );
}

DefaultTimeInfo.displayName = 'DefaultTimeInfo';
export { DefaultTimeInfo };

/* -------------------------------------------------------------------------------------------------
 * DefaultTimeInvert
 * -----------------------------------------------------------------------------------------------*/

function DefaultTimeInvert({ slots }: { slots?: DefaultTimeInfoSlots }) {
  const $live = useMediaState('live'),
    $duration = useMediaState('duration');

  return $live
    ? slot(slots, 'liveButton', <DefaultLiveButton />)
    : slot(
        slots,
        'endTime',
        $duration ? <Time className="vds-time" type="current" toggle remainder /> : null,
      );
}

DefaultTimeInvert.displayName = 'DefaultTimeInvert';
export { DefaultTimeInvert };
</file>

<file path="components/layouts/default/ui/title.tsx">
import * as React from 'react';

import { useActiveTextTrack } from '../../../../hooks/use-active-text-track';
import { useMediaState } from '../../../../hooks/use-media-state';
import { ChapterTitle } from '../../../ui/chapter-title';
import { Title } from '../../../ui/title';

/* -------------------------------------------------------------------------------------------------
 * DefaultTitle
 * -----------------------------------------------------------------------------------------------*/

function DefaultTitle() {
  const $started = useMediaState('started'),
    $title = useMediaState('title'),
    $hasChapters = useActiveTextTrack('chapters');
  return $hasChapters && ($started || !$title) ? (
    <ChapterTitle className="vds-chapter-title" />
  ) : (
    <Title className="vds-chapter-title" />
  );
}

DefaultTitle.displayName = 'DefaultTitle';
export { DefaultTitle };
</file>

<file path="components/layouts/default/ui/tooltip.tsx">
import * as React from 'react';

import type { TooltipPlacement } from 'vidstack';

import * as Tooltip from '../../../ui/tooltip';
import { useDefaultLayoutContext } from '../context';

export interface DefaultTooltipProps {
  content: string;
  placement?: TooltipPlacement;
  children: React.ReactNode;
}

function DefaultTooltip({ content, placement, children }: DefaultTooltipProps) {
  const { showTooltipDelay } = useDefaultLayoutContext();
  return (
    <Tooltip.Root showDelay={showTooltipDelay}>
      <Tooltip.Trigger asChild>{children}</Tooltip.Trigger>
      <Tooltip.Content className="vds-tooltip-content" placement={placement}>
        {content}
      </Tooltip.Content>
    </Tooltip.Root>
  );
}

DefaultTooltip.displayName = 'DefaultTooltip';
export { DefaultTooltip };
</file>

<file path="components/layouts/default/video-layout.tsx">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';

import { useMediaState } from '../../../hooks/use-media-state';
import * as Controls from '../../ui/controls';
import { Gesture } from '../../ui/gesture';
import * as Spinner from '../../ui/spinner';
import { Time } from '../../ui/time';
import { useLayoutName } from '../utils';
import { useDefaultLayoutContext } from './context';
import { createDefaultMediaLayout, type DefaultLayoutProps } from './media-layout';
import {
  slot,
  useDefaultVideoLayoutSlots,
  type DefaultLayoutMenuSlotName,
  type DefaultVideoLayoutSlots,
  type Slots,
} from './slots';
import { DefaultAnnouncer } from './ui/announcer';
import {
  DefaultAirPlayButton,
  DefaultCaptionButton,
  DefaultDownloadButton,
  DefaultFullscreenButton,
  DefaultGoogleCastButton,
  DefaultPIPButton,
  DefaultPlayButton,
} from './ui/buttons';
import { DefaultCaptions } from './ui/captions';
import { DefaultControlsSpacer } from './ui/controls';
import { DefaultKeyboardDisplay } from './ui/keyboard-display';
import { DefaultChaptersMenu } from './ui/menus/chapters-menu';
import { DefaultSettingsMenu } from './ui/menus/settings-menu';
import { DefaultTimeSlider, DefaultVolumePopup } from './ui/sliders';
import { DefaultTimeInfo } from './ui/time';
import { DefaultTitle } from './ui/title';

/* -------------------------------------------------------------------------------------------------
 * DefaultVideoLayout
 * -----------------------------------------------------------------------------------------------*/

const MediaLayout = createDefaultMediaLayout({
  type: 'video',
  smLayoutWhen({ width, height }) {
    return width < 576 || height < 380;
  },
  renderLayout(props) {
    return <VideoLayout {...props} />;
  },
});

export interface DefaultVideoLayoutProps extends DefaultLayoutProps<DefaultVideoLayoutSlots> {}

/**
 * The video layout is our production-ready UI that's displayed when the media view type is set to
 * 'video'. It includes support for picture-in-picture, fullscreen, slider chapters, slider
 * previews, captions, audio/quality settings, live streams, and more out of the box.
 *
 * @attr data-match - Whether this layout is being used.
 * @attr data-sm - The small layout is active
 * @attr data-lg - The large layout is active.
 * @attr data-size - The active layout size (sm or lg).
 * @example
 * ```tsx
 * <MediaPlayer src="video.mp4">
 *   <MediaProvider />
 *   <DefaultVideoLayout thumbnails="/thumbnails.vtt" icons={defaultLayoutIcons} />
 * </MediaPlayer>
 * ```
 */
function DefaultVideoLayout(props: DefaultVideoLayoutProps) {
  return <MediaLayout {...props} />;
}

DefaultVideoLayout.displayName = 'DefaultVideoLayout';
export { DefaultVideoLayout };

/* -------------------------------------------------------------------------------------------------
 * VideoLayout
 * -----------------------------------------------------------------------------------------------*/

function VideoLayout({ streamType, isLoadLayout, isSmallLayout }) {
  useLayoutName('video');

  return isLoadLayout ? (
    <DefaultVideoLoadLayout />
  ) : streamType === 'unknown' ? (
    <DefaultBufferingIndicator />
  ) : isSmallLayout ? (
    <DefaultVideoSmallLayout />
  ) : (
    <DefaultVideoLargeLayout />
  );
}

VideoLayout.displayName = 'VideoLayout';

/* -------------------------------------------------------------------------------------------------
 * DefaultVideoLargeLayout
 * -----------------------------------------------------------------------------------------------*/

function DefaultVideoLargeLayout() {
  const { menuGroup } = useDefaultLayoutContext(),
    baseSlots = useDefaultVideoLayoutSlots(),
    slots = { ...baseSlots, ...baseSlots?.largeLayout };
  return (
    <>
      <DefaultAnnouncer />
      <DefaultVideoGestures />
      <DefaultVideoKeyboardDisplay />
      {slot(slots, 'bufferingIndicator', <DefaultBufferingIndicator />)}
      {slot(slots, 'captions', <DefaultCaptions />)}
      <Controls.Root className="vds-controls">
        <Controls.Group className="vds-controls-group">
          {slot(slots, 'topControlsGroupStart', null)}
          <DefaultControlsSpacer />
          {slot(slots, 'topControlsGroupCenter', null)}
          <DefaultControlsSpacer />
          {slot(slots, 'topControlsGroupEnd', null)}
          {menuGroup === 'top' && <DefaultVideoMenus slots={slots} />}
        </Controls.Group>

        <DefaultControlsSpacer />

        <Controls.Group className="vds-controls-group">
          {slot(slots, 'centerControlsGroupStart', null)}
          <DefaultControlsSpacer />
          {slot(slots, 'centerControlsGroupCenter', null)}
          <DefaultControlsSpacer />
          {slot(slots, 'centerControlsGroupEnd', null)}
        </Controls.Group>

        <DefaultControlsSpacer />

        <Controls.Group className="vds-controls-group">
          {slot(slots, 'timeSlider', <DefaultTimeSlider />)}
        </Controls.Group>

        <Controls.Group className="vds-controls-group">
          {slot(slots, 'playButton', <DefaultPlayButton tooltip="top start" />)}
          <DefaultVolumePopup orientation="horizontal" tooltip="top" slots={slots} />
          <DefaultTimeInfo slots={slots} />
          {slot(slots, 'chapterTitle', <DefaultTitle />)}
          {slot(slots, 'captionButton', <DefaultCaptionButton tooltip="top" />)}
          {menuGroup === 'bottom' && <DefaultVideoMenus slots={slots} />}
          {slot(slots, 'airPlayButton', <DefaultAirPlayButton tooltip="top" />)}
          {slot(slots, 'googleCastButton', <DefaultGoogleCastButton tooltip="top" />)}
          {slot(slots, 'downloadButton', <DefaultDownloadButton />)}
          {slot(slots, 'pipButton', <DefaultPIPButton tooltip="top" />)}
          {slot(slots, 'fullscreenButton', <DefaultFullscreenButton tooltip="top end" />)}
        </Controls.Group>
      </Controls.Root>
    </>
  );
}

DefaultVideoLargeLayout.displayName = 'DefaultVideoLargeLayout';
export { DefaultVideoLargeLayout };

/* -------------------------------------------------------------------------------------------------
 * DefaultVideoSmallLayout
 * -----------------------------------------------------------------------------------------------*/

function DefaultVideoSmallLayout() {
  const baseSlots = useDefaultVideoLayoutSlots(),
    slots = { ...baseSlots, ...baseSlots?.smallLayout };
  return (
    <>
      <DefaultAnnouncer />
      <DefaultVideoGestures />
      <DefaultVideoKeyboardDisplay />
      {slot(slots, 'bufferingIndicator', <DefaultBufferingIndicator />)}
      {slot(slots, 'captions', <DefaultCaptions />)}
      <Controls.Root className="vds-controls">
        <Controls.Group className="vds-controls-group">
          {slot(slots, 'topControlsGroupStart', null)}
          {slot(slots, 'airPlayButton', <DefaultAirPlayButton tooltip="top start" />)}
          {slot(slots, 'googleCastButton', <DefaultGoogleCastButton tooltip="top start" />)}
          <DefaultControlsSpacer />
          {slot(slots, 'topControlsGroupCenter', null)}
          <DefaultControlsSpacer />
          {slot(slots, 'captionButton', <DefaultCaptionButton tooltip="bottom" />)}
          {slot(slots, 'downloadButton', <DefaultDownloadButton />)}
          <DefaultVideoMenus slots={slots} />
          <DefaultVolumePopup orientation="vertical" tooltip="bottom end" slots={slots} />
          {slot(slots, 'topControlsGroupEnd', null)}
        </Controls.Group>
        <DefaultControlsSpacer />
        <Controls.Group className="vds-controls-group" style={{ pointerEvents: 'none' }}>
          {slot(slots, 'centerControlsGroupStart', null)}
          <DefaultControlsSpacer />
          {slot(slots, 'centerControlsGroupCenter', null)}
          {slot(slots, 'playButton', <DefaultPlayButton tooltip="top" />)}
          <DefaultControlsSpacer />
          {slot(slots, 'centerControlsGroupEnd', null)}
        </Controls.Group>
        <DefaultControlsSpacer />
        <Controls.Group className="vds-controls-group">
          <DefaultTimeInfo slots={slots} />
          {slot(slots, 'chapterTitle', <DefaultTitle />)}
          {slot(slots, 'fullscreenButton', <DefaultFullscreenButton tooltip="top end" />)}
        </Controls.Group>
        <Controls.Group className="vds-controls-group">
          {slot(slots, 'timeSlider', <DefaultTimeSlider />)}
        </Controls.Group>
      </Controls.Root>
      {slot(slots, 'startDuration', <DefaultVideoStartDuration />)}
    </>
  );
}

DefaultVideoSmallLayout.displayName = 'DefaultVideoSmallLayout';
export { DefaultVideoSmallLayout };

/* -------------------------------------------------------------------------------------------------
 * DefaultVideoStartDuration
 * -----------------------------------------------------------------------------------------------*/

function DefaultVideoStartDuration() {
  const $duration = useMediaState('duration');
  if ($duration === 0) return null;
  return (
    <div className="vds-start-duration">
      <Time className="vds-time" type="duration" />
    </div>
  );
}

DefaultVideoStartDuration.displayName = 'DefaultVideoStartDuration';
/* -------------------------------------------------------------------------------------------------
 * DefaultVideoGestures
 * -----------------------------------------------------------------------------------------------*/

function DefaultVideoGestures() {
  const { noGestures } = useDefaultLayoutContext();

  if (noGestures) return null;

  return (
    <div className="vds-gestures">
      <Gesture className="vds-gesture" event="pointerup" action="toggle:paused" />
      <Gesture className="vds-gesture" event="pointerup" action="toggle:controls" />
      <Gesture className="vds-gesture" event="dblpointerup" action="toggle:fullscreen" />
      <Gesture className="vds-gesture" event="dblpointerup" action="seek:-10" />
      <Gesture className="vds-gesture" event="dblpointerup" action="seek:10" />
    </div>
  );
}

DefaultVideoGestures.displayName = 'DefaultVideoGestures';
export { DefaultVideoGestures };

/* -------------------------------------------------------------------------------------------------
 * DefaultBufferingIndicator
 * -----------------------------------------------------------------------------------------------*/

function DefaultBufferingIndicator() {
  return (
    <div className="vds-buffering-indicator">
      <Spinner.Root className="vds-buffering-spinner">
        <Spinner.Track className="vds-buffering-track" />
        <Spinner.TrackFill className="vds-buffering-track-fill" />
      </Spinner.Root>
    </div>
  );
}

DefaultBufferingIndicator.displayName = 'DefaultBufferingIndicator';
export { DefaultBufferingIndicator };

/* -------------------------------------------------------------------------------------------------
 * DefaultVideoMenus
 * -----------------------------------------------------------------------------------------------*/

function DefaultVideoMenus({ slots }: { slots?: Slots<DefaultLayoutMenuSlotName> }) {
  const { isSmallLayout, noModal, menuGroup } = useDefaultLayoutContext(),
    side = menuGroup === 'top' || isSmallLayout ? 'bottom' : ('top' as const),
    tooltip = `${side} end` as const,
    placement = noModal
      ? (`${side} end` as const)
      : !isSmallLayout
        ? (`${side} end` as const)
        : null;
  return (
    <>
      {slot(
        slots,
        'chaptersMenu',
        <DefaultChaptersMenu
          tooltip={tooltip}
          placement={placement}
          portalClass="vds-video-layout"
        />,
      )}
      {slot(
        slots,
        'settingsMenu',
        <DefaultSettingsMenu
          tooltip={tooltip}
          placement={placement}
          portalClass="vds-video-layout"
          slots={slots}
        />,
      )}
    </>
  );
}

DefaultVideoMenus.displayName = 'DefaultVideoMenus';

/* -------------------------------------------------------------------------------------------------
 * DefaultVideoLoadLayout
 * -----------------------------------------------------------------------------------------------*/

function DefaultVideoLoadLayout() {
  const { isSmallLayout } = useDefaultLayoutContext(),
    baseSlots = useDefaultVideoLayoutSlots(),
    slots = { ...baseSlots, ...baseSlots?.[isSmallLayout ? 'smallLayout' : 'largeLayout'] };
  return (
    <div className="vds-load-container">
      {slot(slots, 'bufferingIndicator', <DefaultBufferingIndicator />)}
      {slot(slots, 'loadButton', <DefaultPlayButton tooltip="top" />)}
    </div>
  );
}

DefaultVideoLoadLayout.displayName = 'DefaultVideoLoadLayout';

/* -------------------------------------------------------------------------------------------------
 * DefaultVideoKeyboardDisplay
 * -----------------------------------------------------------------------------------------------*/

function DefaultVideoKeyboardDisplay() {
  const { noKeyboardAnimations, icons, userPrefersKeyboardAnimations } = useDefaultLayoutContext(),
    $userPrefersKeyboardAnimations = useSignal(userPrefersKeyboardAnimations),
    disabled = noKeyboardAnimations || !$userPrefersKeyboardAnimations;

  if (disabled || !icons.KeyboardDisplay) return null;

  return <DefaultKeyboardDisplay icons={icons.KeyboardDisplay} />;
}

DefaultVideoKeyboardDisplay.displayName = 'DefaultVideoKeyboardDisplay';
</file>

<file path="components/layouts/plyr/context.ts">
import * as React from 'react';

import { type WriteSignal } from 'maverick.js';
import type { PlyrLayoutWord } from 'vidstack';

import type { PlyrLayoutProps } from './props';

interface PlyrLayoutContext extends PlyrLayoutProps {
  previewTime: WriteSignal<number>;
}

export const PlyrLayoutContext = React.createContext<PlyrLayoutContext>({} as any);
PlyrLayoutContext.displayName = 'PlyrLayoutContext';

export function usePlyrLayoutContext() {
  return React.useContext(PlyrLayoutContext);
}

export function usePlyrLayoutWord(word: PlyrLayoutWord) {
  const { translations } = usePlyrLayoutContext();
  return i18n(translations, word);
}

export function i18n(translations: any, word: string) {
  return translations?.[word] ?? word;
}
</file>

<file path="components/layouts/plyr/icons.tsx">
import * as React from 'react';

import { Icon } from '../../../icon';
import airplay from './icons/plyr-airplay';
import captionsOff from './icons/plyr-captions-off';
import captionsOn from './icons/plyr-captions-on';
import download from './icons/plyr-download';
import exitFullscreen from './icons/plyr-enter-fullscreen';
import enterFullscreen from './icons/plyr-exit-fullscreen';
import fastForward from './icons/plyr-fast-forward';
import muted from './icons/plyr-muted';
import pause from './icons/plyr-pause';
import pip from './icons/plyr-pip';
import play from './icons/plyr-play';
import restart from './icons/plyr-restart';
import rewind from './icons/plyr-rewind';
import settings from './icons/plyr-settings';
import volume from './icons/plyr-volume';

function createIcon(paths: string) {
  function PlyrLayoutIcon(props: PlyrLayoutIconProps) {
    return <Icon viewBox="0 0 18 18" paths={paths} {...props} />;
  }

  PlyrLayoutIcon.displayName = 'PlyrLayoutIcon';
  return PlyrLayoutIcon;
}

export const plyrLayoutIcons: PlyrLayoutIcons = {
  AirPlay: createIcon(airplay),
  CaptionsOff: createIcon(captionsOff),
  CaptionsOn: createIcon(captionsOn),
  Download: createIcon(download),
  EnterFullscreen: createIcon(enterFullscreen),
  EnterPiP: createIcon(pip),
  ExitFullscreen: createIcon(exitFullscreen),
  ExitPiP: createIcon(pip),
  FastForward: createIcon(fastForward),
  Muted: createIcon(muted),
  Pause: createIcon(pause),
  Play: createIcon(play),
  Restart: createIcon(restart),
  Rewind: createIcon(rewind),
  Settings: createIcon(settings),
  Volume: createIcon(volume),
};

export interface PlyrLayoutIconProps extends React.PropsWithoutRef<React.SVGProps<SVGSVGElement>> {}

export interface PlyrLayoutIcon {
  (props: PlyrLayoutIconProps): React.ReactNode;
}

export interface PlyrLayoutIcons {
  AirPlay: PlyrLayoutIcon;
  CaptionsOff: PlyrLayoutIcon;
  CaptionsOn: PlyrLayoutIcon;
  Download: PlyrLayoutIcon;
  EnterFullscreen: PlyrLayoutIcon;
  EnterPiP: PlyrLayoutIcon;
  ExitFullscreen: PlyrLayoutIcon;
  ExitPiP: PlyrLayoutIcon;
  FastForward: PlyrLayoutIcon;
  Muted: PlyrLayoutIcon;
  Pause: PlyrLayoutIcon;
  Play: PlyrLayoutIcon;
  Restart: PlyrLayoutIcon;
  Rewind: PlyrLayoutIcon;
  Settings: PlyrLayoutIcon;
  Volume: PlyrLayoutIcon;
}
</file>

<file path="components/layouts/plyr/icons/plyr-airplay.js">
export default `<g><path d="M16,1 L2,1 C1.447,1 1,1.447 1,2 L1,12 C1,12.553 1.447,13 2,13 L5,13 L5,11 L3,11 L3,3 L15,3 L15,11 L13,11 L13,13 L16,13 C16.553,13 17,12.553 17,12 L17,2 C17,1.447 16.553,1 16,1 L16,1 Z"></path><polygon points="4 17 14 17 9 11"></polygon></g>`;
</file>

<file path="components/layouts/plyr/icons/plyr-captions-off.js">
export default `<g fill-rule="evenodd" fill-opacity="0.5"><path d="M1,1 C0.4,1 0,1.4 0,2 L0,13 C0,13.6 0.4,14 1,14 L5.6,14 L8.3,16.7 C8.5,16.9 8.7,17 9,17 C9.3,17 9.5,16.9 9.7,16.7 L12.4,14 L17,14 C17.6,14 18,13.6 18,13 L18,2 C18,1.4 17.6,1 17,1 L1,1 Z M5.52,11.15 C7.51,11.15 8.53,9.83 8.8,8.74 L7.51,8.35 C7.32,9.01 6.73,9.8 5.52,9.8 C4.38,9.8 3.32,8.97 3.32,7.46 C3.32,5.85 4.44,5.09 5.5,5.09 C6.73,5.09 7.28,5.84 7.45,6.52 L8.75,6.11 C8.47,4.96 7.46,3.76 5.5,3.76 C3.6,3.76 1.89,5.2 1.89,7.46 C1.89,9.72 3.54,11.15 5.52,11.15 Z M13.09,11.15 C15.08,11.15 16.1,9.83 16.37,8.74 L15.08,8.35 C14.89,9.01 14.3,9.8 13.09,9.8 C11.95,9.8 10.89,8.97 10.89,7.46 C10.89,5.85 12.01,5.09 13.07,5.09 C14.3,5.09 14.85,5.84 15.02,6.52 L16.32,6.11 C16.04,4.96 15.03,3.76 13.07,3.76 C11.17,3.76 9.46,5.2 9.46,7.46 C9.46,9.72 11.11,11.15 13.09,11.15 Z"></path></g>`;
</file>

<file path="components/layouts/plyr/icons/plyr-captions-on.js">
export default `<g fill-rule="evenodd"><path d="M1,1 C0.4,1 0,1.4 0,2 L0,13 C0,13.6 0.4,14 1,14 L5.6,14 L8.3,16.7 C8.5,16.9 8.7,17 9,17 C9.3,17 9.5,16.9 9.7,16.7 L12.4,14 L17,14 C17.6,14 18,13.6 18,13 L18,2 C18,1.4 17.6,1 17,1 L1,1 Z M5.52,11.15 C7.51,11.15 8.53,9.83 8.8,8.74 L7.51,8.35 C7.32,9.01 6.73,9.8 5.52,9.8 C4.38,9.8 3.32,8.97 3.32,7.46 C3.32,5.85 4.44,5.09 5.5,5.09 C6.73,5.09 7.28,5.84 7.45,6.52 L8.75,6.11 C8.47,4.96 7.46,3.76 5.5,3.76 C3.6,3.76 1.89,5.2 1.89,7.46 C1.89,9.72 3.54,11.15 5.52,11.15 Z M13.09,11.15 C15.08,11.15 16.1,9.83 16.37,8.74 L15.08,8.35 C14.89,9.01 14.3,9.8 13.09,9.8 C11.95,9.8 10.89,8.97 10.89,7.46 C10.89,5.85 12.01,5.09 13.07,5.09 C14.3,5.09 14.85,5.84 15.02,6.52 L16.32,6.11 C16.04,4.96 15.03,3.76 13.07,3.76 C11.17,3.76 9.46,5.2 9.46,7.46 C9.46,9.72 11.11,11.15 13.09,11.15 Z"></path></g>`;
</file>

<file path="components/layouts/plyr/icons/plyr-download.js">
export default `<g transform="translate(2 1)"><path d="M7,12 C7.3,12 7.5,11.9 7.7,11.7 L13.4,6 L12,4.6 L8,8.6 L8,0 L6,0 L6,8.6 L2,4.6 L0.6,6 L6.3,11.7 C6.5,11.9 6.7,12 7,12 Z" /><rect width="14" height="2" y="14" /></g>`;
</file>

<file path="components/layouts/plyr/icons/plyr-enter-fullscreen.js">
export default `<polygon points="10 3 13.6 3 9.6 7 11 8.4 15 4.4 15 8 17 8 17 1 10 1"></polygon><polygon points="7 9.6 3 13.6 3 10 1 10 1 17 8 17 8 15 4.4 15 8.4 11"></polygon>`;
</file>

<file path="components/layouts/plyr/icons/plyr-exit-fullscreen.js">
export default `<polygon points="1 12 4.6 12 0.6 16 2 17.4 6 13.4 6 17 8 17 8 10 1 10"></polygon><polygon points="16 0.6 12 4.6 12 1 10 1 10 8 17 8 17 6 13.4 6 17.4 2"></polygon>`;
</file>

<file path="components/layouts/plyr/icons/plyr-fast-forward.js">
export default `<polygon points="7.875 7.17142857 0 1 0 17 7.875 10.8285714 7.875 17 18 9 7.875 1"></polygon>`;
</file>

<file path="components/layouts/plyr/icons/plyr-muted.js">
export default `<polygon points="12.4 12.5 14.5 10.4 16.6 12.5 18 11.1 15.9 9 18 6.9 16.6 5.5 14.5 7.6 12.4 5.5 11 6.9 13.1 9 11 11.1"></polygon><path d="M3.78571429,6.00820648 L0.714285714,6.00820648 C0.285714286,6.00820648 0,6.30901277 0,6.76022222 L0,11.2723167 C0,11.7235261 0.285714286,12.0243324 0.714285714,12.0243324 L3.78571429,12.0243324 L7.85714286,15.8819922 C8.35714286,16.1827985 9,15.8819922 9,15.2803796 L9,2.75215925 C9,2.15054666 8.35714286,1.77453879 7.85714286,2.15054666 L3.78571429,6.00820648 Z"></path>`;
</file>

<file path="components/layouts/plyr/icons/plyr-pause.js">
export default `<path d="M6,1 L3,1 C2.4,1 2,1.4 2,2 L2,16 C2,16.6 2.4,17 3,17 L6,17 C6.6,17 7,16.6 7,16 L7,2 C7,1.4 6.6,1 6,1 L6,1 Z"></path><path d="M12,1 C11.4,1 11,1.4 11,2 L11,16 C11,16.6 11.4,17 12,17 L15,17 C15.6,17 16,16.6 16,16 L16,2 C16,1.4 15.6,1 15,1 L12,1 Z"></path>`;
</file>

<file path="components/layouts/plyr/icons/plyr-pip.js">
export default `<polygon points="13.293 3.293 7.022 9.564 8.436 10.978 14.707 4.707 17 7 17 1 11 1"></polygon><path d="M13,15 L3,15 L3,5 L8,5 L8,3 L2,3 C1.448,3 1,3.448 1,4 L1,16 C1,16.552 1.448,17 2,17 L14,17 C14.552,17 15,16.552 15,16 L15,10 L13,10 L13,15 L13,15 Z"></path>`;
</file>

<file path="components/layouts/plyr/icons/plyr-play.js">
export default `<path d="M15.5615866,8.10002147 L3.87056367,0.225209313 C3.05219207,-0.33727727 2,0.225209313 2,1.12518784 L2,16.8748122 C2,17.7747907 3.05219207,18.3372773 3.87056367,17.7747907 L15.5615866,9.89997853 C16.1461378,9.44998927 16.1461378,8.55001073 15.5615866,8.10002147 L15.5615866,8.10002147 Z"></path>`;
</file>

<file path="components/layouts/plyr/icons/plyr-restart.js">
export default `<path d="M9.7,1.2 L10.4,7.6 L12.5,5.5 C14.4,7.4 14.4,10.6 12.5,12.5 C11.6,13.5 10.3,14 9,14 C7.7,14 6.4,13.5 5.5,12.5 C3.6,10.6 3.6,7.4 5.5,5.5 C6.1,4.9 6.9,4.4 7.8,4.2 L7.2,2.3 C6,2.6 4.9,3.2 4,4.1 C1.3,6.8 1.3,11.2 4,14 C5.3,15.3 7.1,16 8.9,16 C10.8,16 12.5,15.3 13.8,14 C16.5,11.3 16.5,6.9 13.8,4.1 L16,1.9 L9.7,1.2 L9.7,1.2 Z"></path>`;
</file>

<file path="components/layouts/plyr/icons/plyr-rewind.js">
export default `<polygon points="10.125 1 0 9 10.125 17 10.125 10.8285714 18 17 18 1 10.125 7.17142857"></polygon>`;
</file>

<file path="components/layouts/plyr/icons/plyr-settings.js">
export default `<path d="M16.135,7.784 C14.832,7.458 14.214,5.966 14.905,4.815 C15.227,4.279 15.13,3.817 14.811,3.499 L14.501,3.189 C14.183,2.871 13.721,2.774 13.185,3.095 C12.033,3.786 10.541,3.168 10.216,1.865 C10.065,1.258 9.669,1 9.219,1 L8.781,1 C8.331,1 7.936,1.258 7.784,1.865 C7.458,3.168 5.966,3.786 4.815,3.095 C4.279,2.773 3.816,2.87 3.498,3.188 L3.188,3.498 C2.87,3.816 2.773,4.279 3.095,4.815 C3.786,5.967 3.168,7.459 1.865,7.784 C1.26,7.935 1,8.33 1,8.781 L1,9.219 C1,9.669 1.258,10.064 1.865,10.216 C3.168,10.542 3.786,12.034 3.095,13.185 C2.773,13.721 2.87,14.183 3.189,14.501 L3.499,14.811 C3.818,15.13 4.281,15.226 4.815,14.905 C5.967,14.214 7.459,14.832 7.784,16.135 C7.935,16.742 8.331,17 8.781,17 L9.219,17 C9.669,17 10.064,16.742 10.216,16.135 C10.542,14.832 12.034,14.214 13.185,14.905 C13.72,15.226 14.182,15.13 14.501,14.811 L14.811,14.501 C15.129,14.183 15.226,13.72 14.905,13.185 C14.214,12.033 14.832,10.541 16.135,10.216 C16.742,10.065 17,9.669 17,9.219 L17,8.781 C17,8.33 16.74,7.935 16.135,7.784 L16.135,7.784 Z M9,12 C7.343,12 6,10.657 6,9 C6,7.343 7.343,6 9,6 C10.657,6 12,7.343 12,9 C12,10.657 10.657,12 9,12 L9,12 Z"></path>`;
</file>

<file path="components/layouts/plyr/icons/plyr-volume.js">
export default `<path d="M15.5999996,3.3 C15.1999996,2.9 14.5999996,2.9 14.1999996,3.3 C13.7999996,3.7 13.7999996,4.3 14.1999996,4.7 C15.3999996,5.9 15.9999996,7.4 15.9999996,9 C15.9999996,10.6 15.3999996,12.1 14.1999996,13.3 C13.7999996,13.7 13.7999996,14.3 14.1999996,14.7 C14.3999996,14.9 14.6999996,15 14.8999996,15 C15.1999996,15 15.3999996,14.9 15.5999996,14.7 C17.0999996,13.2 17.9999996,11.2 17.9999996,9 C17.9999996,6.8 17.0999996,4.8 15.5999996,3.3 L15.5999996,3.3 Z"></path><path d="M11.2819745,5.28197449 C10.9060085,5.65794047 10.9060085,6.22188944 11.2819745,6.59785542 C12.0171538,7.33303477 12.2772954,8.05605449 12.2772954,9.00000021 C12.2772954,9.93588462 11.851678,10.9172014 11.2819745,11.4869049 C10.9060085,11.8628709 10.9060085,12.4268199 11.2819745,12.8027859 C11.4271642,12.9479755 11.9176724,13.0649528 12.2998149,12.9592565 C12.4124479,12.9281035 12.5156669,12.8776063 12.5978555,12.8027859 C13.773371,11.732654 14.1311161,10.1597914 14.1312523,9.00000021 C14.1312723,8.8299555 14.1286311,8.66015647 14.119665,8.4897429 C14.0674781,7.49784946 13.8010171,6.48513613 12.5978554,5.28197449 C12.2218894,4.9060085 11.6579405,4.9060085 11.2819745,5.28197449 Z"></path><path d="M3.78571429,6.00820648 L0.714285714,6.00820648 C0.285714286,6.00820648 0,6.30901277 0,6.76022222 L0,11.2723167 C0,11.7235261 0.285714286,12.0243324 0.714285714,12.0243324 L3.78571429,12.0243324 L7.85714286,15.8819922 C8.35714286,16.1827985 9,15.8819922 9,15.2803796 L9,2.75215925 C9,2.15054666 8.35714286,1.77453879 7.85714286,2.15054666 L3.78571429,6.00820648 Z"></path>`;
</file>

<file path="components/layouts/plyr/index.ts">
export {
  type PlyrLayoutElementProps,
  PlyrLayout,
  PlyrAudioLayout,
  PlyrVideoLayout,
} from './layout';
export type { PlyrLayoutProps } from './props';
export type { PlyrLayoutSlots, PlyrLayoutSlotName } from './slots';
export type { PlyrControl, PlyrLayoutTranslations, PlyrLayoutWord, PlyrMarker } from 'vidstack';
export * from './icons';
export * from './context';
</file>

<file path="components/layouts/plyr/layout.tsx">
import * as React from 'react';

import { signal } from 'maverick.js';
import { composeRefs, useSignal } from 'maverick.js/react';
import { isNumber, isString, listenEvent } from 'maverick.js/std';
import type { VTTCue } from 'media-captions';
import {
  isKeyboardClick,
  isKeyboardEvent,
  usePlyrLayoutClasses,
  type PlyrControl,
  type PlyrLayoutWord,
  type PlyrMarker,
} from 'vidstack';

import { getDownloadFile } from '../../../../../vidstack/src/utils/network';
import { useAudioOptions } from '../../../hooks/options/use-audio-options';
import { useCaptionOptions } from '../../../hooks/options/use-caption-options';
import { usePlaybackRateOptions } from '../../../hooks/options/use-playback-rate-options';
import { useVideoQualityOptions } from '../../../hooks/options/use-video-quality-options';
import { useClassName } from '../../../hooks/use-dom';
import { useMediaContext } from '../../../hooks/use-media-context';
import { useMediaRemote } from '../../../hooks/use-media-remote';
import { useMediaState } from '../../../hooks/use-media-state';
import { isRemotionSource } from '../../../providers/remotion';
import { appendParamsToURL } from '../../../utils';
import { Primitive, type PrimitivePropsWithRef } from '../../primitives/nodes';
import { AirPlayButton } from '../../ui/buttons/airplay-button';
import { CaptionButton } from '../../ui/buttons/caption-button';
import { FullscreenButton } from '../../ui/buttons/fullscreen-button';
import { LiveButton } from '../../ui/buttons/live-button';
import { MuteButton } from '../../ui/buttons/mute-button';
import { PIPButton } from '../../ui/buttons/pip-button';
import { PlayButton } from '../../ui/buttons/play-button';
import { SeekButton } from '../../ui/buttons/seek-button';
import { Gesture } from '../../ui/gesture';
import * as Menu from '../../ui/menu';
import * as TimeSlider from '../../ui/sliders/time-slider';
import * as VolumeSlider from '../../ui/sliders/volume-slider';
import * as Thumbnail from '../../ui/thumbnail';
import { Time } from '../../ui/time';
import { RemotionPoster, RemotionSliderThumbnail, RemotionThumbnail } from '../remotion-ui';
import { useLayoutName } from '../utils';
import { i18n, PlyrLayoutContext, usePlyrLayoutContext, usePlyrLayoutWord } from './context';
import { defaultPlyrLayoutProps, type PlyrLayoutProps } from './props';
import { slot } from './slots';

/* -------------------------------------------------------------------------------------------------
 * PlyrLayout
 * -----------------------------------------------------------------------------------------------*/

export interface PlyrLayoutElementProps extends PlyrLayoutProps, PrimitivePropsWithRef<'div'> {}

const PlyrLayout = React.forwardRef<HTMLElement, PlyrLayoutElementProps>(
  (userProps, forwardRef) => {
    const {
        clickToPlay,
        clickToFullscreen,
        controls,
        displayDuration,
        download,
        markers,
        invertTime,
        thumbnails,
        toggleTime,
        translations,
        seekTime,
        speed,
        icons,
        slots,
        posterFrame,
        className,
        ...elProps
      } = { ...defaultPlyrLayoutProps, ...userProps },
      [el, setEl] = React.useState<HTMLElement | null>(null),
      media = useMediaContext(),
      previewTime = React.useMemo(() => signal(0), []),
      $viewType = useMediaState('viewType');

    useLayoutName('plyr');
    useClassName(el, className);

    React.useEffect(() => {
      if (!el || !media) return;
      return usePlyrLayoutClasses(el, media);
    }, [el, media]);

    return (
      <PlyrLayoutContext.Provider
        value={{
          clickToPlay,
          clickToFullscreen,
          controls,
          displayDuration,
          download,
          markers,
          invertTime,
          thumbnails,
          toggleTime,
          translations,
          seekTime,
          speed,
          previewTime,
          icons,
          slots,
          posterFrame,
        }}
      >
        <Primitive.div
          {...elProps}
          className={
            __SERVER__ ? `plyr plyr--full-ui plyr--${$viewType} ${className || ''}` : undefined
          }
          ref={composeRefs(setEl, forwardRef) as any}
        >
          {$viewType === 'audio' ? (
            <PlyrAudioLayout />
          ) : $viewType === 'video' ? (
            <PlyrVideoLayout />
          ) : null}
        </Primitive.div>
      </PlyrLayoutContext.Provider>
    );
  },
);

PlyrLayout.displayName = 'PlyrLayout';
export { PlyrLayout };

/* -------------------------------------------------------------------------------------------------
 * PlyrAudioLayout
 * -----------------------------------------------------------------------------------------------*/

function PlyrAudioLayout() {
  return PlyrAudioControls();
}

PlyrAudioLayout.displayName = 'PlyrAudioLayout';
export { PlyrAudioLayout };

/* -------------------------------------------------------------------------------------------------
 * PlyrVideoLayout
 * -----------------------------------------------------------------------------------------------*/

function PlyrVideoLayout() {
  const media = useMediaContext(),
    { controls } = usePlyrLayoutContext(),
    { load } = media.$props,
    { canLoad } = media.$state,
    $load = useSignal(load),
    $canLoad = useSignal(canLoad);

  if ($load === 'play' && !$canLoad) {
    return (
      <>
        <PlyrPlayLargeButton />
        <PlyrPoster />
      </>
    );
  }

  return (
    <>
      {controls!.includes('play-large') ? <PlyrPlayLargeButton /> : null}
      <PlyrPreviewScrubbing />
      <PlyrPoster />
      <PlyrVideoControls />
      <PlyrGestures />
      <PlyrCaptions />
    </>
  );
}

PlyrVideoLayout.displayName = 'PlyrVideoLayout';
export { PlyrVideoLayout };

/* -------------------------------------------------------------------------------------------------
 * PlyrPlayLargeButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrPlayLargeButton() {
  const { translations, icons: Icons } = usePlyrLayoutContext(),
    $title = useMediaState('title'),
    label = `${i18n(translations, 'Play')} ${$title}`;
  return slot(
    'playLargeButton',
    <PlayButton
      className="plyr__control plyr__control--overlaid"
      aria-label={label}
      data-plyr="play"
    >
      <Icons.Play />
    </PlayButton>,
  );
}

PlyrPlayLargeButton.displayName = 'PlyrPlayLargeButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrPreviewScrubbing
 * -----------------------------------------------------------------------------------------------*/

function PlyrPreviewScrubbing() {
  const $src = useMediaState('source'),
    { thumbnails, previewTime } = usePlyrLayoutContext(),
    $previewTime = useSignal(previewTime),
    $RemotionThumbnail = useSignal(RemotionThumbnail),
    $hasRemotionThumbnail = $RemotionThumbnail && isRemotionSource($src);

  return $hasRemotionThumbnail ? (
    <$RemotionThumbnail className="plyr__preview-scrubbing" frame={$previewTime * $src.fps!} />
  ) : (
    <Thumbnail.Root src={thumbnails} className="plyr__preview-scrubbing" time={$previewTime}>
      <Thumbnail.Img />
    </Thumbnail.Root>
  );
}

PlyrPreviewScrubbing.displayName = 'PlyrPreviewScrubbing';

/* -------------------------------------------------------------------------------------------------
 * PlyrPoster
 * -----------------------------------------------------------------------------------------------*/

function PlyrPoster() {
  const $src = useMediaState('source'),
    $poster = useMediaState('poster'),
    { posterFrame } = usePlyrLayoutContext(),
    $RemotionPoster = useSignal(RemotionPoster),
    $hasRemotionPoster = $RemotionPoster && isRemotionSource($src) && isNumber(posterFrame);

  return slot(
    'poster',
    $hasRemotionPoster ? (
      <$RemotionPoster frame={posterFrame} className="plyr__poster" />
    ) : (
      <div className="plyr__poster" style={{ backgroundImage: `url("${$poster}")` }} />
    ),
  );
}

PlyrPoster.displayName = 'PlyrPoster';

/* -------------------------------------------------------------------------------------------------
 * PlyrAudioControls
 * -----------------------------------------------------------------------------------------------*/

const noAudioControl = new Set<PlyrControl>(['captions', 'pip', 'airplay', 'fullscreen']);

function PlyrAudioControls() {
  const { controls } = usePlyrLayoutContext();
  return (
    <div className="plyr__controls">
      {controls!
        .filter((type) => !noAudioControl.has(type))
        .map((type, i) => {
          const Control = getPlyrControl(type);
          return Control ? React.createElement(Control, { key: i }) : null;
        })}
    </div>
  );
}

PlyrAudioControls.displayName = 'PlyrAudioControls';

/* -------------------------------------------------------------------------------------------------
 * PlyrVideoControls
 * -----------------------------------------------------------------------------------------------*/

function PlyrVideoControls() {
  const { controls } = usePlyrLayoutContext();
  return (
    <div className="plyr__controls">
      {controls!.map((type, i) => {
        const Control = getPlyrControl(type);
        return Control ? React.createElement(Control, { key: i }) : null;
      })}
    </div>
  );
}

PlyrVideoControls.displayName = 'PlyrVideoControls';

/* -------------------------------------------------------------------------------------------------
 * Control
 * -----------------------------------------------------------------------------------------------*/

function getPlyrControl(type: PlyrControl) {
  switch (type) {
    case 'airplay':
      return PlyrAirPlayButton;
    case 'captions':
      return PlyrCaptionsButton;
    case 'current-time':
      return PlyrCurrentTime;
    case 'download':
      return PlyrDownloadButton;
    case 'duration':
      return PlyrDuration;
    case 'fast-forward':
      return PlyrFastForwardButton;
    case 'fullscreen':
      return PlyrFullscreenButton;
    case 'mute':
    case 'volume':
    case 'mute+volume':
      return () => PlyrVolume({ type });
    case 'pip':
      return PlyrPIPButton;
    case 'play':
      return PlyrPlayButton;
    case 'progress':
      return PlyrTimeSlider;
    case 'restart':
      return PlyrRestartButton;
    case 'rewind':
      return PlyrRewindButton;
    case 'settings':
      return PlyrSettings;
    default:
      return null;
  }
}

/* -------------------------------------------------------------------------------------------------
 * PlyrAirPlayButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrAirPlayButton() {
  const { icons: Icons } = usePlyrLayoutContext(),
    airPlayText = usePlyrLayoutWord('AirPlay');
  return slot(
    'airPlayButton',
    <AirPlayButton className="plyr__controls__item plyr__control" data-plyr="airplay">
      <Icons.AirPlay />
      <span className="plyr__tooltip">{airPlayText}</span>
    </AirPlayButton>,
  );
}

PlyrAirPlayButton.displayName = 'PlyrAirPlayButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrCaptionsButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrCaptionsButton() {
  const { icons: Icons } = usePlyrLayoutContext(),
    enableText = usePlyrLayoutWord('Enable captions'),
    disableText = usePlyrLayoutWord('Disable captions');
  return slot(
    'captionsButton',
    <CaptionButton
      className="plyr__controls__item plyr__control"
      data-no-label
      data-plyr="captions"
    >
      <Icons.CaptionsOn className="icon--pressed" />
      <Icons.CaptionsOff className="icon--not-pressed" />
      <span className="label--pressed plyr__tooltip">{disableText}</span>
      <span className="label--not-pressed plyr__tooltip">{enableText}</span>
    </CaptionButton>,
  );
}

PlyrCaptionsButton.displayName = 'PlyrCaptionsButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrFullscreenButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrFullscreenButton() {
  const { icons: Icons } = usePlyrLayoutContext(),
    enterText = usePlyrLayoutWord('Enter Fullscreen'),
    exitText = usePlyrLayoutWord('Exit Fullscreen');
  return slot(
    'fullscreenButton',
    <FullscreenButton
      className="plyr__controls__item plyr__control"
      data-no-label
      data-plyr="fullscreen"
    >
      <Icons.EnterFullscreen className="icon--pressed" />
      <Icons.ExitFullscreen className="icon--not-pressed" />
      <span className="label--pressed plyr__tooltip">{exitText}</span>
      <span className="label--not-pressed plyr__tooltip">{enterText}</span>
    </FullscreenButton>,
  );
}

PlyrFullscreenButton.displayName = 'PlyrFullscreenButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrPIPButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrPIPButton() {
  const { icons: Icons } = usePlyrLayoutContext(),
    enterText = usePlyrLayoutWord('Enter PiP'),
    exitText = usePlyrLayoutWord('Exit PiP');
  return slot(
    'pipButton',
    <PIPButton className="plyr__controls__item plyr__control" data-no-label data-plyr="pip">
      <Icons.EnterPiP className="icon--pressed" />
      <Icons.ExitPiP className="icon--not-pressed" />
      <span className="label--pressed plyr__tooltip">{exitText}</span>
      <span className="label--not-pressed plyr__tooltip">{enterText}</span>
    </PIPButton>,
  );
}

PlyrPIPButton.displayName = 'PlyrPIPButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrMuteButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrMuteButton() {
  const { icons: Icons } = usePlyrLayoutContext(),
    muteText = usePlyrLayoutWord('Mute'),
    unmuteText = usePlyrLayoutWord('Unmute');
  return slot(
    'muteButton',
    <MuteButton className="plyr__control" data-no-label data-plyr="mute">
      <Icons.Muted className="icon--pressed" />
      <Icons.Volume className="icon--not-pressed" />
      <span className="label--pressed plyr__tooltip">{unmuteText}</span>
      <span className="label--not-pressed plyr__tooltip">{muteText}</span>
    </MuteButton>,
  );
}

PlyrMuteButton.displayName = 'PlyrMuteButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrPlayButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrPlayButton() {
  const { icons: Icons } = usePlyrLayoutContext(),
    playText = usePlyrLayoutWord('Play'),
    pauseText = usePlyrLayoutWord('Pause');
  return slot(
    'playButton',
    <PlayButton className="plyr__controls__item plyr__control" data-no-label data-plyr="play">
      <Icons.Pause className="icon--pressed" />
      <Icons.Play className="icon--not-pressed" />
      <span className="label--pressed plyr__tooltip">{pauseText}</span>
      <span className="label--not-pressed plyr__tooltip">{playText}</span>
    </PlayButton>,
  );
}

PlyrPlayButton.displayName = 'PlyrPlayButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrRestartButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrRestartButton() {
  const { icons: Icons } = usePlyrLayoutContext(),
    restartText = usePlyrLayoutWord('Restart'),
    remote = useMediaRemote();

  function onPress({ nativeEvent: event }: React.SyntheticEvent) {
    if (isKeyboardEvent(event) && !isKeyboardClick(event)) return;
    remote.seek(0, event);
  }

  return slot(
    'restartButton',
    <button
      type="button"
      className="plyr__control"
      data-plyr="restart"
      onPointerUp={onPress}
      onKeyDown={onPress}
    >
      <slot name="restart-icon" data-class=""></slot>
      <Icons.Restart />
      <span className="plyr__tooltip">{restartText}</span>
    </button>,
  );
}

PlyrRestartButton.displayName = 'PlyrRestartButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrFastForwardButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrFastForwardButton() {
  const { icons: Icons, seekTime } = usePlyrLayoutContext(),
    forwardText = usePlyrLayoutWord('Forward'),
    label = `${forwardText} ${seekTime}s`;
  return slot(
    'fastForwardButton',
    <SeekButton
      className="plyr__controls__item plyr__control"
      seconds={seekTime}
      data-no-label
      data-plyr="fast-forward"
    >
      <Icons.FastForward />
      <span className="plyr__tooltip">{label}</span>
    </SeekButton>,
  );
}

PlyrFastForwardButton.displayName = 'PlyrFastForwardButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrRewindButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrRewindButton() {
  const { icons: Icons, seekTime } = usePlyrLayoutContext(),
    rewindText = usePlyrLayoutWord('Rewind'),
    label = `${rewindText} ${seekTime}s`;
  return slot(
    'rewindButton',
    <SeekButton
      className="plyr__controls__item plyr__control"
      seconds={-1 * seekTime!}
      data-no-label
      data-plyr="rewind"
    >
      <Icons.Rewind />
      <span className="plyr__tooltip">{label}</span>
    </SeekButton>,
  );
}

PlyrRewindButton.displayName = 'PlyrRewindButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrTimeSlider
 * -----------------------------------------------------------------------------------------------*/

function PlyrTimeSlider() {
  const { markers, thumbnails, seekTime, previewTime } = usePlyrLayoutContext(),
    $src = useMediaState('source'),
    $duration = useMediaState('duration'),
    seekText = usePlyrLayoutWord('Seek'),
    [activeMarker, setActiveMarker] = React.useState<PlyrMarker | null>(null),
    $RemotionSliderThumbnail = useSignal(RemotionSliderThumbnail),
    $hasRemotionSliderThumbnail = $RemotionSliderThumbnail && isRemotionSource($src);

  function onSeekingRequest(time: number) {
    previewTime.set(time);
  }

  function onMarkerEnter(this: PlyrMarker) {
    setActiveMarker(this);
  }

  function onMarkerLeave() {
    setActiveMarker(null);
  }

  const markerLabel = activeMarker ? (
    <span
      className="plyr__progress__marker-label"
      dangerouslySetInnerHTML={{ __html: activeMarker.label + '<br />' }}
    ></span>
  ) : null;

  return slot(
    'timeSlider',
    <div className="plyr__controls__item plyr__progress__container">
      <div className="plyr__progress">
        <TimeSlider.Root
          className="plyr__slider"
          pauseWhileDragging
          keyStep={seekTime}
          aria-label={seekText}
          data-plyr="seek"
          onMediaSeekingRequest={onSeekingRequest}
        >
          <div className="plyr__slider__track"></div>
          <div className="plyr__slider__thumb"></div>
          <div className="plyr__slider__buffer"></div>

          {!thumbnails && !$hasRemotionSliderThumbnail ? (
            <span className="plyr__tooltip">
              {markerLabel}
              <TimeSlider.Value />
            </span>
          ) : $hasRemotionSliderThumbnail ? (
            <TimeSlider.Preview className="plyr__slider__preview">
              <div className="plyr__slider__preview__thumbnail">
                <span className="plyr__slider__preview__time-container">
                  {markerLabel}
                  <TimeSlider.Value className="plyr__slider__preview__time" />
                </span>
                <$RemotionSliderThumbnail className="plyr__slider__preview__thumbnail" />
              </div>
            </TimeSlider.Preview>
          ) : (
            <TimeSlider.Preview className="plyr__slider__preview">
              <TimeSlider.Thumbnail.Root
                src={thumbnails}
                className="plyr__slider__preview__thumbnail"
              >
                <span className="plyr__slider__preview__time-container">
                  {markerLabel}
                  <TimeSlider.Value className="plyr__slider__preview__time" />
                </span>
                <TimeSlider.Thumbnail.Img />
              </TimeSlider.Thumbnail.Root>
            </TimeSlider.Preview>
          )}

          {markers && Number.isFinite($duration)
            ? markers.map((marker, i) => (
                <span
                  className="plyr__progress__marker"
                  key={i}
                  onMouseEnter={onMarkerEnter.bind(marker)}
                  onMouseLeave={onMarkerLeave}
                  style={{ left: `${(marker.time / $duration) * 100}%` }}
                ></span>
              ))
            : null}
        </TimeSlider.Root>
      </div>
    </div>,
  );
}

PlyrTimeSlider.displayName = 'PlyrTimeSlider';

/* -------------------------------------------------------------------------------------------------
 * PlyrVolumeSlider
 * -----------------------------------------------------------------------------------------------*/

function PlyrVolumeSlider() {
  const volumeText = usePlyrLayoutWord('Volume');
  return slot(
    'volumeSlider',
    <VolumeSlider.Root className="plyr__slider" data-plyr="volume" aria-label={volumeText}>
      <div className="plyr__slider__track"></div>
      <div className="plyr__slider__thumb"></div>
    </VolumeSlider.Root>,
  );
}

PlyrVolumeSlider.displayName = 'PlyrVolumeSlider';

/* -------------------------------------------------------------------------------------------------
 * PlyrVolume
 * -----------------------------------------------------------------------------------------------*/

function PlyrVolume({ type }: { type: PlyrControl }) {
  const hasMuteButton = type === 'mute' || type === 'mute+volume',
    hasVolumeSlider = type === 'volume' || type === 'mute+volume';
  return (
    <div className="plyr__controls__item plyr__volume">
      {hasMuteButton ? <PlyrMuteButton /> : null}
      {hasVolumeSlider ? <PlyrVolumeSlider /> : null}
    </div>
  );
}

PlyrVolume.displayName = 'PlyrVolume';

/* -------------------------------------------------------------------------------------------------
 * PlyrCurrentTime
 * -----------------------------------------------------------------------------------------------*/

function PlyrCurrentTime() {
  const { invertTime, toggleTime, displayDuration } = usePlyrLayoutContext(),
    $streamType = useMediaState('streamType'),
    currentTimeText = usePlyrLayoutWord('Current time'),
    liveText = usePlyrLayoutWord('LIVE'),
    [invert, setInvert] = React.useState(invertTime),
    remainder = !displayDuration && invert;

  function onPress({ nativeEvent: event }: React.SyntheticEvent) {
    if (!toggleTime || displayDuration || (isKeyboardEvent(event) && !isKeyboardClick(event))) {
      return;
    }

    setInvert((n) => !n);
  }

  return slot(
    'currentTime',
    $streamType === 'live' || $streamType === 'll-live' ? (
      <LiveButton className="plyr__controls__item plyr__control plyr__live-button" data-plyr="live">
        <span className="plyr__live-button__text">{liveText}</span>
      </LiveButton>
    ) : (
      <>
        <Time
          type="current"
          className="plyr__controls__item plyr__time plyr__time--current"
          role="timer"
          aria-label={currentTimeText}
          tabIndex={0}
          remainder={remainder}
          onPointerUp={onPress}
          onKeyDown={onPress}
        />
        {displayDuration ? <PlyrDuration /> : null}
      </>
    ),
  );
}

PlyrCurrentTime.displayName = 'PlyrCurrentTime';

/* -------------------------------------------------------------------------------------------------
 * PlyrDuration
 * -----------------------------------------------------------------------------------------------*/

function PlyrDuration() {
  const durationText = usePlyrLayoutWord('Duration');
  return slot(
    'duration',
    <Time
      className="plyr__controls__item plyr__time plyr__time--duration"
      type="duration"
      role="timer"
      tabIndex={0}
      aria-label={durationText}
    />,
  );
}

PlyrDuration.displayName = 'PlyrDuration';

/* -------------------------------------------------------------------------------------------------
 * PlyrDownloadButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrDownloadButton() {
  const { download } = usePlyrLayoutContext(),
    $src = useMediaState('source'),
    $title = useMediaState('title'),
    file = getDownloadFile({
      title: $title,
      src: $src,
      download,
    }),
    downloadText = usePlyrLayoutWord('Download');

  return slot(
    'download',
    isString(file?.url) ? (
      <a
        className="plyr__controls__item plyr__control"
        href={appendParamsToURL(file.url, { download: file.name })}
        download={file.name}
        target="_blank"
      >
        <slot name="download-icon" />
        <span className="plyr__tooltip">{downloadText}</span>
      </a>
    ) : null,
  );
}

PlyrDownloadButton.displayName = 'PlyrDownloadButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrGestures
 * -----------------------------------------------------------------------------------------------*/

function PlyrGestures() {
  const { clickToPlay, clickToFullscreen } = usePlyrLayoutContext();
  return (
    <>
      {clickToPlay ? (
        <Gesture className="plyr__gesture" event="pointerup" action="toggle:paused" />
      ) : null}
      {clickToFullscreen ? (
        <Gesture className="plyr__gesture" event="dblpointerup" action="toggle:fullscreen" />
      ) : null}
    </>
  );
}

PlyrGestures.displayName = 'PlyrGestures';

/* -------------------------------------------------------------------------------------------------
 * PlyrCaptions
 * -----------------------------------------------------------------------------------------------*/

function PlyrCaptions() {
  const $track = useMediaState('textTrack'),
    [activeCue, setActiveCue] = React.useState<VTTCue | null>(null);

  React.useEffect(() => {
    if (!$track) return;

    function onCueChange() {
      setActiveCue($track ? $track.activeCues[0] : null);
    }

    onCueChange();
    return listenEvent($track, 'cue-change', onCueChange);
  }, [$track]);

  return (
    <div className="plyr__captions" dir="auto">
      <span
        className="plyr__caption"
        dangerouslySetInnerHTML={{
          __html: activeCue?.text || '',
        }}
      />
    </div>
  );
}

PlyrCaptions.displayName = 'PlyrCaptions';

/* -------------------------------------------------------------------------------------------------
 * PlyrSettings
 * -----------------------------------------------------------------------------------------------*/

function PlyrSettings() {
  const { icons: Icons } = usePlyrLayoutContext(),
    settingsText = usePlyrLayoutWord('Settings');
  return slot(
    'settings',
    <div className="plyr__controls__item plyr__menu">
      <Menu.Root>
        <Menu.Button className="plyr__control" data-plyr="settings">
          {slot(
            'settingsButton',
            <>
              <Icons.Settings />
              <span className="plyr__tooltip">{settingsText}</span>
            </>,
          )}
        </Menu.Button>
        <Menu.Items className="plyr__menu__container" placement="top end">
          <div>
            <div>
              {slot(
                'settingsMenu',
                <>
                  <PlyrAudioMenu />
                  <PlyrCaptionsMenu />
                  <PlyrQualityMenu />
                  <PlyrSpeedMenu />
                </>,
              )}
            </div>
          </div>
        </Menu.Items>
      </Menu.Root>
    </div>,
  );
}

PlyrSettings.displayName = 'PlyrSettings';

/* -------------------------------------------------------------------------------------------------
 * PlyrMenuButton
 * -----------------------------------------------------------------------------------------------*/

function PlyrMenuButton({
  label,
  hint,
  open,
  disabled,
}: {
  label: PlyrLayoutWord;
  hint?: string;
  open: boolean;
  disabled: boolean;
}) {
  const buttonText = usePlyrLayoutWord(label),
    goBackText = usePlyrLayoutWord('Go back to previous menu');
  return (
    <Menu.Button
      className={`plyr__control plyr__control--${open ? 'back' : 'forward'}`}
      data-plyr="settings"
      disabled={disabled}
    >
      <span className="plyr__menu__label" aria-hidden={open ? 'true' : undefined}>
        {buttonText}
      </span>
      {hint ? <span className="plyr__menu__value">{hint}</span> : null}
      {open ? <span className="plyr__sr-only">{goBackText}</span> : null}
    </Menu.Button>
  );
}

PlyrMenuButton.displayName = 'PlyrMenuButton';

/* -------------------------------------------------------------------------------------------------
 * PlyrMenu
 * -----------------------------------------------------------------------------------------------*/

function PlyrMenu({
  label,
  hint,
  children,
  disabled,
}: {
  label: PlyrLayoutWord;
  hint?: string;
  disabled;
  children: React.ReactNode;
}) {
  const [open, setOpen] = React.useState(false);

  function onOpen() {
    setOpen(true);
  }

  function onClose() {
    setOpen(false);
  }

  return (
    <Menu.Root onOpen={onOpen} onClose={onClose}>
      <PlyrMenuButton label={label} open={open} hint={hint} disabled={disabled} />
      <Menu.Items>{children}</Menu.Items>
    </Menu.Root>
  );
}

PlyrMenu.displayName = 'PlyrMenu';

/* -------------------------------------------------------------------------------------------------
 * PlyrAudioMenu
 * -----------------------------------------------------------------------------------------------*/

function PlyrAudioMenu() {
  const defaultText = usePlyrLayoutWord('Default'),
    $track = useMediaState('audioTrack'),
    options = useAudioOptions();
  return (
    <PlyrMenu label="Audio" hint={$track?.label ?? defaultText} disabled={options.disabled}>
      <Menu.RadioGroup value={options.selectedValue}>
        {options.map(({ label, value, select }) => (
          <Menu.Radio className="plyr__control" value={value} onSelect={select} key={value}>
            <span>{label}</span>
          </Menu.Radio>
        ))}
      </Menu.RadioGroup>
    </PlyrMenu>
  );
}

PlyrAudioMenu.displayName = 'PlyrAudioMenu';

/* -------------------------------------------------------------------------------------------------
 * PlyrSpeedMenu
 * -----------------------------------------------------------------------------------------------*/

function PlyrSpeedMenu() {
  const normalLabel = usePlyrLayoutWord('Normal'),
    options = usePlaybackRateOptions({ normalLabel }),
    hint = options.selectedValue === '1' ? normalLabel : options.selectedValue + 'x';
  return (
    <PlyrMenu label="Speed" hint={hint} disabled={options.disabled}>
      <Menu.RadioGroup value={options.selectedValue}>
        {options.map(({ label, value, select }) => (
          <Menu.Radio className="plyr__control" value={value} onSelect={select} key={value}>
            <span>{label}</span>
          </Menu.Radio>
        ))}
      </Menu.RadioGroup>
    </PlyrMenu>
  );
}

PlyrSpeedMenu.displayName = 'PlyrSpeedMenu';

/* -------------------------------------------------------------------------------------------------
 * PlyrCaptionsMenu
 * -----------------------------------------------------------------------------------------------*/

function PlyrCaptionsMenu() {
  const offText = usePlyrLayoutWord('Disabled'),
    options = useCaptionOptions({ off: offText }),
    hint = options.selectedTrack?.label ?? offText;
  return (
    <PlyrMenu label="Captions" hint={hint} disabled={options.disabled}>
      <Menu.RadioGroup value={options.selectedValue}>
        {options.map(({ label, value, select }) => (
          <Menu.Radio className="plyr__control" value={value} onSelect={select} key={value}>
            <span>{label}</span>
          </Menu.Radio>
        ))}
      </Menu.RadioGroup>
    </PlyrMenu>
  );
}

PlyrCaptionsMenu.displayName = 'PlyrCaptionsMenu';

/* -------------------------------------------------------------------------------------------------
 * PlyrQualityMenu
 * -----------------------------------------------------------------------------------------------*/

function PlyrQualityMenu() {
  const autoText = usePlyrLayoutWord('Auto'),
    options = useVideoQualityOptions({ auto: autoText, sort: 'descending' }),
    currentQuality = options.selectedQuality?.height,
    hint =
      options.selectedValue !== 'auto' && currentQuality
        ? `${currentQuality}p`
        : `${autoText}${currentQuality ? ` (${currentQuality}p)` : ''}`;
  return (
    <PlyrMenu label="Quality" hint={hint} disabled={options.disabled}>
      <Menu.RadioGroup value={options.selectedValue}>
        {options.map(({ label, value, select }) => (
          <Menu.Radio className="plyr__control" value={value} onSelect={select} key={value}>
            <span>{label}</span>
          </Menu.Radio>
        ))}
      </Menu.RadioGroup>
    </PlyrMenu>
  );
}

PlyrQualityMenu.displayName = 'PlyrQualityMenu';
</file>

<file path="components/layouts/plyr/props.ts">
import type {
  FileDownloadInfo,
  PlyrControl,
  PlyrLayoutTranslations,
  PlyrMarker,
  ThumbnailSrc,
} from 'vidstack';

import type { PlyrLayoutIcons } from './icons';
import type { PlyrLayoutSlots } from './slots';

export const defaultPlyrLayoutProps: Omit<PlyrLayoutProps, 'icons' | 'slots' | 'posterFrame'> = {
  clickToPlay: true,
  clickToFullscreen: true,
  controls: [
    'play-large',
    'play',
    'progress',
    'current-time',
    'mute+volume',
    'captions',
    'settings',
    'pip',
    'airplay',
    'fullscreen',
  ],
  displayDuration: false,
  download: null,
  markers: null,
  invertTime: true,
  thumbnails: null,
  toggleTime: true,
  translations: null,
  seekTime: 10,
  speed: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4],
};

export interface PlyrLayoutProps {
  /**
   * The icons to be rendered and displayed inside the layout.
   */
  icons: PlyrLayoutIcons;
  /**
   * The frame of the video to use as the poster. This only works with Remotion sources at the
   * moment.
   */
  posterFrame?: number;
  /**
   * Press the video container to toggle play/pause.
   */
  clickToPlay?: boolean;
  /**
   * Double-press the video container to toggle fullscreen.
   */
  clickToFullscreen?: boolean;
  /**
   * The controls to be included in the layout and their order specified by the position in the
   * array.
   */
  controls?: PlyrControl[];
  /**
   * Whether the duration should be displayed. This is ignored if `toggleTime` is `true`.
   */
  displayDuration?: boolean;
  /**
   * Sets the download URL and filename for the download button. The download button must be
   * included in the `controls` prop for this to take effect.
   */
  download?: FileDownloadInfo;
  /**
   * Points on the time slider which should be visually marked for the user.
   */
  markers?: PlyrMarker[] | null;
  /**
   * Display the current time as a countdown rather than an incremental counter.
   */
  invertTime?: boolean;
  /**
   * The thumbnails resource.
   *
   * @see {@link https://www.vidstack.io/docs/wc/player/core-concepts/loading#thumbnails}
   */
  thumbnails?: ThumbnailSrc;
  /**
   * Allow users to press to toggle the inverted time.
   */
  toggleTime?: boolean;
  /**
   * Translation map from english to your desired language for words used throughout the layout.
   */
  translations?: Partial<PlyrLayoutTranslations> | null;
  /**
   * The time, in seconds, to seek when a user hits fast forward or rewind.
   */
  seekTime?: number;
  /**
   * The speed options to display in the UI.
   */
  speed?: (string | number)[];
  /**
   * Provide additional content to be inserted in specific positions.
   */
  slots?: PlyrLayoutSlots;
}
</file>

<file path="components/layouts/plyr/slots.tsx">
import * as React from 'react';

import { isUndefined, uppercaseFirstChar } from 'maverick.js/std';

import { usePlyrLayoutContext } from './context';

export type SlotPositions<Name extends string> =
  | `before${Capitalize<Name>}`
  | Name
  | `after${Capitalize<Name>}`;

export type Slots<Names extends string> = {
  [slotName in SlotPositions<Names>]?: React.ReactNode;
};

export type PlyrLayoutSlotName =
  | 'airPlayButton'
  | 'captionsButton'
  | 'currentTime'
  | 'download'
  | 'duration'
  | 'fastForwardButton'
  | 'fullscreenButton'
  | 'liveButton'
  | 'muteButton'
  | 'pipButton'
  | 'playButton'
  | 'playLargeButton'
  | 'poster'
  | 'restartButton'
  | 'rewindButton'
  | 'rewindButton'
  | 'settings'
  | 'settingsButton'
  | 'timeSlider'
  | 'volumeSlider'
  | 'settingsMenu';

export interface PlyrLayoutSlots extends Slots<PlyrLayoutSlotName> {}

export function slot(name: PlyrLayoutSlotName, defaultValue: React.ReactNode): React.ReactNode {
  const { slots } = usePlyrLayoutContext(),
    slot = slots?.[name],
    capitalizedName = uppercaseFirstChar(name as string);
  return (
    <>
      {slots?.[`before${capitalizedName}`]}
      {isUndefined(slot) ? defaultValue : slot}
      {slots?.[`after${capitalizedName}`]}
    </>
  );
}
</file>

<file path="components/layouts/remotion-ui.ts">
import { signal } from 'maverick.js';

export const RemotionThumbnail = /* @__PURE__ */ signal<React.LazyExoticComponent<
  React.ComponentType<any>
> | null>(null);

export const RemotionSliderThumbnail = /* @__PURE__ */ signal<React.LazyExoticComponent<
  React.ComponentType<any>
> | null>(null);

export const RemotionPoster = /* @__PURE__ */ signal<React.LazyExoticComponent<
  React.ComponentType<any>
> | null>(null);
</file>

<file path="components/layouts/utils.ts">
import * as React from 'react';

import { effect } from 'maverick.js';

import { useMediaPlayer } from '../../hooks/use-media-player';

export function useLayoutName(name: string) {
  const player = useMediaPlayer();
  React.useEffect(() => {
    if (!player) return;
    return effect(() => {
      const el = player.$el;
      el?.setAttribute('data-layout', name);
      return () => el?.removeAttribute('data-layout');
    });
  }, [player]);
}
</file>

<file path="components/player-callbacks.ts">
import type { InferComponentEvents } from 'maverick.js';
import type { ReactEventCallbacks } from 'maverick.js/react';

import type { MediaPlayerInstance } from './primitives/instances';

type PlayerCallbacks = keyof ReactEventCallbacks<InferComponentEvents<MediaPlayerInstance>>;

export const playerCallbacks: PlayerCallbacks[] = [
  'onAbort',
  'onAudioTrackChange',
  'onAudioTracksChange',
  'onAutoPlay',
  'onAutoPlayChange',
  'onAutoPlayFail',
  'onCanLoad',
  'onCanPlay',
  'onCanPlayThrough',
  'onControlsChange',
  'onDestroy',
  'onDurationChange',
  'onEmptied',
  'onEnd',
  'onEnded',
  'onError',
  'onFindMediaPlayer',
  'onFullscreenChange',
  'onFullscreenError',
  'onLiveChange',
  'onLiveEdgeChange',
  'onLoadedData',
  'onLoadedMetadata',
  'onLoadStart',
  'onLoopChange',
  'onOrientationChange',
  'onPause',
  'onPictureInPictureChange',
  'onPictureInPictureError',
  'onPlay',
  'onPlayFail',
  'onPlaying',
  'onPlaysInlineChange',
  'onPosterChange',
  'onProgress',
  'onProviderChange',
  'onProviderLoaderChange',
  'onProviderSetup',
  'onQualitiesChange',
  'onQualityChange',
  'onRateChange',
  'onReplay',
  'onSeeked',
  'onSeeking',
  'onSourceChange',
  'onSourceChange',
  'onStalled',
  'onStarted',
  'onStreamTypeChange',
  'onSuspend',
  'onTextTrackChange',
  'onTextTracksChange',
  'onTimeUpdate',
  'onTitleChange',
  'onVdsLog',
  'onVideoPresentationChange',
  'onVolumeChange',
  'onWaiting',
];
</file>

<file path="components/player.tsx">
import * as React from 'react';

import { createReactComponent, type ReactElementProps } from 'maverick.js/react';
import type { MediaSrc } from 'vidstack';

import type { PlayerSrc } from '../source';
import { playerCallbacks } from './player-callbacks';
import { MediaPlayerInstance } from './primitives/instances';
import { Primitive } from './primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * MediaPlayer
 * -----------------------------------------------------------------------------------------------*/

const MediaPlayerBridge = createReactComponent(MediaPlayerInstance, {
  events: playerCallbacks,
  eventsRegex: /^onHls/,
  domEventsRegex: /^onMedia/,
});

export interface MediaPlayerProps extends Omit<ReactElementProps<MediaPlayerInstance>, 'src'> {
  /**
   * The URL or object of the current media resource/s to be considered for playback.
   *
   * @see {@link https://vidstack.io/docs/player/core-concepts/loading#sources}
   */
  src?: PlayerSrc;
  aspectRatio?: string;
  asChild?: boolean;
  children: React.ReactNode;
  ref?: React.Ref<MediaPlayerInstance>;
}

/**
 * All media components exist inside the `<MediaPlayer>` component. This component's main
 * responsibilities are to manage media state updates, dispatch media events, handle media
 * requests, and expose media state through HTML attributes and CSS properties for styling
 * purposes.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/media/player}
 * @example
 * ```tsx
 * <MediaPlayer src="...">
 *   <MediaProvider />
 * </MediaPlayer>
 * ```
 */
const MediaPlayer = React.forwardRef<MediaPlayerInstance, MediaPlayerProps>(
  ({ aspectRatio, children, ...props }, forwardRef) => {
    return (
      <MediaPlayerBridge
        {...props}
        src={props.src as MediaSrc}
        ref={forwardRef}
        style={{
          aspectRatio,
          ...props.style,
        }}
      >
        {(props) => <Primitive.div {...props}>{children}</Primitive.div>}
      </MediaPlayerBridge>
    );
  },
);

MediaPlayer.displayName = 'MediaPlayer';
export { MediaPlayer };
</file>

<file path="components/primitives/instances.ts">
import {
  AirPlayButton,
  AudioGainSlider,
  CaptionButton,
  Captions,
  Controls,
  ControlsGroup,
  FullscreenButton,
  Gesture,
  GoogleCastButton,
  LiveButton,
  MediaAnnouncer,
  MediaPlayer,
  MediaProvider,
  Menu,
  MenuButton,
  MenuItem,
  MenuItems,
  MenuPortal,
  MuteButton,
  PIPButton,
  PlayButton,
  Poster,
  QualitySlider,
  Radio,
  RadioGroup,
  SeekButton,
  Slider,
  SliderChapters,
  SliderPreview,
  SliderThumbnail,
  SliderValue,
  SliderVideo,
  SpeedSlider,
  Thumbnail,
  Time,
  TimeSlider,
  ToggleButton,
  Tooltip,
  TooltipContent,
  TooltipTrigger,
  VolumeSlider,
} from 'vidstack';

// Core
export class MediaPlayerInstance extends MediaPlayer {}
export class MediaProviderInstance extends MediaProvider {}
export class MediaAnnouncerInstance extends MediaAnnouncer {}
// Controls
export class ControlsInstance extends Controls {}
export class ControlsGroupInstance extends ControlsGroup {}
// Buttons
export class ToggleButtonInstance extends ToggleButton {}
export class CaptionButtonInstance extends CaptionButton {}
export class FullscreenButtonInstance extends FullscreenButton {}
export class LiveButtonInstance extends LiveButton {}
export class MuteButtonInstance extends MuteButton {}
export class PIPButtonInstance extends PIPButton {}
export class PlayButtonInstance extends PlayButton {}
export class AirPlayButtonInstance extends AirPlayButton {}
export class GoogleCastButtonInstance extends GoogleCastButton {}
export class SeekButtonInstance extends SeekButton {}
// Tooltip
export class TooltipInstance extends Tooltip {}
export class TooltipTriggerInstance extends TooltipTrigger {}
export class TooltipContentInstance extends TooltipContent {}
// Sliders
export class SliderInstance extends Slider {}
export class TimeSliderInstance extends TimeSlider {}
export class VolumeSliderInstance extends VolumeSlider {}
export class AudioGainSliderInstance extends AudioGainSlider {}
export class SpeedSliderInstance extends SpeedSlider {}
export class QualitySliderInstance extends QualitySlider {}
export class SliderThumbnailInstance extends SliderThumbnail {}
export class SliderValueInstance extends SliderValue {}
export class SliderVideoInstance extends SliderVideo {}
export class SliderPreviewInstance extends SliderPreview {}
export class SliderChaptersInstance extends SliderChapters {}
// Menus
export class MenuInstance extends Menu {}
export class MenuButtonInstance extends MenuButton {}
export class MenuItemsInstance extends MenuItems {}
export class MenuItemInstance extends MenuItem {}
export class MenuPortalInstance extends MenuPortal {}
export class RadioGroupInstance extends RadioGroup {}
export class RadioInstance extends Radio {}
// Display
export class CaptionsInstance extends Captions {}
export class GestureInstance extends Gesture {}
export class PosterInstance extends Poster {}
export class ThumbnailInstance extends Thumbnail {}
export class TimeInstance extends Time {}
</file>

<file path="components/primitives/nodes.tsx">
/* -------------------------------------------------------------------------------------------------
 * Credit: https://github.com/radix-ui/primitives/blob/main/packages/react/primitive/src/Primitive.tsx
 * -----------------------------------------------------------------------------------------------*/

import * as React from 'react';

import { Slot } from './slot';

/* -------------------------------------------------------------------------------------------------
 * Primitive
 * -----------------------------------------------------------------------------------------------*/

const NODES = ['button', 'div', 'span', 'img', 'video', 'audio'] as const;

export const Primitive = NODES.reduce((primitives, node) => {
  const Node = React.forwardRef((props: PrimitivePropsWithRef<typeof node>, forwardedRef: any) => {
    const { asChild, ...primitiveProps } = props;
    const Comp: any = asChild ? Slot : node;
    return <Comp {...primitiveProps} ref={forwardedRef} />;
  });

  Node.displayName = `Primitive.${node}`;

  return { ...primitives, [node]: Node };
}, {} as Primitives);

/* -------------------------------------------------------------------------------------------------
 * Types
 * -----------------------------------------------------------------------------------------------*/

// Temporary while we await merge of this fix:
// https://github.com/DefinitelyTyped/DefinitelyTyped/pull/55396
type PropsWithoutRef<P> = P extends any
  ? 'ref' extends keyof P
    ? Pick<P, Exclude<keyof P, 'ref'>>
    : P
  : P;

export type ComponentPropsWithoutRef<T extends React.ElementType> = PropsWithoutRef<
  React.ComponentProps<T>
>;

type Primitives = { [E in (typeof NODES)[number]]: PrimitiveForwardRefComponent<E> };

export type PrimitivePropsWithRef<E extends React.ElementType> = Omit<
  React.ComponentProps<E>,
  'style'
> &
  React.Attributes & {
    asChild?: boolean;
    style?:
      | React.CSSProperties
      | (React.CSSProperties & Record<`--${string}`, string | null | undefined>)
      | undefined;
  };

interface PrimitiveForwardRefComponent<E extends React.ElementType>
  extends React.ForwardRefExoticComponent<PrimitivePropsWithRef<E>> {}
</file>

<file path="components/primitives/slot.tsx">
/* -------------------------------------------------------------------------------------------------
 * Credit: https://github.com/radix-ui/primitives/blob/main/packages/react/slot/src/Slot.tsx
 * -----------------------------------------------------------------------------------------------*/

import * as React from 'react';
import { composeRefs } from 'maverick.js/react';

/* -------------------------------------------------------------------------------------------------
 * Slot
 * -----------------------------------------------------------------------------------------------*/

interface SlotProps extends React.HTMLAttributes<HTMLElement> {
  children?: React.ReactNode;
}

const Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = React.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);

  if (slottable) {
    // the new element to render is the one passed as a child of `Slottable`
    const newElement = slottable.props.children as React.ReactNode;

    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        // because the new element will be the one rendered, we are only interested
        // in grabbing its children (`newElement.props.children`)
        if (React.Children.count(newElement) > 1) return React.Children.only(null);
        return React.isValidElement(newElement)
          ? (newElement.props.children as React.ReactNode)
          : null;
      } else {
        return child;
      }
    });

    return (
      <SlotClone {...slotProps} ref={forwardedRef}>
        {React.isValidElement(newElement)
          ? React.cloneElement(newElement, undefined, newChildren)
          : null}
      </SlotClone>
    );
  }

  return (
    <SlotClone {...slotProps} ref={forwardedRef}>
      {children}
    </SlotClone>
  );
});

Slot.displayName = 'Slot';

/* -------------------------------------------------------------------------------------------------
 * SlotClone
 * -----------------------------------------------------------------------------------------------*/

interface SlotCloneProps {
  children: React.ReactNode;
}

const SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {
  const { children, ...slotProps } = props;

  if (React.isValidElement(children)) {
    return React.cloneElement<any>(children, {
      ...mergeProps(slotProps, children.props),
      ref: forwardedRef ? composeRefs(forwardedRef, (children as any).ref) : (children as any).ref,
    });
  }

  return React.Children.count(children) > 1 ? React.Children.only(null) : null;
});

SlotClone.displayName = 'SlotClone';

/* -------------------------------------------------------------------------------------------------
 * Slottable
 * -----------------------------------------------------------------------------------------------*/

const Slottable = ({ children }: { children: React.ReactNode }) => {
  return <>{children}</>;
};

/* ---------------------------------------------------------------------------------------------- */

type AnyProps = Record<string, any>;

function isSlottable(child: React.ReactNode): child is React.ReactElement {
  return React.isValidElement(child) && child.type === Slottable;
}

function mergeProps(slotProps: AnyProps, childProps: AnyProps) {
  // all child props should override
  const overrideProps = { ...childProps };

  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];

    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      // if the handler exists on both, we compose them
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args: unknown[]) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      }
      // but if it exists only on the slot, we use only this one
      else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    }
    // if it's `style`, we merge them
    else if (propName === 'style') {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === 'className') {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');
    }
  }

  return { ...slotProps, ...overrideProps };
}

const Root = Slot;

export { Slot, Slottable, Root };
export type { SlotProps };
</file>

<file path="components/provider.tsx">
import * as React from 'react';

import {
  createReactComponent,
  useSignal,
  useStateContext,
  type ReactElementProps,
} from 'maverick.js/react';
import { isString } from 'maverick.js/std';
import { mediaState, type MediaProviderLoader } from 'vidstack';

import { useMediaContext } from '../hooks/use-media-context';
import { Icon } from '../icon';
import { isRemotionProvider } from '../providers/remotion/type-check';
import { MediaProviderInstance } from './primitives/instances';

/* -------------------------------------------------------------------------------------------------
 * MediaProvider
 * -----------------------------------------------------------------------------------------------*/

const MediaProviderBridge = createReactComponent(MediaProviderInstance);

export interface MediaProviderProps
  extends Omit<ReactElementProps<MediaProviderInstance>, 'loaders'> {
  loaders?: Array<{ new (): MediaProviderLoader }>;
  iframeProps?: React.IframeHTMLAttributes<HTMLIFrameElement>;
  mediaProps?: React.HTMLAttributes<HTMLMediaElement>;
  children?: React.ReactNode;
  ref?: React.Ref<MediaProviderInstance>;
}

/**
 * Renders the current provider at this component location.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/media/provider}
 * @example
 * ```tsx
 * <MediaPlayer src="...">
 *   <MediaProvider />
 * </MediaPlayer>
 * ```
 */
const MediaProvider = React.forwardRef<MediaProviderInstance, MediaProviderProps>(
  ({ loaders = [], children, iframeProps, mediaProps, ...props }, forwardRef) => {
    const reactLoaders = React.useMemo(() => loaders.map((Loader) => new Loader()), loaders);

    return (
      <MediaProviderBridge {...props} loaders={reactLoaders} ref={forwardRef}>
        {(props, instance) => (
          <div {...props}>
            <MediaOutlet provider={instance} mediaProps={mediaProps} iframeProps={iframeProps} />
            {children}
          </div>
        )}
      </MediaProviderBridge>
    );
  },
);

MediaProvider.displayName = 'MediaProvider';
export { MediaProvider };

/* -------------------------------------------------------------------------------------------------
 * MediaOutlet
 * -----------------------------------------------------------------------------------------------*/

interface MediaOutletProps {
  provider: MediaProviderInstance;
  mediaProps?: React.HTMLAttributes<HTMLMediaElement>;
  iframeProps?: React.IframeHTMLAttributes<HTMLIFrameElement>;
}

function MediaOutlet({ provider, mediaProps, iframeProps }: MediaOutletProps) {
  const { sources, crossOrigin, poster, remotePlaybackInfo, nativeControls, viewType } =
      useStateContext(mediaState),
    { loader } = provider.$state,
    { $provider: $$provider, $providerSetup: $$providerSetup } = useMediaContext(),
    $sources = useSignal(sources),
    $nativeControls = useSignal(nativeControls),
    $crossOrigin = useSignal(crossOrigin),
    $poster = useSignal(poster),
    $loader = useSignal(loader),
    $provider = useSignal($$provider),
    $providerSetup = useSignal($$providerSetup),
    $remoteInfo = useSignal(remotePlaybackInfo),
    $mediaType = $loader?.mediaType(),
    $viewType = useSignal(viewType),
    isAudioView = $viewType === 'audio',
    isYouTubeEmbed = $loader?.name === 'youtube',
    isVimeoEmbed = $loader?.name === 'vimeo',
    isEmbed = isYouTubeEmbed || isVimeoEmbed,
    isRemotion = $loader?.name === 'remotion',
    isGoogleCast = $loader?.name === 'google-cast',
    [googleCastIconPaths, setGoogleCastIconPaths] = React.useState(''),
    [hasMounted, setHasMounted] = React.useState(false);

  React.useEffect(() => {
    if (!isGoogleCast || googleCastIconPaths) return;
    import('media-icons/dist/icons/chromecast.js').then((mod) => {
      setGoogleCastIconPaths(mod.default);
    });
  }, [isGoogleCast]);

  React.useEffect(() => {
    setHasMounted(true);
  }, []);

  if (isGoogleCast) {
    return (
      <div
        className="vds-google-cast"
        ref={(el) => {
          provider.load(el);
        }}
      >
        <Icon paths={googleCastIconPaths} />
        {$remoteInfo?.deviceName ? (
          <span className="vds-google-cast-info">
            Google Cast on{' '}
            <span className="vds-google-cast-device-name">{$remoteInfo.deviceName}</span>
          </span>
        ) : null}
      </div>
    );
  }

  if (isRemotion) {
    return (
      <div data-remotion-canvas>
        <div
          data-remotion-container
          ref={(el) => {
            provider.load(el);
          }}
        >
          {isRemotionProvider($provider) && $providerSetup
            ? React.createElement($provider.render)
            : null}
        </div>
      </div>
    );
  }

  return isEmbed
    ? React.createElement(
        React.Fragment,
        null,
        React.createElement('iframe', {
          ...iframeProps,
          className:
            (iframeProps?.className ? `${iframeProps.className} ` : '') + isYouTubeEmbed
              ? 'vds-youtube'
              : 'vds-vimeo',
          suppressHydrationWarning: true,
          tabIndex: !$nativeControls ? -1 : undefined,
          'aria-hidden': 'true',
          'data-no-controls': !$nativeControls ? '' : undefined,
          ref(el: HTMLElement) {
            provider.load(el);
          },
        }),
        !$nativeControls && !isAudioView
          ? React.createElement('div', { className: 'vds-blocker' })
          : null,
      )
    : $mediaType
      ? React.createElement($mediaType === 'audio' ? 'audio' : 'video', {
          ...mediaProps,
          controls: $nativeControls ? true : null,
          crossOrigin: typeof $crossOrigin === 'boolean' ? '' : $crossOrigin,
          poster: $mediaType === 'video' && $nativeControls && $poster ? $poster : null,
          suppressHydrationWarning: true,
          children: !hasMounted
            ? $sources.map(({ src, type }) =>
                isString(src) ? (
                  <source src={src} type={type !== '?' ? type : undefined} key={src} />
                ) : null,
              )
            : null,
          ref(el: HTMLMediaElement) {
            provider.load(el);
          },
        })
      : null;
}

MediaOutlet.displayName = 'MediaOutlet';
</file>

<file path="components/text-track.tsx">
import type { CaptionsFileFormat, CaptionsParserFactory } from 'media-captions';
import type { VTTContent } from 'vidstack';

import { createTextTrack } from '../hooks/create-text-track';

/**
 * Creates a new `TextTrack` object and adds it to the player.
 *
 * @see {@link https://www.vidstack.io/docs/player/api/text-tracks}
 * @example
 * ```tsx
 * <MediaPlayer>
 *   <MediaProvider>
 *     <Track
 *       src="english.vtt"
 *       kind="subtitles"
 *       label="English"
 *       lang="en-US"
 *       default
 *     />
 *   </MediaProvider>
 * </MediaPlayer>
 * ```
 */
function Track({ lang, ...props }: TrackProps) {
  createTextTrack({ language: lang, ...props });
  return null;
}

export interface TrackProps {
  /**
   * A unique identifier.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrack/id}
   */
  readonly id?: string;
  /**
   * URL of the text track resource. This attribute must be specified and its URL value must have
   * the same origin as the document  unless the <audio> or <video> parent element of the track
   * element has a `crossorigin` attribute.
   */
  readonly src?: string;
  /**
   * Used to directly pass in text track file contents.
   */
  readonly content?: string | VTTContent;
  /**
   * The captions file format to be parsed or a custom parser factory (functions that returns a
   * captions parser). Supported types include: 'vtt', 'srt', 'ssa', 'ass', and 'json'.
   *
   * @defaultValue 'vtt'
   */
  readonly type?: 'json' | CaptionsFileFormat | CaptionsParserFactory;
  /**
   * The text encoding type to be used when decoding data bytes to text.
   *
   * @defaultValue 'utf-8'
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Encoding_API/Encodings}
   *
   */
  readonly encoding?: string;
  /**
   * Indicates that the track should be enabled unless the user's preferences indicate that
   * another track is more appropriate. This may only be used on one track element per media
   * element.
   *
   * @defaultValue false
   */
  readonly default?: boolean;
  /**
   * The kind of text track this object represents. This decides how the track will be handled
   * by the player.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrack/kind}
   */
  readonly kind: TextTrackKind;
  /**
   * A human-readable label for the text track. This will be displayed to the user.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrack/label}
   */
  readonly label?: string;
  /**
   * A string containing a language identifier. For example, `"en-US"` for United States English
   * or `"pt-BR"` for Brazilian Portuguese.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrack/language}
   * @see {@link https://datatracker.ietf.org/doc/html/rfc5646}
   */
  readonly language?: string;
  /**
   * A string containing a language identifier. For example, `"en-US"` for United States English
   * or `"pt-BR"` for Brazilian Portuguese. This is a short alias for `language`.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrack/language}
   * @see {@link https://datatracker.ietf.org/doc/html/rfc5646}
   */
  readonly lang?: TrackProps['language'];
  /**
   * React list key.
   */
  readonly key?: string;
}

Track.displayName = 'Track';
export { Track };
</file>

<file path="components/ui/buttons/airplay-button.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { AirPlayButtonInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * AirPlayButton
 * -----------------------------------------------------------------------------------------------*/

const AirPlayButtonBridge = createReactComponent(AirPlayButtonInstance, {
  domEventsRegex: /^onMedia/,
});

export interface AirPlayButtonProps
  extends ReactElementProps<AirPlayButtonInstance, HTMLButtonElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * A button for requesting to connect to Apple AirPlay.
 *
 * @see {@link https://www.apple.com/au/airplay}
 * @docs {@link https://www.vidstack.io/docs/player/components/buttons/airplay-button}
 * @example
 * ```tsx
 * <AirPlayButton>
 *   <AirPlayIcon />
 * </AirPlayButton>
 * ```
 */
const AirPlayButton = React.forwardRef<HTMLButtonElement, AirPlayButtonProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <AirPlayButtonBridge {...(props as Omit<AirPlayButtonProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </AirPlayButtonBridge>
    );
  },
);

AirPlayButton.displayName = 'AirPlayButton';
export { AirPlayButton };
</file>

<file path="components/ui/buttons/caption-button.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { CaptionButtonInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * CaptionButton
 * -----------------------------------------------------------------------------------------------*/

const CaptionButtonBridge = createReactComponent(CaptionButtonInstance, {
  domEventsRegex: /^onMedia/,
});

export interface CaptionButtonProps
  extends ReactElementProps<CaptionButtonInstance, HTMLButtonElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * A button for toggling the showing state of the captions.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/buttons/caption-button}
 * @example
 * ```tsx
 * const track = useMediaState('textTrack'),
 *   isOn = track && isTrackCaptionKind(track);
 *
 * <CaptionButton>
 *   {isOn ? <OnIcon /> : <OffIcon />}
 * </CaptionButton>
 * ```
 */
const CaptionButton = React.forwardRef<HTMLButtonElement, CaptionButtonProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <CaptionButtonBridge {...(props as Omit<CaptionButtonProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </CaptionButtonBridge>
    );
  },
);

CaptionButton.displayName = 'CaptionButton';
export { CaptionButton };
</file>

<file path="components/ui/buttons/fullscreen-button.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { FullscreenButtonInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * FullscreenButton
 * -----------------------------------------------------------------------------------------------*/

const FullscreenButtonBridge = createReactComponent(FullscreenButtonInstance, {
  domEventsRegex: /^onMedia/,
});

export interface FullscreenButtonProps
  extends ReactElementProps<FullscreenButtonInstance, HTMLButtonElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * A button for toggling the fullscreen mode of the player.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/buttons/fullscreen-button}
 * @see {@link https://www.vidstack.io/docs/player/api/fullscreen}
 * @example
 * ```tsx
 * const isActive = useMediaState('fullscreen');
 *
 * <FullscreenButton>
 *   {!isActive ? <EnterIcon /> : <ExitIcon />}
 * </FullscreenButton>
 * ```
 */
const FullscreenButton = React.forwardRef<HTMLButtonElement, FullscreenButtonProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <FullscreenButtonBridge {...(props as Omit<FullscreenButtonProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </FullscreenButtonBridge>
    );
  },
);

FullscreenButton.displayName = 'FullscreenButton';
export { FullscreenButton };
</file>

<file path="components/ui/buttons/google-cast-button.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { GoogleCastButtonInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * GoogleCastButton
 * -----------------------------------------------------------------------------------------------*/

const GoogleCastButtonBridge = createReactComponent(GoogleCastButtonInstance, {
  domEventsRegex: /^onMedia/,
});

export interface GoogleCastButtonProps
  extends ReactElementProps<GoogleCastButtonInstance, HTMLButtonElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * A button for requesting Google Cast.
 *
 * @see {@link https://developers.google.com/cast/docs/overview}
 * @docs {@link https://www.vidstack.io/docs/player/components/buttons/google-cast-button}
 * @example
 * ```tsx
 * <GoogleCastButton>
 *   <ChromecastIcon />
 * </GoogleCastButton>
 * ```
 */
const GoogleCastButton = React.forwardRef<HTMLButtonElement, GoogleCastButtonProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <GoogleCastButtonBridge {...(props as Omit<GoogleCastButtonProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </GoogleCastButtonBridge>
    );
  },
);

GoogleCastButton.displayName = 'GoogleCastButton';
export { GoogleCastButton };
</file>

<file path="components/ui/buttons/live-button.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { LiveButtonInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * LiveButton
 * -----------------------------------------------------------------------------------------------*/

const LiveButtonBridge = createReactComponent(LiveButtonInstance, {
  domEventsRegex: /^onMedia/,
});

export interface LiveButtonProps extends ReactElementProps<LiveButtonInstance, HTMLButtonElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * This component displays the current live status of the stream. This includes whether it's
 * live, at the live edge, or not live. In addition, this component is a button during live streams
 * and will skip ahead to the live edge when pressed.
 *
 *  This component will have `aria-hidden="true"` applied when the current stream is _not_
 * live.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/buttons/live-button}
 * @example
 * ```tsx
 * <LiveButton>
 *   <LiveIcon />
 * </LiveButton>
 * ```
 */
const LiveButton = React.forwardRef<HTMLButtonElement, LiveButtonProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <LiveButtonBridge {...(props as Omit<LiveButtonProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </LiveButtonBridge>
    );
  },
);

LiveButton.displayName = 'LiveButton';
export { LiveButton };
</file>

<file path="components/ui/buttons/mute-button.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { MuteButtonInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * MuteButton
 * -----------------------------------------------------------------------------------------------*/

const MuteButtonBridge = createReactComponent(MuteButtonInstance, {
  domEventsRegex: /^onMedia/,
});

export interface MuteButtonProps extends ReactElementProps<MuteButtonInstance, HTMLButtonElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * A button for toggling the muted state of the player.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/buttons/mute-button}
 * @example
 * ```tsx
 * const volume = useMediaState('volume'),
 *   isMuted = useMediaState('muted');
 *
 * <MuteButton>
 *   {isMuted || volume == 0 ? (
 *     <MuteIcon />
 *   ) : volume < 0.5 ? (
 *     <VolumeLowIcon />
 *   ) : (
 *     <VolumeHighIcon />
 *   )}
 * </MuteButton>
 * ```
 */
const MuteButton = React.forwardRef<HTMLButtonElement, MuteButtonProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <MuteButtonBridge {...(props as Omit<MuteButtonProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </MuteButtonBridge>
    );
  },
);

MuteButton.displayName = 'MuteButton';
export { MuteButton };
</file>

<file path="components/ui/buttons/pip-button.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { PIPButtonInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * PIPButton
 * -----------------------------------------------------------------------------------------------*/

const PIPButtonBridge = createReactComponent(PIPButtonInstance, {
  domEventsRegex: /^onMedia/,
});

export interface PIPButtonProps extends ReactElementProps<PIPButtonInstance, HTMLButtonElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * A button for toggling the picture-in-picture (PIP) mode of the player.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/buttons/pip-button}
 * @see {@link https://www.vidstack.io/docs/player/api/picture-in-picture}
 * @example
 * ```tsx
 * const isActive = useMediaState('pictureInPicture');
 *
 * <PIPButton>
 *   {!isActive ? <EnterIcon /> : <ExitIcon />}
 * </PIPButton>
 * ```
 */
const PIPButton = React.forwardRef<HTMLButtonElement, PIPButtonProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <PIPButtonBridge {...(props as Omit<PIPButtonProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </PIPButtonBridge>
    );
  },
);

PIPButton.displayName = 'PIPButton';
export { PIPButton };
</file>

<file path="components/ui/buttons/play-button.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { PlayButtonInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * PlayButton
 * -----------------------------------------------------------------------------------------------*/

const PlayButtonBridge = createReactComponent(PlayButtonInstance, {
  domEventsRegex: /^onMedia/,
});

export interface PlayButtonProps extends ReactElementProps<PlayButtonInstance, HTMLButtonElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * A button for toggling the playback state (play/pause) of the current media.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/buttons/play-button}
 * @example
 * ```tsx
 * const isPaused = useMediaState('paused');
 *
 * <PlayButton>
 *   {isPaused ? <PlayIcon /> : <PauseIcon />}
 * </PlayButton>
 * ```
 */
const PlayButton = React.forwardRef<HTMLButtonElement, PlayButtonProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <PlayButtonBridge {...(props as Omit<PlayButtonProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </PlayButtonBridge>
    );
  },
);

PlayButton.displayName = 'PlayButton';
export { PlayButton };
</file>

<file path="components/ui/buttons/seek-button.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { SeekButtonInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * SeekButton
 * -----------------------------------------------------------------------------------------------*/

const SeekButtonBridge = createReactComponent(SeekButtonInstance, {
  domEventsRegex: /^onMedia/,
});

export interface SeekButtonProps extends ReactElementProps<SeekButtonInstance, HTMLButtonElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * A button for seeking the current media playback forwards or backwards by a specified amount.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/buttons/seek-button}
 * @example
 * ```tsx
 * <SeekButton seconds={-10}>
 *   <SeekBackwardIcon />
 * </SeekButton>
 *
 * <SeekButton seconds={10}>
 *   <SeekForwardIcon />
 * </SeekButton>
 * ```
 */
const SeekButton = React.forwardRef<HTMLButtonElement, SeekButtonProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <SeekButtonBridge {...(props as Omit<SeekButtonProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </SeekButtonBridge>
    );
  },
);

SeekButton.displayName = 'SeekButton';
export { SeekButton };
</file>

<file path="components/ui/buttons/toggle-button.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { ToggleButtonInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * ToggleButton
 * -----------------------------------------------------------------------------------------------*/

const ToggleButtonBridge = createReactComponent(ToggleButtonInstance);

export interface ToggleButtonProps
  extends ReactElementProps<ToggleButtonInstance, HTMLButtonElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * A toggle button is a two-state button that can be either off (not pressed) or on (pressed).
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/buttons/toggle-button}
 * @example
 * ```tsx
 * <ToggleButton aria-label="...">
 *   <OnIcon />
 *   <OffIcon />
 * </ToggleButton>
 * ```
 */
const ToggleButton = React.forwardRef<HTMLButtonElement, ToggleButtonProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <ToggleButtonBridge {...(props as Omit<ToggleButtonProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </ToggleButtonBridge>
    );
  },
);

ToggleButton.displayName = 'ToggleButton';
export { ToggleButton };
</file>

<file path="components/ui/caption.tsx">
import * as React from 'react';

import type { VTTCue } from 'media-captions';

import { useMediaState } from '../../hooks/use-media-state';
import { Primitive, type PrimitivePropsWithRef } from '../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * Caption
 * -----------------------------------------------------------------------------------------------*/

export interface RootProps extends PrimitivePropsWithRef<'div'> {
  children?: React.ReactNode;
}

const Root = React.forwardRef<HTMLElement, RootProps>(({ children, ...props }, forwardRef) => {
  return (
    <Primitive.div
      translate="yes"
      aria-live="off"
      aria-atomic="true"
      {...props}
      ref={forwardRef as React.Ref<any>}
    >
      {children}
    </Primitive.div>
  );
});

Root.displayName = 'Caption';
export { Root };

/* -------------------------------------------------------------------------------------------------
 * CaptionText
 * -----------------------------------------------------------------------------------------------*/

export interface TextProps extends PrimitivePropsWithRef<'span'> {}

const Text = React.forwardRef<HTMLElement, TextProps>((props, forwardRef) => {
  const textTrack = useMediaState('textTrack'),
    [activeCue, setActiveCue] = React.useState<VTTCue | undefined>();

  React.useEffect(() => {
    if (!textTrack) return;

    function onCueChange() {
      setActiveCue(textTrack?.activeCues[0]);
    }

    textTrack.addEventListener('cue-change', onCueChange);
    return () => {
      textTrack.removeEventListener('cue-change', onCueChange);
      setActiveCue(undefined);
    };
  }, [textTrack]);

  return (
    <Primitive.span
      {...props}
      data-part="cue"
      dangerouslySetInnerHTML={{
        __html: activeCue?.text || '',
      }}
      ref={forwardRef as React.Ref<any>}
    />
  );
});

Text.displayName = 'CaptionText';
export { Text };
</file>

<file path="components/ui/captions.tsx">
import * as React from 'react';

import { createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { CaptionsInstance } from '../primitives/instances';
import { Primitive } from '../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * Captions
 * -----------------------------------------------------------------------------------------------*/

const CaptionsBridge = createReactComponent(CaptionsInstance);

export interface CaptionsProps extends ReactElementProps<CaptionsInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<CaptionsInstance>;
}

/**
 * Renders and displays captions/subtitles. This will be an overlay for video and a simple
 * captions box for audio.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/display/captions}
 * @example
 * ```tsx
 * <Captions />
 * ```
 */
const Captions = React.forwardRef<CaptionsInstance, CaptionsProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <CaptionsBridge {...props} ref={forwardRef}>
        {(props) => <Primitive.div {...props}>{children}</Primitive.div>}
      </CaptionsBridge>
    );
  },
);

Captions.displayName = 'Captions';
export { Captions };
</file>

<file path="components/ui/chapter-title.tsx">
import * as React from 'react';

import { useChapterTitle } from '../../hooks/use-chapter-title';
import { Primitive, type PrimitivePropsWithRef } from '../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * Chapter Title
 * -----------------------------------------------------------------------------------------------*/

export interface ChapterTitleProps extends PrimitivePropsWithRef<'span'> {
  /**
   * Specify text to be displayed when no chapter title is available.
   */
  defaultText?: string;
}

/**
 * This component is used to load and display the current chapter title based on the text tracks
 * provided.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/display/chapter-title}
 * @example
 * ```tsx
 * <ChapterTitle />
 * ```
 */
const ChapterTitle = React.forwardRef<HTMLElement, ChapterTitleProps>(
  ({ defaultText = '', children, ...props }, forwardRef) => {
    const $chapterTitle = useChapterTitle();
    return (
      <Primitive.span {...props} ref={forwardRef as React.Ref<any>}>
        {$chapterTitle || defaultText}
        {children}
      </Primitive.span>
    );
  },
);

ChapterTitle.displayName = 'ChapterTitle';
export { ChapterTitle };
</file>

<file path="components/ui/controls.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { ControlsGroupInstance, ControlsInstance } from '../primitives/instances';
import { Primitive } from '../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * Controls
 * -----------------------------------------------------------------------------------------------*/

const ControlsBridge = createReactComponent(ControlsInstance);

export interface RootProps extends ReactElementProps<ControlsInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

/**
 * This component creates a container for control groups.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/media/controls}
 * @example
 * ```tsx
 * <Controls.Root>
 *   <Controls.Group></Controls.Group>
 *   <Controls.Group></Controls.Group>
 * <Controls.Root>
 * ```
 */
const Root = React.forwardRef<HTMLElement, RootProps>(({ children, ...props }, forwardRef) => {
  return (
    <ControlsBridge {...(props as Omit<RootProps, 'ref'>)}>
      {(props) => (
        <Primitive.div
          {...props}
          ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
        >
          {children}
        </Primitive.div>
      )}
    </ControlsBridge>
  );
});

Root.displayName = 'Controls';

/* -------------------------------------------------------------------------------------------------
 * ControlsGroup
 * -----------------------------------------------------------------------------------------------*/

const ControlsGroupBridge = createReactComponent(ControlsGroupInstance);

export interface GroupProps extends ReactElementProps<ControlsGroupInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

/**
 * This component creates a container for media controls.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/media/controls#group}
 * @example
 * ```tsx
 * <Controls.Root>
 *   <Controls.Group></Controls.Group>
 *   <Controls.Group></Controls.Group>
 * <Controls.Root>
 * ```
 */
const Group = React.forwardRef<HTMLElement, GroupProps>(({ children, ...props }, forwardRef) => {
  return (
    <ControlsGroupBridge {...(props as Omit<GroupProps, 'ref'>)}>
      {(props) => (
        <Primitive.div
          {...props}
          ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
        >
          {children}
        </Primitive.div>
      )}
    </ControlsGroupBridge>
  );
});

Group.displayName = 'ControlsGroup';

export { Root, Group };
</file>

<file path="components/ui/gesture.tsx">
import * as React from 'react';

import { createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { GestureInstance } from '../primitives/instances';
import { Primitive } from '../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * Gesture
 * -----------------------------------------------------------------------------------------------*/

const GestureBridge = createReactComponent(GestureInstance, {
  events: ['onWillTrigger', 'onTrigger'],
});

export interface GestureProps extends ReactElementProps<GestureInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<GestureInstance>;
}

/**
 * This component enables actions to be performed on the media based on user gestures.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/media/gesture}
 * @example
 * ```tsx
 * <Gesture event="pointerup" action="toggle:paused" />
 * <Gesture event="dblpointerup" action="toggle:fullscreen" />
 * ```
 */
const Gesture = React.forwardRef<GestureInstance, GestureProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <GestureBridge {...props} ref={forwardRef}>
        {(props) => <Primitive.div {...props}>{children}</Primitive.div>}
      </GestureBridge>
    );
  },
);

Gesture.displayName = 'Gesture';
export { Gesture };
</file>

<file path="components/ui/menu.tsx">
import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';
import { isString } from 'maverick.js/std';
import { createPortal } from 'react-dom';

import { useMediaState } from '../../hooks/use-media-state';
import {
  MenuButtonInstance,
  MenuInstance,
  MenuItemInstance,
  MenuItemsInstance,
  MenuPortalInstance,
} from '../primitives/instances';
import { Primitive } from '../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * Menu
 * -----------------------------------------------------------------------------------------------*/

const MenuBridge = createReactComponent(MenuInstance, {
  events: ['onOpen', 'onClose'],
  domEventsRegex: /^onMedia/,
});

export interface RootProps extends ReactElementProps<MenuInstance> {
  asChild?: boolean;
  children: React.ReactNode;
  ref?: React.Ref<MenuInstance>;
}

/**
 * Root menu container used to hold and manage a menu button and menu items. This component is
 * used to display options in a floating panel. They can be nested to create submenus.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/menu/menu}
 * @example
 * ```tsx
 * <Menu.Root>
 *   <Menu.Button></Menu.Button>
 *   <Menu.Content placement="top end"></Menu.Content>
 * </Menu.Root>
 * ```
 */
const Root = React.forwardRef<MenuInstance, RootProps>(({ children, ...props }, forwardRef) => {
  return (
    <MenuBridge {...props} ref={forwardRef}>
      {(props, instance) => (
        <Primitive.div
          {...props}
          style={{ display: !instance.isSubmenu ? 'contents' : undefined, ...props.style }}
        >
          {children}
        </Primitive.div>
      )}
    </MenuBridge>
  );
});

Root.displayName = 'Menu';

/* -------------------------------------------------------------------------------------------------
 * MenuButton
 * -----------------------------------------------------------------------------------------------*/

const ButtonBridge = createReactComponent(MenuButtonInstance, {
  events: ['onSelect'],
});

export interface ButtonProps extends ReactElementProps<MenuButtonInstance, HTMLButtonElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * A button that controls the opening and closing of a menu component. The button will become a
 * `menuitem` when used inside a submenu.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/menu/menu}
 * @example
 * ```tsx
 * <Menu.Root>
 *   <Menu.Button></Menu.Button>
 *   <Menu.Content placement="top end"></Menu.Content>
 * </Menu.Root>
 * ```
 */
const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <ButtonBridge {...(props as Omit<ButtonProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </ButtonBridge>
    );
  },
);

Button.displayName = 'MenuButton';

/* -------------------------------------------------------------------------------------------------
 * Portal
 * -----------------------------------------------------------------------------------------------*/

export interface PortalProps extends ReactElementProps<MenuPortalInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

/**
 * Portals menu items into the given container.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/menu#portal}
 * @example
 * ```tsx
 * <Menu.Root>
 *   <Menu.Button></Menu.Button>
 *   <Menu.Portal>
 *     <Menu.Content placement="top end"></Menu.Content>
 *   </Menu.Portal>
 * </Menu.Root>
 * ```
 */
const Portal = React.forwardRef<HTMLElement, PortalProps>(
  ({ container = null, disabled = false, children, ...props }, forwardRef) => {
    let fullscreen = useMediaState('fullscreen'),
      shouldPortal = disabled === 'fullscreen' ? !fullscreen : !disabled;

    const target = React.useMemo(() => {
      if (__SERVER__) return null;
      const node = isString(container) ? document.querySelector(container) : container;
      return node ?? document.body;
    }, [container]);

    return !target || !shouldPortal
      ? children
      : createPortal(
          <Primitive.div
            {...props}
            style={{ display: 'contents', ...props.style }}
            ref={forwardRef as React.Ref<any>}
          >
            {children}
          </Primitive.div>,
          target,
        );
  },
);

Portal.displayName = 'MenuPortal';

/* -------------------------------------------------------------------------------------------------
 * MenuItems
 * -----------------------------------------------------------------------------------------------*/

const ItemsBridge = createReactComponent(MenuItemsInstance);

export interface ItemsProps extends ReactElementProps<MenuItemsInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

/**
 * Used to group and display settings or arbitrary content in a floating panel.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/menu/menu}
 * @example
 * ```tsx
 * <Menu.Root>
 *   <Menu.Button></Menu.Button>
 *   <Menu.Items placement="top end"></Menu.Items>
 * </Menu.Root>
 * ```
 */
const Items = React.forwardRef<HTMLElement, ItemsProps>(({ children, ...props }, forwardRef) => {
  return (
    <ItemsBridge {...(props as Omit<ItemsProps, 'ref'>)}>
      {(props) => (
        <Primitive.div
          {...props}
          ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
        >
          {children}
        </Primitive.div>
      )}
    </ItemsBridge>
  );
});

Items.displayName = 'MenuItems';

/* -------------------------------------------------------------------------------------------------
 * MenuItem
 * -----------------------------------------------------------------------------------------------*/

const ItemBridge = createReactComponent(MenuItemInstance);

export interface ItemProps extends ReactElementProps<MenuItemInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

/**
 * Represents a specific option or action, typically displayed as a text label or icon, which
 * users can select to access or perform a particular function or view related content.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/menu/menu}
 * @example
 * ```tsx
 * <Menu.Root>
 *   <Menu.Button></Menu.Button>
 *   <Menu.Content placement="top end">
 *     <Menu.Item></Menu.Item>
 *   </Menu.Content>
 * </Menu.Root>
 * ```
 */
const Item = React.forwardRef<HTMLElement, ItemProps>(({ children, ...props }, forwardRef) => {
  return (
    <ItemBridge {...(props as Omit<ItemProps, 'ref'>)}>
      {(props) => (
        <Primitive.div
          {...props}
          ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
        >
          {children}
        </Primitive.div>
      )}
    </ItemBridge>
  );
});

Item.displayName = 'MenuItem';

export { Root, Button, Portal, Items, Items as Content, type ItemsProps as ContentProps, Item };
export {
  Root as RadioGroup,
  Item as Radio,
  type RootProps as RadioGroupProps,
  type ItemProps as RadioProps,
} from './radio-group';
</file>

<file path="components/ui/poster.tsx">
import * as React from 'react';

import {
  composeRefs,
  createReactComponent,
  useSignal,
  type ReactElementProps,
} from 'maverick.js/react';

import { PosterInstance } from '../primitives/instances';
import { Primitive } from '../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * Poster
 * -----------------------------------------------------------------------------------------------*/

const PosterBridge = createReactComponent(PosterInstance);

export interface PosterProps extends ReactElementProps<PosterInstance, HTMLImageElement> {
  alt?: string;
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLImageElement>;
}

/**
 * Loads and displays the current media poster image. By default, the media provider's
 * loading strategy is respected meaning the poster won't load until the media can.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/media/poster}
 * @example
 * ```tsx
 * <MediaPlayer>
 *   <MediaProvider>
 *     <Poster src="..." alt="..." />
 *   </MediaProvider>
 * </MediaPlayer>
 * ```
 */
const Poster = React.forwardRef<HTMLImageElement, PosterProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <PosterBridge
        src={props.asChild && React.isValidElement(children) ? children.props.src : undefined}
        {...(props as Omit<PosterProps, 'ref'>)}
      >
        {(props, instance) => (
          <PosterImg
            {...props}
            instance={instance}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as any)}
          >
            {children}
          </PosterImg>
        )}
      </PosterBridge>
    );
  },
);

Poster.displayName = 'Poster';
export { Poster };

/* -------------------------------------------------------------------------------------------------
 * PosterImg
 * -----------------------------------------------------------------------------------------------*/

interface PosterImgProps {
  instance: PosterInstance;
  children?: React.ReactNode;
  asChild?: boolean;
  ref?: React.LegacyRef<HTMLImageElement>;
}

const PosterImg = React.forwardRef<HTMLImageElement, PosterImgProps>(
  ({ instance, children, ...props }, forwardRef) => {
    const { src, img, alt, crossOrigin, hidden } = instance.$state,
      $src = useSignal(src),
      $alt = useSignal(alt),
      $crossOrigin = useSignal(crossOrigin),
      $hidden = useSignal(hidden);
    return (
      <Primitive.img
        {...props}
        src={$src || undefined}
        alt={$alt || undefined}
        crossOrigin={$crossOrigin || undefined}
        ref={composeRefs(img.set as React.Ref<HTMLImageElement>, forwardRef)}
        style={{ display: $hidden ? 'none' : undefined }}
      >
        {children}
      </Primitive.img>
    );
  },
);

PosterImg.displayName = 'PosterImg';
</file>

<file path="components/ui/radio-group.tsx">
/* -------------------------------------------------------------------------------------------------
 * RadioGroup
 * -----------------------------------------------------------------------------------------------*/

import * as React from 'react';

import { composeRefs, createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { RadioGroupInstance, RadioInstance } from '../primitives/instances';
import { Primitive } from '../primitives/nodes';

const RadioGroupBridge = createReactComponent(RadioGroupInstance, {
  events: ['onChange'],
});

export interface RootProps extends ReactElementProps<RadioGroupInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<RadioGroupInstance>;
}

/**
 * A radio group consists of options where only one of them can be checked. Each option is
 * provided as a radio (i.e., a selectable element).
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/menu/radio-group}
 * @example
 * ```tsx
 * <RadioGroup.Root>
 *   <RadioGroup.Item value="1080">1080p</RadioGroup.Item>
 *   <RadioGroup.Item value="720">720p</RadioGroup.Item>
 * </RadioGroup.Root>
 * ```
 */
const Root = React.forwardRef<RadioGroupInstance, RootProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <RadioGroupBridge {...props} ref={forwardRef}>
        {(props) => <Primitive.div {...props}>{children}</Primitive.div>}
      </RadioGroupBridge>
    );
  },
);

Root.displayName = 'RadioGroup';

/* -------------------------------------------------------------------------------------------------
 * RadioItem
 * -----------------------------------------------------------------------------------------------*/

const ItemBridge = createReactComponent(RadioInstance, {
  events: ['onChange', 'onSelect'],
});

export interface ItemProps extends ReactElementProps<RadioInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

/**
 * A radio represents a option that a user can select inside of a radio group. Only one radio
 * can be checked in a group.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/menu/radio}
 * @example
 * ```tsx
 * <RadioGroup.Item value="1080">1080p</RadioGroup.Item>
 * ```
 */
const Item = React.forwardRef<HTMLElement, ItemProps>(({ children, ...props }, forwardRef) => {
  return (
    <ItemBridge {...(props as Omit<ItemProps, 'ref'>)}>
      {(props) => (
        <Primitive.div
          {...props}
          ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
        >
          {children}
        </Primitive.div>
      )}
    </ItemBridge>
  );
});

Item.displayName = 'RadioItem';

export { Root, Item };
</file>

<file path="components/ui/sliders/audio-gain-slider.tsx">
import * as React from 'react';

import { createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { AudioGainSliderInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';
import { Value } from './slider';
import { sliderCallbacks } from './slider-callbacks';

/* -------------------------------------------------------------------------------------------------
 * AudioGainSlider
 * -----------------------------------------------------------------------------------------------*/

const AudioGainSliderBridge = createReactComponent(AudioGainSliderInstance, {
  events: sliderCallbacks,
  domEventsRegex: /^onMedia/,
});

export interface RootProps extends ReactElementProps<AudioGainSliderInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<AudioGainSliderInstance>;
}

/**
 * Versatile and user-friendly audio boost control designed for seamless cross-browser and provider
 * compatibility and accessibility with ARIA support. It offers a smooth user experience for both
 * mouse and touch interactions and is highly customizable in terms of styling. Users can
 * effortlessly change the audio gain within the range 0 to 100.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/sliders/audio-gain-slider}
 * @example
 * ```tsx
 * <AudioGainSlider.Root>
 *   <AudioGainSlider.Track>
 *     <AudioGainSlider.TrackFill />
 *   </AudioGainSlider.Track>
 *   <AudioGainSlider.Thumb />
 * </AudioGainSlider.Root>
 * ```
 */
const Root = React.forwardRef<AudioGainSliderInstance, RootProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <AudioGainSliderBridge {...props} ref={forwardRef}>
        {(props) => <Primitive.div {...props}>{children}</Primitive.div>}
      </AudioGainSliderBridge>
    );
  },
);

Root.displayName = 'AudioGainSlider';

export * from './slider';
export { Root, Value };
</file>

<file path="components/ui/sliders/quality-slider.tsx">
import * as React from 'react';

import { createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { QualitySliderInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';
import { Value } from './slider';
import { sliderCallbacks } from './slider-callbacks';

/* -------------------------------------------------------------------------------------------------
 * QualitySlider
 * -----------------------------------------------------------------------------------------------*/

const QualitySliderBridge = createReactComponent(QualitySliderInstance, {
  events: sliderCallbacks,
  domEventsRegex: /^onMedia/,
});

export interface RootProps extends ReactElementProps<QualitySliderInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<QualitySliderInstance>;
}

/**
 * Versatile and user-friendly input video quality control designed for seamless cross-browser and
 * provider compatibility and accessibility with ARIA support. It offers a smooth user experience
 * for both mouse and touch interactions and is highly customizable in terms of styling.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/sliders/quality-slider}
 * @example
 * ```tsx
 * <QualitySlider.Root>
 *   <QualitySlider.Track>
 *     <QualitySlider.TrackFill />
 *   </QualitySlider.Track>
 *   <QualitySlider.Thumb />
 * </QualitySlider.Root>
 * ```
 */
const Root = React.forwardRef<QualitySliderInstance, RootProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <QualitySliderBridge {...props} ref={forwardRef}>
        {(props) => <Primitive.div {...props}>{children}</Primitive.div>}
      </QualitySliderBridge>
    );
  },
);

Root.displayName = 'QualitySlider';

export * from './slider';
export { Root, Value };
</file>

<file path="components/ui/sliders/slider-callbacks.ts">
import type { InferComponentEvents } from 'maverick.js';
import type { ReactEventCallbacks } from 'maverick.js/react';

import type { SliderInstance } from '../../primitives/instances';

type SliderCallbacks = keyof ReactEventCallbacks<InferComponentEvents<SliderInstance>>;

export const sliderCallbacks: SliderCallbacks[] = [
  'onDragStart',
  'onDragEnd',
  'onDragValueChange',
  'onValueChange',
  'onPointerValueChange',
];
</file>

<file path="components/ui/sliders/slider-value.tsx">
import * as React from 'react';

import { createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { SliderValueInstance } from '../../primitives/instances';

export const SliderValueBridge = createReactComponent(SliderValueInstance);

export interface SliderValueProps extends ReactElementProps<SliderValueInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}
</file>

<file path="components/ui/sliders/slider.tsx">
import * as React from 'react';

import {
  composeRefs,
  createReactComponent,
  useSignal,
  type ReactElementProps,
} from 'maverick.js/react';

import { useSliderState } from '../../../hooks/use-slider-state';
import { SliderInstance, SliderPreviewInstance } from '../../primitives/instances';
import { Primitive, type PrimitivePropsWithRef } from '../../primitives/nodes';
import { sliderCallbacks } from './slider-callbacks';
import { SliderValueBridge, type SliderValueProps } from './slider-value';

/* -------------------------------------------------------------------------------------------------
 * Slider
 * -----------------------------------------------------------------------------------------------*/

const SliderBridge = createReactComponent(SliderInstance, {
  events: sliderCallbacks,
});

export interface RootProps extends ReactElementProps<SliderInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<SliderInstance>;
}

/**
 * Versatile and user-friendly input control designed for seamless cross-browser compatibility and
 * accessibility with ARIA support. It offers a smooth user experience for both mouse and touch
 * interactions and is highly customizable in terms of styling. Users can effortlessly input numeric
 * values within a specified range, defined by a minimum and maximum value.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/sliders/slider}
 * @example
 * ```tsx
 * <Slider.Root>
 *   <Slider.Track>
 *     <Slider.TrackFill />
 *   </Slider.Track>
 *   <Slider.Thumb />
 * </Slider.Root>
 * ```
 */
const Root = React.forwardRef<SliderInstance, RootProps>(({ children, ...props }, forwardRef) => {
  return (
    <SliderBridge {...props} ref={forwardRef}>
      {(props) => <Primitive.div {...props}>{children}</Primitive.div>}
    </SliderBridge>
  );
});

Root.displayName = 'Slider';

/* -------------------------------------------------------------------------------------------------
 * SliderThumb
 * -----------------------------------------------------------------------------------------------*/

export interface ThumbProps extends PrimitivePropsWithRef<'div'> {}

/**
 * Purely visual element used to display a draggable handle to the user for adjusting the value
 * on the slider component.
 *
 * @example
 * ```tsx
 * <Slider.Root>
 *   <Slider.Thumb />
 * </Slider.Root>
 * ```
 */
const Thumb = React.forwardRef<HTMLElement, ThumbProps>((props, forwardRef) => (
  <Primitive.div {...props} ref={forwardRef as React.Ref<any>} />
));

Thumb.displayName = 'SliderThumb';

/* -------------------------------------------------------------------------------------------------
 * SliderTrack
 * -----------------------------------------------------------------------------------------------*/

export interface TrackProps extends PrimitivePropsWithRef<'div'> {}

/**
 * Visual element inside the slider that serves as a horizontal or vertical bar, providing a
 * visual reference for the range or values that can be selected by moving the slider thumb along
 * it. Users can interact with the slider by dragging the thumb along the track to set a specific
 * value.
 *
 * @example
 * ```tsx
 * <Slider.Root>
 *   <Slider.Track>
 *     <Slider.TrackFill />
 *   </Slider.Track>
 * </Slider.Root>
 * ```
 */
const Track = React.forwardRef<HTMLElement, TrackProps>((props, forwardRef) => (
  <Primitive.div {...props} ref={forwardRef as React.Ref<any>} />
));

Track.displayName = 'SliderTrack';

/* -------------------------------------------------------------------------------------------------
 * SliderTrackFill
 * -----------------------------------------------------------------------------------------------*/

export interface TrackFillProps extends PrimitivePropsWithRef<'div'> {}

/**
 * Portion of the slider track that is visually filled or highlighted to indicate the selected or
 * currently chosen range or value. As the slider thumb is moved along the track, the track
 * fill dynamically adjusts to visually represent the portion of the track that corresponds to the
 * selected value or range, providing users with a clear visual indication of their selection.
 *
 * @example
 * ```tsx
 * <Slider.Root>
 *   <Slider.Track>
 *     <Slider.TrackFill />
 *   </Slider.Track>
 * </Slider.Root>
 * ```
 */
const TrackFill = React.forwardRef<HTMLElement, TrackFillProps>((props, forwardRef) => (
  <Primitive.div {...props} ref={forwardRef as React.Ref<any>} />
));

TrackFill.displayName = 'SliderTrackFill';

/* -------------------------------------------------------------------------------------------------
 * SliderPreview
 * -----------------------------------------------------------------------------------------------*/

const PreviewBridge = createReactComponent(SliderPreviewInstance);

export interface PreviewProps extends ReactElementProps<SliderPreviewInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

/**
 * Used to provide users with a real-time or interactive preview of the value or selection they
 * are making as they move the slider thumb. This can include displaying the current pointer
 * value numerically, or displaying a thumbnail over the time slider.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/slider#preview}
 * @example
 * ```tsx
 * <Slider.Root>
 *   <Slider.Preview>
 *     <Slider.Value />
 *   </Slider.Preview>
 * </Slider.Root>
 * ```
 */
const Preview = React.forwardRef<HTMLElement, PreviewProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <PreviewBridge {...(props as Omit<PreviewProps, 'ref'>)}>
        {(props) => (
          <Primitive.div
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.div>
        )}
      </PreviewBridge>
    );
  },
);

Preview.displayName = 'SliderPreview';

/* -------------------------------------------------------------------------------------------------
 * SliderValue
 * -----------------------------------------------------------------------------------------------*/

export interface ValueProps extends SliderValueProps {}

/**
 * Displays the specific numeric representation of the current or pointer value of the slider.
 * When a user interacts with a slider by moving its thumb along the track, the slider value
 * changes accordingly.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/slider#preview}
 * @example
 * ```tsx
 * <Slider.Root>
 *   <Slider.Preview>
 *     <Slider.Value />
 *   </Slider.Preview>
 * </Slider.Root>
 * ```
 */
const Value = React.forwardRef<HTMLElement, ValueProps>(({ children, ...props }, forwardRef) => {
  return (
    <SliderValueBridge {...(props as Omit<ValueProps, 'ref'>)}>
      {(props, instance) => {
        const $text = useSignal(() => instance.getValueText(), instance);
        return (
          <Primitive.div {...props} ref={forwardRef as React.Ref<any>}>
            {$text}
            {children}
          </Primitive.div>
        );
      }}
    </SliderValueBridge>
  );
});

Value.displayName = 'SliderValue';

/* -------------------------------------------------------------------------------------------------
 * SliderSteps
 * -----------------------------------------------------------------------------------------------*/

export interface StepsProps extends Omit<PrimitivePropsWithRef<'div'>, 'children'> {
  children: (step: number) => React.ReactNode;
}

/**
 * Visual markers that can be used to indicate value steps on the slider track.
 *
 * @example
 * ```tsx
 * <Slider.Root>
 *   <Slider.Steps className="steps">
 *     {(step) => <div className="step" key={String(step)}></div>}
 *   </Slider.Steps>
 * </Slider.Root>
 * ```
 */
const Steps = React.forwardRef<HTMLElement, StepsProps>(({ children, ...props }, forwardRef) => {
  const $min = useSliderState('min'),
    $max = useSliderState('max'),
    $step = useSliderState('step'),
    steps = ($max - $min) / $step;

  return (
    <Primitive.div {...props} ref={forwardRef as React.Ref<any>}>
      {Array.from({ length: Math.floor(steps) + 1 }).map((_, step) => children(step))}
    </Primitive.div>
  );
});

Steps.displayName = 'SliderSteps';

export { Root, Thumb, Track, TrackFill, Preview, Value, Steps };
</file>

<file path="components/ui/sliders/speed-slider.tsx">
import * as React from 'react';

import { createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { SpeedSliderInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';
import { Value } from './slider';
import { sliderCallbacks } from './slider-callbacks';

/* -------------------------------------------------------------------------------------------------
 * SpeedSlider
 * -----------------------------------------------------------------------------------------------*/

const SpeedSliderBridge = createReactComponent(SpeedSliderInstance, {
  events: sliderCallbacks,
  domEventsRegex: /^onMedia/,
});

export interface RootProps extends ReactElementProps<SpeedSliderInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<SpeedSliderInstance>;
}

/**
 * Versatile and user-friendly input playback rate control designed for seamless cross-browser and
 * provider compatibility and accessibility with ARIA support. It offers a smooth user experience
 * for both mouse and touch interactions and is highly customizable in terms of styling.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/sliders/speed-slider}
 * @example
 * ```tsx
 * <SpeedSlider.Root>
 *   <SpeedSlider.Track>
 *     <SpeedSlider.TrackFill />
 *   </SpeedSlider.Track>
 *   <SpeedSlider.Thumb />
 * </SpeedSlider.Root>
 * ```
 */
const Root = React.forwardRef<SpeedSliderInstance, RootProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <SpeedSliderBridge {...props} ref={forwardRef}>
        {(props) => <Primitive.div {...props}>{children}</Primitive.div>}
      </SpeedSliderBridge>
    );
  },
);

Root.displayName = 'SpeedSlider';

export * from './slider';
export { Root, Value };
</file>

<file path="components/ui/sliders/time-slider.tsx">
import * as React from 'react';

import { effect, signal, type WriteSignal } from 'maverick.js';
import {
  composeRefs,
  createReactComponent,
  useSignal,
  useStateContext,
  type ReactElementProps,
} from 'maverick.js/react';
import type { VTTCue } from 'media-captions';
import { mediaState } from 'vidstack';

import { createVTTCue } from '../../../utils';
import {
  SliderChaptersInstance,
  SliderThumbnailInstance,
  SliderVideoInstance,
  TimeSliderInstance,
} from '../../primitives/instances';
import { Primitive, type PrimitivePropsWithRef } from '../../primitives/nodes';
import * as ThumbnailBase from '../thumbnail';
import { sliderCallbacks } from './slider-callbacks';

/* -------------------------------------------------------------------------------------------------
 * TimeSliderContext
 * -----------------------------------------------------------------------------------------------*/

const TimeSliderContext = React.createContext<TimeSliderContext>({
  $chapters: signal<SliderChaptersInstance | null>(null),
});

interface TimeSliderContext {
  $chapters: WriteSignal<SliderChaptersInstance | null>;
}

TimeSliderContext.displayName = 'TimeSliderContext';

/* -------------------------------------------------------------------------------------------------
 * TimeSlider
 * -----------------------------------------------------------------------------------------------*/

const TimeSliderBridge = createReactComponent(TimeSliderInstance, {
  events: sliderCallbacks,
  domEventsRegex: /^onMedia/,
});

export interface RootProps extends ReactElementProps<TimeSliderInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<TimeSliderInstance>;
}

/**
 * Versatile and user-friendly input time control designed for seamless cross-browser and provider
 * compatibility and accessibility with ARIA support. It offers a smooth user experience for both
 * mouse and touch interactions and is highly customizable in terms of styling. Users can
 * effortlessly change the current playback time within the range 0 to seekable end.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/sliders/time-slider}
 * @example
 * ```tsx
 * <TimeSlider.Root>
 *   <TimeSlider.Track>
 *     <TimeSlider.TrackFill />
 *     <TimeSlider.Progress />
 *   </TimeSlider.Track>
 *   <TimeSlider.Thumb />
 * </TimeSlider.Root>
 * ```
 */
const Root = React.forwardRef<TimeSliderInstance, RootProps>(
  ({ children, ...props }, forwardRef) => {
    const $chapters = React.useMemo(() => signal<SliderChaptersInstance | null>(null), []);
    return (
      <TimeSliderContext.Provider value={{ $chapters }}>
        <TimeSliderBridge {...props} ref={forwardRef}>
          {(props) => <Primitive.div {...props}>{children}</Primitive.div>}
        </TimeSliderBridge>
      </TimeSliderContext.Provider>
    );
  },
);

Root.displayName = 'TimeSlider';

/* -------------------------------------------------------------------------------------------------
 * SliderChapters
 * -----------------------------------------------------------------------------------------------*/

const SliderChaptersBridge = createReactComponent(SliderChaptersInstance);

export interface ChaptersProps extends Omit<ReactElementProps<SliderChaptersInstance>, 'children'> {
  children: (cues: VTTCue[], forwardRef: React.RefCallback<HTMLElement>) => React.ReactNode;
}

/**
 * Used to create predefined sections within a time slider interface based on the currently
 * active chapters text track.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/slider-chapters}
 * @example
 * ```tsx
 * <TimeSlider.Root>
 *   <TimeSlider.Chapters>
 *     {(cues, forwardRef) =>
 *       cues.map((cue) => (
 *         <div key={cue.startTime} ref={forwardRef}>
 *           <TimeSlider.Track>
 *             <TimeSlider.TrackFill />
 *             <TimeSlider.Progress />
 *           </TimeSlider.Track>
 *        </div>
 *     ))}
 *   </TimeSlider.Chapters>
 * </TimeSlider.Root>
 * ```
 */
const Chapters = React.forwardRef<HTMLDivElement, ChaptersProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <SliderChaptersBridge {...props}>
        {(props, instance) => (
          <Primitive.div
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            <ChapterTracks instance={instance}>{children}</ChapterTracks>
          </Primitive.div>
        )}
      </SliderChaptersBridge>
    );
  },
);

Chapters.displayName = 'SliderChapters';

interface ChapterTracksProps {
  instance: SliderChaptersInstance;
  children: ChaptersProps['children'];
}

function ChapterTracks({ instance, children }: ChapterTracksProps) {
  const $cues = useSignal(() => instance.cues, instance),
    refs = React.useRef<HTMLElement[]>([]),
    emptyCue = React.useRef<VTTCue>(),
    { $chapters } = React.useContext(TimeSliderContext);

  if (!emptyCue.current) {
    emptyCue.current = createVTTCue();
  }

  React.useEffect(() => {
    $chapters.set(instance);
    return () => void $chapters.set(null);
  }, [instance]);

  React.useEffect(() => {
    instance.setRefs(refs.current);
  }, [$cues]);

  return children($cues.length ? $cues : [emptyCue.current], (el) => {
    if (!el) {
      refs.current.length = 0;
      return;
    }

    refs.current.push(el);
  });
}

ChapterTracks.displayName = 'SliderChapterTracks';

/* -------------------------------------------------------------------------------------------------
 * SliderChapterTitle
 * -----------------------------------------------------------------------------------------------*/

export interface ChapterTitleProps extends PrimitivePropsWithRef<'div'> {}

/**
 * Used to display the active cue text based on the slider value and preview value.
 *
 * @example
 * ```tsx
 * <TimeSlider.Root>
 *   <TimeSlider.Preview>
 *     <TimeSlider.Chapter />
 *   </TimeSlider.Preview>
 * </TimeSlider.Root>
 * ```
 */
const ChapterTitle = React.forwardRef<HTMLElement, ChapterTitleProps>(
  ({ children, ...props }, forwardRef) => {
    const { $chapters } = React.useContext(TimeSliderContext)!,
      [title, setTitle] = React.useState<string>();

    React.useEffect(() => {
      return effect(() => {
        const chapters = $chapters(),
          cue = chapters?.activePointerCue || chapters?.activeCue;
        setTitle(cue?.text || '');
      });
    }, []);

    return (
      <Primitive.div {...props} ref={forwardRef as React.Ref<any>}>
        {title}
        {children}
      </Primitive.div>
    );
  },
);

ChapterTitle.displayName = 'SliderChapterTitle';

/* -------------------------------------------------------------------------------------------------
 * SliderProgress
 * -----------------------------------------------------------------------------------------------*/

export interface ProgressProps extends PrimitivePropsWithRef<'div'> {}

/**
 * Visual element inside the slider that serves as a horizontal or vertical bar, providing a
 * visual reference for the range of playback that has buffered/loaded.
 *
 * @example
 * ```tsx
 * <TimeSlider.Root>
 *   <TimeSlider.Track>
 *     <TimeSlider.Progress />
 *   </TimeSlider.Track>
 * </TimeSlider.Root>
 * ```
 */
const Progress = React.forwardRef<HTMLElement, ProgressProps>((props, forwardRef) => (
  <Primitive.div {...props} ref={forwardRef as React.Ref<any>} />
));

Progress.displayName = 'SliderProgress';

/* -------------------------------------------------------------------------------------------------
 * SliderThumbnail
 * -----------------------------------------------------------------------------------------------*/

const SliderThumbnailBridge = createReactComponent(SliderThumbnailInstance);

export interface ThumbnailProps extends ReactElementProps<SliderThumbnailInstance, HTMLElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

export type ThumbnailImgProps = ThumbnailBase.ImgProps;

/**
 * Used to display preview thumbnails when the user is hovering or dragging the time slider.
 * The time ranges in the WebVTT file will automatically be matched based on the current slider
 * pointer position.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/sliders/slider-thumbnail}
 *
 * @example
 * ```tsx
 * <TimeSlider.Root>
 *   <TimeSlider.Preview>
 *     <TimeSlider.Thumbnail.Root src="thumbnails.vtt">
 *       <TimeSlider.Thumbnail.Img />
 *     </TimeSlider.Thumbnail.Root>
 *   </TimeSlider.Preview>
 * </TimeSlider.Root>
 * ```
 */
const ThumbnailRoot = React.forwardRef<HTMLElement, ThumbnailProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <SliderThumbnailBridge {...(props as Omit<ThumbnailProps, 'ref'>)}>
        {(props) => (
          <Primitive.div {...props} ref={composeRefs(props.ref as React.Ref<any>, forwardRef)}>
            {children}
          </Primitive.div>
        )}
      </SliderThumbnailBridge>
    );
  },
);

ThumbnailRoot.displayName = 'SliderThumbnail';

const Thumbnail = {
  Root: ThumbnailRoot,
  Img: ThumbnailBase.Img,
} as const;

/* -------------------------------------------------------------------------------------------------
 * SliderVideo
 * -----------------------------------------------------------------------------------------------*/

const VideoBridge = createReactComponent(SliderVideoInstance, {
  events: ['onCanPlay', 'onError'],
});

export interface VideoProps extends ReactElementProps<SliderVideoInstance, HTMLVideoElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLVideoElement>;
}

/**
 * Used to load a low-resolution video to be displayed when the user is hovering over or dragging
 * the time slider. The preview video will automatically be updated to be in-sync with the current
 * preview position, so ensure it has the same length as the original media (i.e., same duration).
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/sliders/slider-video}
 * @example
 * ```tsx
 * <TimeSlider.Root>
 *   <TimeSlider.Preview>
 *     <TimeSlider.Video src="preview.mp4" />
 *   </TimeSlider.Preview>
 * </TimeSlider.Root>
 * ```
 */
const Video = React.forwardRef<HTMLVideoElement, VideoProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <VideoBridge {...(props as Omit<VideoProps, 'ref'>)}>
        {(props, instance) => (
          <VideoProvider
            {...props}
            instance={instance}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef)}
          >
            {children}
          </VideoProvider>
        )}
      </VideoBridge>
    );
  },
);

Video.displayName = 'SliderVideo';

/* -------------------------------------------------------------------------------------------------
 * SliderVideoProvider
 * -----------------------------------------------------------------------------------------------*/

export interface VideoProviderProps {
  instance: SliderVideoInstance;
  children?: React.ReactNode;
}

const VideoProvider = React.forwardRef<HTMLVideoElement, VideoProviderProps>(
  ({ instance, children, ...props }, forwardRef) => {
    const { canLoad } = useStateContext(mediaState),
      { src, video, crossOrigin } = instance.$state,
      $src = useSignal(src),
      $canLoad = useSignal(canLoad),
      $crossOrigin = useSignal(crossOrigin);
    return (
      <Primitive.video
        style={{ maxWidth: 'unset' }}
        {...props}
        src={$src || undefined}
        muted
        playsInline
        preload={$canLoad ? 'auto' : 'none'}
        crossOrigin={$crossOrigin || undefined}
        ref={composeRefs(video.set as React.Ref<HTMLVideoElement>, forwardRef)}
      >
        {children}
      </Primitive.video>
    );
  },
);

VideoProvider.displayName = 'SliderVideoProvider';

export * from './slider';
export { Root, Progress, Thumbnail, Video, Chapters, ChapterTitle };
</file>

<file path="components/ui/sliders/volume-slider.tsx">
import * as React from 'react';

import { createReactComponent, type ReactElementProps } from 'maverick.js/react';

import { VolumeSliderInstance } from '../../primitives/instances';
import { Primitive } from '../../primitives/nodes';
import { Value } from './slider';
import { sliderCallbacks } from './slider-callbacks';

/* -------------------------------------------------------------------------------------------------
 * VolumeSlider
 * -----------------------------------------------------------------------------------------------*/

const VolumeSliderBridge = createReactComponent(VolumeSliderInstance, {
  events: sliderCallbacks,
  domEventsRegex: /^onMedia/,
});

export interface RootProps extends ReactElementProps<VolumeSliderInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<VolumeSliderInstance>;
}

/**
 * Versatile and user-friendly input volume control designed for seamless cross-browser and provider
 * compatibility and accessibility with ARIA support. It offers a smooth user experience for both
 * mouse and touch interactions and is highly customizable in terms of styling. Users can
 * effortlessly change the volume level within the range 0 (muted) to 100.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/sliders/volume-slider}
 * @example
 * ```tsx
 * <VolumeSlider.Root>
 *   <VolumeSlider.Track>
 *     <VolumeSlider.TrackFill />
 *   </VolumeSlider.Track>
 *   <VolumeSlider.Thumb />
 * </VolumeSlider.Root>
 * ```
 */
const Root = React.forwardRef<VolumeSliderInstance, RootProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <VolumeSliderBridge {...props} ref={forwardRef}>
        {(props) => <Primitive.div {...props}>{children}</Primitive.div>}
      </VolumeSliderBridge>
    );
  },
);

Root.displayName = 'VolumeSlider';

export * from './slider';
export { Root, Value };
</file>

<file path="components/ui/spinner.tsx">
import * as React from 'react';

/* -------------------------------------------------------------------------------------------------
 * Spinner
 * -----------------------------------------------------------------------------------------------*/

export interface RootProps
  extends React.PropsWithoutRef<React.SVGProps<SVGSVGElement>>,
    React.RefAttributes<SVGElement | SVGSVGElement> {
  /**
   * The horizontal (width) and vertical (height) length of the spinner.
   *
   * @defaultValue 96
   */
  size?: number;
}

/**
 * @docs {@link https://www.vidstack.io/docs/player/components/display/buffering-indicator}
 * @example
 * ```html
 * <Spinner.Root>
 *   <Spinner.Track />
 *   <Spinner.TrackFill />
 * </Spinner>
 * ```
 */
const Root = React.forwardRef<SVGElement | SVGSVGElement, RootProps>(
  ({ size = 96, children, ...props }: RootProps, forwardRef) => {
    return (
      <svg
        width={size}
        height={size}
        fill="none"
        viewBox="0 0 120 120"
        aria-hidden="true"
        data-part="root"
        {...props}
        ref={forwardRef as React.Ref<any>}
      >
        {children}
      </svg>
    );
  },
);

/* -------------------------------------------------------------------------------------------------
 * Track
 * -----------------------------------------------------------------------------------------------*/

export interface TrackProps
  extends React.PropsWithoutRef<React.SVGProps<SVGCircleElement>>,
    React.RefAttributes<SVGCircleElement> {}

const Track = React.forwardRef<SVGCircleElement, TrackProps>(
  ({ width = 8, children, ...props }, ref) => (
    <circle
      cx="60"
      cy="60"
      r="54"
      stroke="currentColor"
      strokeWidth={width}
      data-part="track"
      {...props}
      ref={ref}
    >
      {children}
    </circle>
  ),
);

/* -------------------------------------------------------------------------------------------------
 * TrackFill
 * -----------------------------------------------------------------------------------------------*/

export interface TrackFillProps
  extends React.PropsWithoutRef<React.SVGProps<SVGCircleElement>>,
    React.RefAttributes<SVGCircleElement> {
  /**
   * The percentage of the track that should be filled.
   */
  fillPercent?: number;
}

const TrackFill = React.forwardRef<SVGCircleElement, TrackFillProps>(
  ({ width = 8, fillPercent = 50, children, ...props }, ref) => (
    <circle
      cx="60"
      cy="60"
      r="54"
      stroke="currentColor"
      pathLength="100"
      strokeWidth={width}
      strokeDasharray={100}
      strokeDashoffset={100 - fillPercent}
      data-part="track-fill"
      {...props}
      ref={ref}
    >
      {children}
    </circle>
  ),
);

export { Root, Track, TrackFill };
</file>

<file path="components/ui/thumbnail.tsx">
import * as React from 'react';

import type { WriteSignal } from 'maverick.js';
import {
  composeRefs,
  createReactComponent,
  useSignal,
  useStateContext,
  type ReactElementProps,
} from 'maverick.js/react';
import { mediaState } from 'vidstack';

import { ThumbnailInstance } from '../primitives/instances';
import { Primitive, type PrimitivePropsWithRef } from '../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * Thumbnail
 * -----------------------------------------------------------------------------------------------*/

const ThumbnailBridge = createReactComponent(ThumbnailInstance);

export interface RootProps extends ReactElementProps<ThumbnailInstance, HTMLElement> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

/**
 * Used to load and display a preview thumbnail at the given `time`.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/display/thumbnail}
 * @example
 * ```tsx
 * <Thumbnail.Root src="thumbnails.vtt" time={10} >
 *   <Thumbnail.Img />
 * </Thumbnail.Root>
 * ```
 */
const Root = React.forwardRef<HTMLElement, RootProps>(({ children, ...props }, forwardRef) => {
  return (
    <ThumbnailBridge {...(props as Omit<RootProps, 'ref'>)}>
      {(props) => (
        <Primitive.div
          {...props}
          ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
        >
          {children}
        </Primitive.div>
      )}
    </ThumbnailBridge>
  );
});

Root.displayName = 'Thumbnail';

/* -------------------------------------------------------------------------------------------------
 * ThumbnailImg
 * -----------------------------------------------------------------------------------------------*/

export interface ImgProps extends PrimitivePropsWithRef<'img'> {
  children?: React.ReactNode;
}

const Img = React.forwardRef<HTMLImageElement, ImgProps>(({ children, ...props }, forwardRef) => {
  const { src, img, crossOrigin } = useStateContext(ThumbnailInstance.state),
    $src = useSignal(src),
    $crossOrigin = useSignal(crossOrigin);
  return (
    <Primitive.img
      crossOrigin={$crossOrigin as '' | undefined}
      {...props}
      src={$src || undefined}
      ref={composeRefs((img as any).set, forwardRef)}
    >
      {children}
    </Primitive.img>
  );
});

Img.displayName = 'ThumbnailImg';

export { Root, Img };
</file>

<file path="components/ui/time.tsx">
import * as React from 'react';

import {
  composeRefs,
  createReactComponent,
  useSignal,
  type ReactElementProps,
} from 'maverick.js/react';

import { TimeInstance } from '../primitives/instances';
import { Primitive } from '../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * Time
 * -----------------------------------------------------------------------------------------------*/

const TimeBridge = createReactComponent(TimeInstance);

export interface TimeProps extends ReactElementProps<TimeInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

/**
 * Outputs a media duration (eg: `currentTime`, `duration`, `bufferedAmount`, etc.) value as time
 * formatted text.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/display/time}
 * @example
 * ```tsx
 * <Time type="current" />
 * ```
 */
const Time = React.forwardRef<HTMLElement, TimeProps>(({ children, ...props }, forwardRef) => {
  return (
    <TimeBridge {...(props as Omit<TimeProps, 'ref'>)}>
      {(props, instance) => (
        <TimeText
          {...props}
          instance={instance}
          ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
        >
          {children}
        </TimeText>
      )}
    </TimeBridge>
  );
});

Time.displayName = 'Time';
export { Time };

/* -------------------------------------------------------------------------------------------------
 * TimeText
 * -----------------------------------------------------------------------------------------------*/

interface TimeTextProps extends Record<string, any> {
  instance: TimeInstance;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

const TimeText = React.forwardRef<HTMLElement, TimeTextProps>(
  ({ instance, children, ...props }, forwardRef) => {
    const { timeText } = instance.$state,
      $timeText = useSignal(timeText);
    return (
      <Primitive.div {...props} ref={forwardRef as React.Ref<any>}>
        {$timeText}
        {children}
      </Primitive.div>
    );
  },
);

TimeText.displayName = 'TimeText';
</file>

<file path="components/ui/title.tsx">
import * as React from 'react';

import { useMediaState } from '../../hooks/use-media-state';
import { Primitive, type PrimitivePropsWithRef } from '../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * Title
 * -----------------------------------------------------------------------------------------------*/

export interface TitleProps extends PrimitivePropsWithRef<'span'> {}

/**
 * This component is used to load and display the current media title.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/display/title}
 * @example
 * ```tsx
 * <Title />
 * ```
 */
const Title = React.forwardRef<HTMLElement, TitleProps>(({ children, ...props }, forwardRef) => {
  const $title = useMediaState('title');
  return (
    <Primitive.span {...props} ref={forwardRef as React.Ref<any>}>
      {$title}
      {children}
    </Primitive.span>
  );
});

Title.displayName = 'Title';
export { Title };
</file>

<file path="components/ui/tooltip.tsx">
import * as React from 'react';

import {
  composeRefs,
  createReactComponent,
  type ReactElementProps,
  type ReactProps,
} from 'maverick.js/react';

import {
  TooltipContentInstance,
  TooltipInstance,
  TooltipTriggerInstance,
} from '../primitives/instances';
import { Primitive } from '../primitives/nodes';

/* -------------------------------------------------------------------------------------------------
 * Tooltip
 * -----------------------------------------------------------------------------------------------*/

const TooltipBridge = createReactComponent(TooltipInstance);

export interface RootProps extends ReactProps<TooltipInstance> {
  asChild?: boolean;
  children: React.ReactNode;
}

/**
 * A contextual text bubble that displays a description for an element that appears on pointer
 * hover or keyboard focus.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/tooltip}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/tooltip_role}
 * @example
 * ```tsx
 * <Tooltip.Root>
 *   <Tooltip.Trigger></Tooltip.Trigger>
 *   <Tooltip.Content></Tooltip.Content>
 * </Tooltip.Root>
 * ```
 */
function Root({ children, ...props }: RootProps) {
  return <TooltipBridge {...props}>{children}</TooltipBridge>;
}

Root.displayName = 'Tooltip';

/* -------------------------------------------------------------------------------------------------
 * TooltipTrigger
 * -----------------------------------------------------------------------------------------------*/

const TriggerBridge = createReactComponent(TooltipTriggerInstance);

export interface TriggerProps extends ReactElementProps<TooltipTriggerInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLButtonElement>;
}

/**
 * Wraps the element that will trigger showing/hiding the tooltip on hover or keyboard focus. The
 * tooltip content is positioned relative to this element.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/tooltip}
 * @example
 * ```tsx
 * <Tooltip.Root>
 *   <Tooltip.Trigger></Tooltip.Trigger>
 *   <Tooltip.Content></Tooltip.Content>
 * </Tooltip.Root>
 * ```
 */
const Trigger = React.forwardRef<HTMLButtonElement, TriggerProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <TriggerBridge {...(props as Omit<TriggerProps, 'ref'>)}>
        {(props) => (
          <Primitive.button
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.button>
        )}
      </TriggerBridge>
    );
  },
);

Trigger.displayName = 'TooltipTrigger';

/* -------------------------------------------------------------------------------------------------
 * TooltipContent
 * -----------------------------------------------------------------------------------------------*/

const ContentBridge = createReactComponent(TooltipContentInstance);

export interface ContentProps extends ReactElementProps<TooltipContentInstance> {
  asChild?: boolean;
  children?: React.ReactNode;
  ref?: React.Ref<HTMLElement>;
}

/**
 * This component contains the content that is visible when the tooltip trigger is interacted with.
 *
 * @docs {@link https://www.vidstack.io/docs/player/components/tooltip}
 * @example
 * ```tsx
 * <Tooltip.Root>
 *   <Tooltip.Trigger></Tooltip.Trigger>
 *   <Tooltip.Content></Tooltip.Content>
 * </Tooltip.Root>
 * ```
 */
const Content = React.forwardRef<HTMLElement, ContentProps>(
  ({ children, ...props }, forwardRef) => {
    return (
      <ContentBridge {...(props as Omit<ContentProps, 'ref'>)}>
        {(props) => (
          <Primitive.div
            {...props}
            ref={composeRefs(props.ref as React.Ref<any>, forwardRef as React.Ref<any>)}
          >
            {children}
          </Primitive.div>
        )}
      </ContentBridge>
    );
  },
);

Content.displayName = 'TooltipContent';

export { Root, Trigger, Content };
</file>

<file path="globals.d.ts">
/// <reference path="../../vidstack/src/globals.d.ts" />

export {};
</file>

<file path="hooks/create-text-track.ts">
import * as React from 'react';

import { TextTrack, type TextTrackInit } from 'vidstack';

import { useMediaContext } from './use-media-context';

/**
 * Creates a new `TextTrack` object and adds it to the player.
 *
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/create-text-track}
 */
export function createTextTrack(init: TextTrackInit) {
  const media = useMediaContext(),
    track = React.useMemo(() => new TextTrack(init), Object.values(init));

  React.useEffect(() => {
    media.textTracks.add(track);
    return () => void media.textTracks.remove(track);
  }, [track]);

  return track;
}
</file>

<file path="hooks/options/use-audio-gain-options.ts">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';
import { DEFAULT_AUDIO_GAINS } from 'vidstack';

import { useMediaContext } from '../use-media-context';

/**
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-audio-gain-options}
 */
export function useAudioGainOptions({
  gains = DEFAULT_AUDIO_GAINS,
  disabledLabel = 'disabled',
}: UseAudioGainOptions = {}): AudioGainOptions {
  const media = useMediaContext(),
    { audioGain, canSetAudioGain } = media.$state;

  useSignal(audioGain);
  useSignal(canSetAudioGain);

  return React.useMemo(() => {
    const options = gains.map<AudioGainOption>((opt) => {
      const label =
          typeof opt === 'number'
            ? opt === 1 && disabledLabel
              ? disabledLabel
              : opt * 100 + '%'
            : opt.label,
        gain = typeof opt === 'number' ? opt : opt.gain;
      return {
        label,
        value: gain.toString(),
        gain,
        get selected() {
          return audioGain() === gain;
        },
        select(trigger) {
          media.remote.changeAudioGain(gain, trigger);
        },
      };
    });

    Object.defineProperty(options, 'disabled', {
      get() {
        return !canSetAudioGain() || !options.length;
      },
    });

    Object.defineProperty(options, 'selectedValue', {
      get() {
        return audioGain()?.toString();
      },
    });

    return options as AudioGainOptions;
  }, [gains]);
}

export interface UseAudioGainOptions {
  gains?: (number | { label: string; gain: number })[];
  disabledLabel?: string | null;
}

export type AudioGainOptions = AudioGainOption[] & {
  readonly disabled: boolean;
  readonly selectedValue: string | undefined;
};

export interface AudioGainOption {
  readonly label: string;
  readonly value: string;
  readonly gain: number;
  readonly selected: boolean;
  select(trigger?: Event): void;
}
</file>

<file path="hooks/options/use-audio-options.ts">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';
import { type AudioTrack } from 'vidstack';

import { useMediaContext } from '../use-media-context';

/**
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-audio-options}
 */
export function useAudioOptions(): AudioOptions {
  const media = useMediaContext(),
    { audioTracks, audioTrack } = media.$state,
    $audioTracks = useSignal(audioTracks);

  useSignal(audioTrack);

  return React.useMemo(() => {
    const options = $audioTracks.map<AudioOption>((track) => ({
      track,
      label: track.label,
      value: getTrackValue(track),
      get selected() {
        return audioTrack() === track;
      },
      select(trigger) {
        const index = audioTracks().indexOf(track);
        if (index >= 0) media.remote.changeAudioTrack(index, trigger);
      },
    }));

    Object.defineProperty(options, 'disabled', {
      get() {
        return options.length <= 1;
      },
    });

    Object.defineProperty(options, 'selectedTrack', {
      get() {
        return audioTrack();
      },
    });

    Object.defineProperty(options, 'selectedValue', {
      get() {
        const track = audioTrack();
        return track ? getTrackValue(track) : undefined;
      },
    });

    return options as AudioOptions;
  }, [$audioTracks]);
}

export type AudioOptions = AudioOption[] & {
  readonly disabled: boolean;
  readonly selectedTrack: AudioTrack | null;
  readonly selectedValue: string | undefined;
};

export interface AudioOption {
  readonly track: AudioTrack;
  readonly label: string;
  readonly value: string;
  readonly selected: boolean;
  select(trigger?: Event): void;
}

function getTrackValue(track: AudioTrack) {
  return track.label.toLowerCase();
}
</file>

<file path="hooks/options/use-caption-options.ts">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';
import { isString } from 'maverick.js/std';
import { isTrackCaptionKind, type TextTrack } from 'vidstack';

import { useMediaContext } from '../use-media-context';

/**
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-caption-options}
 */
export function useCaptionOptions({ off = true }: UseCaptionOptions = {}): CaptionOptions {
  const media = useMediaContext(),
    { textTracks, textTrack } = media.$state,
    $textTracks = useSignal(textTracks);

  useSignal(textTrack);

  return React.useMemo(() => {
    const captionTracks = $textTracks.filter(isTrackCaptionKind),
      options = captionTracks.map<CaptionOption>((track) => ({
        track,
        label: track.label,
        value: getTrackValue(track),
        get selected() {
          return textTrack() === track;
        },
        select(trigger) {
          const index = textTracks().indexOf(track);
          if (index >= 0) media.remote.changeTextTrackMode(index, 'showing', trigger);
        },
      }));

    if (off) {
      options.unshift({
        track: null,
        label: isString(off) ? off : 'Off',
        value: 'off',
        get selected() {
          return !textTrack();
        },
        select(trigger) {
          media.remote.toggleCaptions(trigger);
        },
      });
    }

    Object.defineProperty(options, 'disabled', {
      get() {
        return !captionTracks.length;
      },
    });

    Object.defineProperty(options, 'selectedTrack', {
      get() {
        return textTrack();
      },
    });

    Object.defineProperty(options, 'selectedValue', {
      get() {
        const track = textTrack();
        return track ? getTrackValue(track) : 'off';
      },
    });

    return options as CaptionOptions;
  }, [$textTracks]);
}

export interface UseCaptionOptions {
  /**
   * Whether an option should be included for turning off all captions. A string can be provided
   * to specify the label.
   */
  off?: boolean | string;
}

export type CaptionOptions = CaptionOption[] & {
  readonly disabled: boolean;
  readonly selectedTrack: TextTrack | null;
  readonly selectedValue: string;
};

export interface CaptionOption {
  readonly track: TextTrack | null;
  readonly label: string;
  readonly value: string;
  readonly selected: boolean;
  select(trigger?: Event): void;
}

function getTrackValue(track: TextTrack) {
  return track.id + ':' + track.kind + '-' + track.label.toLowerCase();
}
</file>

<file path="hooks/options/use-chapter-options.ts">
import * as React from 'react';

import { effect, type StopEffect } from 'maverick.js';
import { useSignal } from 'maverick.js/react';
import type { VTTCue } from 'media-captions';
import { formatSpokenTime, formatTime } from 'vidstack';

import { useActiveTextCues } from '../use-active-text-cues';
import { useActiveTextTrack } from '../use-active-text-track';
import { useMediaContext } from '../use-media-context';
import { useTextCues } from '../use-text-cues';

/**
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-chapter-options}
 */
export function useChapterOptions(): ChapterOptions {
  const media = useMediaContext(),
    track = useActiveTextTrack('chapters'),
    cues = useTextCues(track),
    $startTime = useSignal(media.$state.seekableStart),
    $endTime = useSignal(media.$state.seekableEnd);

  useActiveTextCues(track);

  return React.useMemo(() => {
    const options = track
      ? cues
          .filter((cue) => cue.startTime <= $endTime && cue.endTime >= $startTime)
          .map<ChapterOption>((cue, i) => {
            let currentRef: HTMLElement | null = null,
              stopProgressEffect: StopEffect | undefined;
            return {
              cue,
              label: cue.text,
              value: i.toString(),
              startTimeText: formatTime(Math.max(0, cue.startTime - $startTime)),
              durationText: formatSpokenTime(
                Math.min($endTime, cue.endTime) - Math.max($startTime, cue.startTime),
              ),
              get selected() {
                return cue === track.activeCues[0];
              },
              setProgressVar(ref) {
                if (!ref || cue !== track.activeCues[0]) {
                  stopProgressEffect?.();
                  stopProgressEffect = undefined;
                  ref?.style.setProperty('--progress', '0%');
                  currentRef = null;
                  return;
                }

                if (currentRef === ref) return;
                currentRef = ref;

                stopProgressEffect?.();
                stopProgressEffect = effect(() => {
                  const { realCurrentTime } = media.$state,
                    time = realCurrentTime(),
                    cueStartTime = Math.max($startTime, cue.startTime),
                    duration = Math.min($endTime, cue.endTime) - cueStartTime,
                    progress = (Math.max(0, time - cueStartTime) / duration) * 100;

                  ref.style.setProperty('--progress', progress.toFixed(3) + '%');
                });
              },
              select(trigger) {
                media.remote.seek(cue.startTime - $startTime, trigger);
              },
            };
          })
      : [];

    Object.defineProperty(options, 'selectedValue', {
      get() {
        const index = options.findIndex((option) => option.selected);
        return (index >= 0 ? index : 0).toString();
      },
    });

    return options as ChapterOptions;
  }, [cues, $startTime, $endTime]);
}

export type ChapterOptions = ChapterOption[] & {
  readonly selectedValue: string | undefined;
};

export interface ChapterOption {
  readonly cue: VTTCue;
  readonly label: string;
  readonly value: string;
  readonly selected: boolean;
  readonly startTimeText: string;
  readonly durationText: string;
  select(trigger?: Event): void;
  setProgressVar(ref: HTMLElement | null): void;
}
</file>

<file path="hooks/options/use-playback-rate-options.ts">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';
import { DEFAULT_PLAYBACK_RATES } from 'vidstack';

import { useMediaContext } from '../use-media-context';

/**
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-playback-rate-options}
 */
export function usePlaybackRateOptions({
  rates = DEFAULT_PLAYBACK_RATES,
  normalLabel = 'Normal',
}: UsePlaybackRateOptions = {}): PlaybackRateOptions {
  const media = useMediaContext(),
    { playbackRate, canSetPlaybackRate } = media.$state;

  useSignal(playbackRate);
  useSignal(canSetPlaybackRate);

  return React.useMemo(() => {
    const options = rates.map<PlaybackRateOption>((opt) => {
      const label =
          typeof opt === 'number'
            ? opt === 1 && normalLabel
              ? normalLabel
              : opt + 'x'
            : opt.label,
        rate = typeof opt === 'number' ? opt : opt.rate;
      return {
        label,
        value: rate.toString(),
        rate,
        get selected() {
          return playbackRate() === rate;
        },
        select(trigger) {
          media.remote.changePlaybackRate(rate, trigger);
        },
      };
    });

    Object.defineProperty(options, 'disabled', {
      get() {
        return !canSetPlaybackRate() || !options.length;
      },
    });

    Object.defineProperty(options, 'selectedValue', {
      get() {
        return playbackRate().toString();
      },
    });

    return options as PlaybackRateOptions;
  }, [rates]);
}

export interface UsePlaybackRateOptions {
  rates?: (number | { label: string; rate: number })[];
  normalLabel?: string | null;
}

export type PlaybackRateOptions = PlaybackRateOption[] & {
  readonly disabled: boolean;
  readonly selectedValue: string | undefined;
};

export interface PlaybackRateOption {
  readonly label: string;
  readonly value: string;
  readonly rate: number;
  readonly selected: boolean;
  select(trigger?: Event): void;
}
</file>

<file path="hooks/options/use-video-quality-options.ts">
import * as React from 'react';

import { useSignal } from 'maverick.js/react';
import { isString } from 'maverick.js/std';
import { sortVideoQualities, type VideoQuality } from 'vidstack';

import { useMediaContext } from '../use-media-context';

/**
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-video-quality-options}
 */
export function useVideoQualityOptions({
  auto = true,
  sort = 'descending',
}: UseVideoQualityOptions = {}): VideoQualityOptions {
  const media = useMediaContext(),
    { qualities, quality, autoQuality, canSetQuality } = media.$state,
    $qualities = useSignal(qualities);

  // Trigger updates.
  useSignal(quality);
  useSignal(autoQuality);
  useSignal(canSetQuality);

  return React.useMemo(() => {
    const sortedQualities = sortVideoQualities($qualities, sort === 'descending'),
      options = sortedQualities.map<VideoQualityOption>((q) => {
        return {
          quality: q,
          label: q.height + 'p',
          value: getQualityValue(q),
          bitrateText:
            q.bitrate && q.bitrate > 0 ? `${(q.bitrate / 1000000).toFixed(2)} Mbps` : null,
          get selected() {
            return q === quality();
          },
          get autoSelected() {
            return autoQuality();
          },
          select(trigger) {
            const index = qualities().indexOf(q);
            if (index >= 0) media.remote.changeQuality(index, trigger);
          },
        };
      });

    if (auto) {
      options.unshift({
        quality: null,
        label: isString(auto) ? auto : 'Auto',
        value: 'auto',
        bitrateText: null,
        get selected() {
          return autoQuality();
        },
        get autoSelected() {
          return autoQuality();
        },
        select(trigger) {
          media.remote.requestAutoQuality(trigger);
        },
      });
    }

    Object.defineProperty(options, 'disabled', {
      get() {
        return !canSetQuality() || $qualities.length <= 1;
      },
    });

    Object.defineProperty(options, 'selectedQuality', {
      get() {
        return quality();
      },
    });

    Object.defineProperty(options, 'selectedValue', {
      get() {
        const $quality = quality();
        return !autoQuality() && $quality ? getQualityValue($quality) : 'auto';
      },
    });

    return options as VideoQualityOptions;
  }, [$qualities, sort]);
}

export interface UseVideoQualityOptions {
  /**
   * Whether an auto option should be included. A string can be provided to specify the label.
   */
  auto?: boolean | string;
  /**
   * Specifies how the options should be sorted. The sorting algorithm looks at both the quality
   * resolution and bitrate.
   *
   * - Ascending: 480p, 720p, 720p (higher bitrate), 1080p
   * - Descending: 1080p, 720p (higher bitrate), 720p, 480p
   *
   * @default 'descending'
   */
  sort?: 'ascending' | 'descending';
}

export type VideoQualityOptions = VideoQualityOption[] & {
  readonly disabled: boolean;
  readonly selectedQuality: VideoQuality | null;
  readonly selectedValue: string;
};

export interface VideoQualityOption {
  readonly quality: VideoQuality | null;
  readonly label: string;
  readonly value: string;
  readonly selected: boolean;
  readonly autoSelected: boolean;
  readonly bitrateText: string | null;
  select(trigger?: Event): void;
}

function getQualityValue(quality: VideoQuality) {
  return quality.height + '_' + quality.bitrate;
}
</file>

<file path="hooks/use-active-text-cues.ts">
import * as React from 'react';

import { listenEvent } from 'maverick.js/std';
import type { VTTCue } from 'media-captions';
import type { TextTrack } from 'vidstack';

/**
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-active-text-cues}
 */
export function useActiveTextCues(track: TextTrack | null): VTTCue[] {
  const [activeCues, setActiveCues] = React.useState<VTTCue[]>([]);

  React.useEffect(() => {
    if (!track) {
      setActiveCues([]);
      return;
    }

    function onCuesChange() {
      if (track) setActiveCues(track.activeCues as VTTCue[]);
    }

    onCuesChange();
    return listenEvent(track, 'cue-change', onCuesChange);
  }, [track]);

  return activeCues;
}
</file>

<file path="hooks/use-active-text-track.ts">
import * as React from 'react';

import { watchActiveTextTrack, type TextTrack } from 'vidstack';

import { useMediaContext } from './use-media-context';

/**
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-active-text-track}
 */
export function useActiveTextTrack(kind: TextTrackKind | TextTrackKind[]): TextTrack | null {
  const media = useMediaContext(),
    [track, setTrack] = React.useState<TextTrack | null>(null);

  React.useEffect(() => {
    return watchActiveTextTrack(media.textTracks, kind, setTrack);
  }, [kind]);

  return track;
}
</file>

<file path="hooks/use-chapter-title.ts">
import { useActiveTextCues } from './use-active-text-cues';
import { useActiveTextTrack } from './use-active-text-track';

/**
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-chapter-title}
 */
export function useChapterTitle(): string {
  const $track = useActiveTextTrack('chapters'),
    $cues = useActiveTextCues($track);

  return $cues[0]?.text || '';
}
</file>

<file path="hooks/use-dom.ts">
import * as React from 'react';

import { animationFrameThrottle, EventsController, listenEvent, setStyle } from 'maverick.js/std';

export function useClassName(el: HTMLElement | null, className?: string) {
  React.useEffect(() => {
    if (!el || !className) return;

    const tokens = className.split(' ');
    for (const token of tokens) el.classList.add(token);

    return () => {
      for (const token of tokens) el.classList.remove(token);
    };
  }, [el, className]);
}

export function useResizeObserver(el: Element | null | undefined, callback: () => void) {
  React.useEffect(() => {
    if (!el) return;

    callback();

    const observer = new ResizeObserver(animationFrameThrottle(callback));
    observer.observe(el);

    return () => observer.disconnect();
  }, [el, callback]);
}

export function useTransitionActive(el: Element | null) {
  const [isActive, setIsActive] = React.useState(false);

  React.useEffect(() => {
    if (!el) return;

    const events = new EventsController(el)
      .add('transitionstart', () => setIsActive(true))
      .add('transitionend', () => setIsActive(false));

    return () => events.abort();
  }, [el]);

  return isActive;
}

export function useMouseEnter(el: Element | null) {
  const [isMouseEnter, setIsMouseEnter] = React.useState(false);

  React.useEffect(() => {
    if (!el) return;

    const events = new EventsController(el)
      .add('mouseenter', () => setIsMouseEnter(true))
      .add('mouseleave', () => setIsMouseEnter(false));

    return () => events.abort();
  }, [el]);

  return isMouseEnter;
}

export function useFocusIn(el: Element | null) {
  const [isFocusIn, setIsFocusIn] = React.useState(false);

  React.useEffect(() => {
    if (!el) return;

    const events = new EventsController(el)
      .add('focusin', () => setIsFocusIn(true))
      .add('focusout', () => setIsFocusIn(false));

    return () => events.abort();
  }, [el]);

  return isFocusIn;
}

export function useActive(el: Element | null) {
  const isMouseEnter = useMouseEnter(el),
    isFocusIn = useFocusIn(el),
    prevMouseEnter = React.useRef(false);

  if (prevMouseEnter.current && !isMouseEnter) return false;

  prevMouseEnter.current = isMouseEnter;
  return isMouseEnter || isFocusIn;
}

export function useRectCSSVars(root: Element | null, el: Element | null, prefix: string) {
  const onResize = React.useCallback(() => {
    if (root && el) setRectCSSVars(root, el, prefix);
  }, [root, el, prefix]);

  useResizeObserver(el, onResize);
}

export function setRectCSSVars(root: Element, el: Element, prefix: string) {
  const rect = el.getBoundingClientRect();
  for (const side of ['top', 'left', 'bottom', 'right']) {
    setStyle(root as HTMLElement, `--${prefix}-${side}`, `${rect[side]}px`);
  }
}

export function useColorSchemePreference() {
  const [colorScheme, setColorScheme] = React.useState<'light' | 'dark'>('dark');

  React.useEffect(() => {
    const media = window.matchMedia('(prefers-color-scheme: light)');

    function onChange() {
      setColorScheme(media.matches ? 'light' : 'dark');
    }

    onChange();

    return listenEvent(media, 'change', onChange);
  }, []);

  return colorScheme;
}
</file>

<file path="hooks/use-media-context.ts">
import { useReactContext } from 'maverick.js/react';
import { mediaContext } from 'vidstack';

export function useMediaContext() {
  return useReactContext(mediaContext)!;
}
</file>

<file path="hooks/use-media-player.ts">
import type { MediaPlayerInstance } from '../components/primitives/instances';
import { useMediaContext } from './use-media-context';

/**
 * Returns the nearest parent player component.
 *
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-media-player}
 */
export function useMediaPlayer(): MediaPlayerInstance | null {
  const context = useMediaContext();

  if (__DEV__ && !context) {
    throw Error(
      '[vidstack] no media context was found - was this called outside of `<MediaPlayer>`?',
    );
  }

  return context?.player || null;
}
</file>

<file path="hooks/use-media-provider.ts">
import * as React from 'react';

import { effect } from 'maverick.js';
import { type MediaProviderAdapter } from 'vidstack';

import { useMediaContext } from './use-media-context';

/**
 * Returns the current parent media provider.
 *
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-media-provider}
 */
export function useMediaProvider(): MediaProviderAdapter | null {
  const [provider, setProvider] = React.useState<MediaProviderAdapter | null>(null),
    context = useMediaContext();

  if (__DEV__ && !context) {
    throw Error(
      '[vidstack] no media context was found - was this called outside of `<MediaPlayer>`?',
    );
  }

  React.useEffect(() => {
    if (!context) return;
    return effect(() => {
      setProvider(context.$provider());
    });
  }, []);

  return provider;
}
</file>

<file path="hooks/use-media-remote.ts">
import * as React from 'react';

import { MediaRemoteControl } from 'vidstack';

import { MediaPlayerInstance } from '../components/primitives/instances';
import { useMediaContext } from './use-media-context';

/**
 * A media remote provides a simple facade for dispatching media requests to the nearest media
 * player.
 *
 * @param target - The DOM event target to dispatch request events from. Defaults to player
 * if no target is provided.
 *
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-media-remote}
 */
export function useMediaRemote(
  target?: EventTarget | null | React.RefObject<EventTarget | null>,
): MediaRemoteControl {
  const media = useMediaContext(),
    remote = React.useRef<MediaRemoteControl>();

  if (!remote.current) {
    remote.current = new MediaRemoteControl();
  }

  React.useEffect(() => {
    const ref = target && 'current' in target ? target.current : target,
      isPlayerRef = ref instanceof MediaPlayerInstance,
      player = isPlayerRef ? ref : media?.player;

    remote.current!.setPlayer(player ?? null);
    remote.current!.setTarget(ref ?? null);
  }, [media, target && 'current' in target ? target.current : target]);

  return remote.current;
}
</file>

<file path="hooks/use-media-state.ts">
import * as React from 'react';

import { useSignal, useSignalRecord, useStateContext } from 'maverick.js/react';
import { mediaState, type MediaState } from 'vidstack';

import { MediaPlayerInstance } from '../components/primitives/instances';

const mediaStateRecord = MediaPlayerInstance.state.record,
  initialMediaStore = Object.keys(mediaStateRecord).reduce(
    (store, prop) => ({
      ...store,
      [prop]() {
        return mediaStateRecord[prop];
      },
    }),
    {},
  );

/**
 * This hook is used to subscribe to a specific media state.
 *
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-media-state}
 */
export function useMediaState<T extends keyof MediaState>(
  prop: T,
  ref?: React.RefObject<MediaPlayerInstance | null>,
): MediaState[T] {
  const $state = useStateContext(mediaState);

  if (__DEV__ && !$state && !ref) {
    console.warn(
      `[vidstack] \`useMediaState\` requires \`RefObject<MediaPlayerInstance>\` argument if called` +
        ' outside the `<MediaPlayer>` component',
    );
  }

  return useSignal((ref?.current?.$state || $state || initialMediaStore)[prop]);
}

/**
 * This hook is used to subscribe to the current media state on the nearest parent player.
 *
 * @docs {@link https://vidstack.io/docs/player/core-concepts/state-management#reading}
 */
export function useMediaStore(
  ref?: React.RefObject<MediaPlayerInstance | null>,
): Readonly<MediaState> {
  const $state = useStateContext(mediaState);

  if (__DEV__ && !$state && !ref) {
    console.warn(
      `[vidstack] \`useMediaStore\` requires \`RefObject<MediaPlayerInstance>\` argument if called` +
        ' outside the `<MediaPlayer>` component',
    );
  }

  return useSignalRecord(ref?.current ? ref.current.$state : $state || initialMediaStore);
}
</file>

<file path="hooks/use-signals.ts">
import * as React from 'react';

import { computed, effect, scoped, signal, type MaybeStopEffect } from 'maverick.js';
import { useReactScope } from 'maverick.js/react';

export function createSignal<T>(initialValue: T, deps: any[] = []) {
  const scope = useReactScope();
  return React.useMemo(() => scoped(() => signal(initialValue), scope)!, [scope, ...deps]);
}

export function createComputed<T>(compute: () => T, deps: any[] = []) {
  const scope = useReactScope();
  return React.useMemo(() => scoped(() => computed(compute), scope)!, [scope, ...deps]);
}

export function createEffect(compute: () => MaybeStopEffect, deps: any[] = []) {
  const scope = useReactScope();
  React.useEffect(() => scoped(() => effect(compute), scope)!, [scope, ...deps]);
}

export function useScoped<T>(compute: () => T) {
  const scope = useReactScope();
  return React.useMemo(() => scoped(compute, scope)!, [scope]);
}
</file>

<file path="hooks/use-slider-preview.ts">
import * as React from 'react';

import { effect, signal } from 'maverick.js';
import { EventsController, listenEvent } from 'maverick.js/std';
import { updateSliderPreviewPlacement, type SliderOrientation } from 'vidstack';

/**
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-slider-preview}
 */
export function useSliderPreview({
  clamp = false,
  offset = 0,
  orientation = 'horizontal',
}: UseSliderPreview = {}) {
  const [rootRef, setRootRef] = React.useState<HTMLElement | null>(null),
    [previewRef, setPreviewRef] = React.useState<HTMLElement | null>(null),
    [pointerValue, setPointerValue] = React.useState(0),
    [isVisible, setIsVisible] = React.useState(false);

  React.useEffect(() => {
    if (!rootRef) return;

    const dragging = signal(false);

    function updatePointerValue(event: PointerEvent) {
      if (!rootRef) return;
      setPointerValue(getPointerValue(rootRef, event, orientation));
    }

    return effect(() => {
      if (!dragging()) {
        new EventsController(rootRef)
          .add('pointerenter', () => {
            setIsVisible(true);
            previewRef?.setAttribute('data-visible', '');
          })
          .add('pointerdown', (event) => {
            dragging.set(true);
            updatePointerValue(event);
          })
          .add('pointerleave', () => {
            setIsVisible(false);
            previewRef?.removeAttribute('data-visible');
          })
          .add('pointermove', updatePointerValue);
      }

      previewRef?.setAttribute('data-dragging', '');

      new EventsController(document)
        .add('pointerup', (event) => {
          dragging.set(false);
          previewRef?.removeAttribute('data-dragging');
          updatePointerValue(event);
        })
        .add('pointermove', updatePointerValue)
        .add('touchmove', (e) => e.preventDefault(), { passive: false });
    });
  }, [rootRef]);

  React.useEffect(() => {
    if (previewRef) {
      previewRef.style.setProperty('--slider-pointer', pointerValue + '%');
    }
  }, [previewRef, pointerValue]);

  React.useEffect(() => {
    if (!previewRef) return;

    const update = () => {
      updateSliderPreviewPlacement(previewRef, {
        offset,
        clamp,
        orientation,
      });
    };

    update();
    const resize = new ResizeObserver(update);
    resize.observe(previewRef);
    return () => resize.disconnect();
  }, [previewRef, clamp, offset, orientation]);

  return {
    previewRootRef: setRootRef,
    previewRef: setPreviewRef,
    previewValue: pointerValue,
    isPreviewVisible: isVisible,
  };
}

export interface UseSliderPreview {
  /**
   * Whether the preview should be clamped to the start and end of the slider root. If `true` the
   * preview won't be placed outside the root bounds.
   */
  clamp?: boolean;
  /**
   * The distance in pixels between the preview and the slider root. You can also set
   * the CSS variable `--media-slider-preview-offset` to adjust this offset.
   */
  offset?: number;
  /**
   * The orientation of the slider.
   */
  orientation?: SliderOrientation;
}

function getPointerValue(root: HTMLElement, event: PointerEvent, orientation: SliderOrientation) {
  let thumbPositionRate: number,
    rect = root.getBoundingClientRect();

  if (orientation === 'vertical') {
    const { bottom: trackBottom, height: trackHeight } = rect;
    thumbPositionRate = (trackBottom - event.clientY) / trackHeight;
  } else {
    const { left: trackLeft, width: trackWidth } = rect;
    thumbPositionRate = (event.clientX - trackLeft) / trackWidth;
  }

  return round(Math.max(0, Math.min(100, 100 * thumbPositionRate)));
}

function round(num: number) {
  return Number(num.toFixed(3));
}
</file>

<file path="hooks/use-slider-state.ts">
import * as React from 'react';

import { useSignal, useSignalRecord, useStateContext } from 'maverick.js/react';
import { sliderState, type SliderState } from 'vidstack';

import {
  SliderInstance,
  type TimeSliderInstance,
  type VolumeSliderInstance,
} from '../components/primitives/instances';

const sliderStateRecord = SliderInstance.state.record,
  initialSliderStore = Object.keys(sliderStateRecord).reduce(
    (store, prop) => ({
      ...store,
      [prop]() {
        return sliderStateRecord[prop];
      },
    }),
    {},
  );

/**
 * This hook is used to subscribe to a specific slider state.
 *
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-slider-state}
 */
export function useSliderState<T extends keyof SliderState>(
  prop: T,
  ref?: React.RefObject<SliderInstance | VolumeSliderInstance | TimeSliderInstance | null>,
): SliderState[T] {
  const $state = useStateContext(sliderState);

  if (__DEV__ && !$state && !ref) {
    console.warn(
      `[vidstack] \`useSliderState\` requires \`RefObject<SliderInstance>\` argument if called` +
        ' outside of a slider component',
    );
  }

  return useSignal((ref?.current?.$state || $state || initialSliderStore)[prop]);
}

/**
 * This hook is used to subscribe to the current slider state on the given or nearest slider
 * component.
 *
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-slider-state#store}
 */
export function useSliderStore(
  ref?: React.RefObject<SliderInstance | VolumeSliderInstance | TimeSliderInstance | null>,
): Readonly<SliderState> {
  const $state = useStateContext(sliderState);

  if (__DEV__ && !$state && !ref) {
    console.warn(
      `[vidstack] \`useSliderStore\` requires \`RefObject<SliderInstance>\` argument if called` +
        ' outside of a slider component',
    );
  }

  return useSignalRecord(ref?.current ? ref.current.$state : $state || initialSliderStore);
}
</file>

<file path="hooks/use-state.ts">
import * as React from 'react';

import type { AnyRecord, Component, State } from 'maverick.js';
import { useSignal, useSignalRecord } from 'maverick.js/react';

/**
 * This hook is used to subscribe to specific state on a component instance.
 *
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-state}
 */
export function useState<T extends AnyRecord, R extends keyof T>(
  ctor: { state: State<T> },
  prop: R,
  ref: React.RefObject<Component<any, T, any, any> | null>,
): T[R] {
  const initialValue = React.useMemo(() => ctor.state.record[prop], [ctor, prop]);
  return useSignal(ref.current ? ref.current.$state[prop] : initialValue);
}

const storesCache = new Map<any, any>();

/**
 * This hook is used to subscribe to multiple states on a component instance.
 *
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-store}
 */
export function useStore<T extends AnyRecord>(
  ctor: { state: State<T> },
  ref: React.RefObject<Component<any, T, any, any> | null>,
): T {
  const initialStore = React.useMemo<any>(() => {
    let store = storesCache.get(ctor);

    // Share the same initial store proxy across constructors.
    if (!store) {
      store = new Proxy(ctor.state.record, {
        get: (_, prop: any) => () => ctor.state.record[prop],
      });

      storesCache.set(ctor, store);
    }

    return store;
  }, [ctor]);

  return useSignalRecord(ref.current ? ref.current.$state : initialStore);
}
</file>

<file path="hooks/use-text-cues.ts">
import * as React from 'react';

import { EventsController } from 'maverick.js/std';
import type { VTTCue } from 'media-captions';
import type { TextTrack } from 'vidstack';

/**
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-text-cues}
 */
export function useTextCues(track: TextTrack | null): VTTCue[] {
  const [cues, setCues] = React.useState<VTTCue[]>([]);

  React.useEffect(() => {
    if (!track) return;

    function onCuesChange() {
      if (track) setCues([...track.cues]);
    }

    const events = new EventsController(track)
      .add('add-cue', onCuesChange)
      .add('remove-cue', onCuesChange);

    onCuesChange();

    return () => {
      setCues([]);
      events.abort();
    };
  }, [track]);

  return cues;
}
</file>

<file path="hooks/use-thumbnails.ts">
import * as React from 'react';

import { useReactScope, useSignal } from 'maverick.js/react';
import {
  ThumbnailsLoader,
  type MediaCrossOrigin,
  type ThumbnailImage,
  type ThumbnailSrc,
} from 'vidstack';

import { createSignal, useScoped } from './use-signals';

/**
 * The function will return the resolved thumbnail images given a thumbnail resource. It's safe to
 * call this hook in multiple places with the same `src` argument as work is de-duped and cached
 * internally.
 *
 * @docs {@link https://www.vidstack.io/docs/player/api/hooks/use-thumbnails}
 */
export function useThumbnails(
  src: ThumbnailSrc,
  crossOrigin: MediaCrossOrigin | null = null,
): ThumbnailImage[] {
  const scope = useReactScope(),
    $src = createSignal(src),
    $crossOrigin = createSignal(crossOrigin),
    loader = useScoped(() => ThumbnailsLoader.create($src, $crossOrigin));

  if (__DEV__ && !scope) {
    console.warn(
      `[vidstack] \`useThumbnails\` must be called inside a child component of \`<MediaPlayer>\``,
    );
  }

  React.useEffect(() => {
    $src.set(src);
  }, [src]);

  React.useEffect(() => {
    $crossOrigin.set(crossOrigin);
  }, [crossOrigin]);

  return useSignal(loader.$images);
}

/**
 * Returns the active thumbnail image based on the given time.
 *
 * @param thumbnails - thumbnail images.
 * @param time - the current time to determine which thumbnail is active.
 */
export function useActiveThumbnail(
  thumbnails: ThumbnailImage[],
  time: number,
): ThumbnailImage | null {
  return React.useMemo(() => {
    let activeIndex = -1;

    for (let i = thumbnails.length - 1; i >= 0; i--) {
      const image = thumbnails[i];
      if (time >= image.startTime && (!image.endTime || time < image.endTime)) {
        activeIndex = i;
        break;
      }
    }

    return thumbnails[activeIndex] || null;
  }, [thumbnails, time]);
}
</file>

<file path="icon.ts">
import * as React from 'react';

export interface IconProps
  extends React.PropsWithoutRef<React.SVGProps<SVGSVGElement>>,
    React.RefAttributes<SVGElement | SVGSVGElement> {
  /**
   * The horizontal (width) and vertical (height) length of the underlying `<svg>` element.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/width}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/height}
   */
  size?: number;
  part?: string;
  /** @internal */
  paths?: string;
}

export interface IconComponent extends React.ForwardRefExoticComponent<IconProps> {}

const Icon: IconComponent = /* #__PURE__*/ React.forwardRef((props, ref) => {
  const { width, height, size = null, paths, ...restProps } = props;
  return React.createElement('svg', {
    viewBox: '0 0 32 32',
    ...restProps,
    width: width ?? size,
    height: height ?? size,
    fill: 'none',
    'aria-hidden': 'true',
    focusable: 'false',
    xmlns: 'http://www.w3.org/2000/svg',
    ref,
    dangerouslySetInnerHTML: { __html: paths },
  });
});

Icon.displayName = 'VidstackIcon';
export { Icon };
</file>

<file path="index.ts">
export * from 'vidstack/exports/core.ts';
export * from 'vidstack/exports/events.ts';
export * from 'vidstack/exports/foundation.ts';
export * from 'vidstack/exports/maverick.ts';
export * from 'vidstack/exports/providers.ts';
export * from 'vidstack/exports/utils.ts';

export {
  DEFAULT_AUDIO_GAINS,
  DEFAULT_PLAYBACK_RATES,
  sliderState,
  type AudioGainSliderState,
  type GestureAction,
  type MediaAnnouncerState,
  type MediaAnnouncerTranslations,
  type MediaAnnouncerWord,
  type MediaProviderState,
  type MenuPlacement,
  type MenuPlacementAlign,
  type MenuPlacementSide,
  type PosterState,
  type QualitySliderState,
  type SliderCSSVars,
  type SliderOrientation,
  type SliderState,
  type SliderVideoState,
  type SpeedSliderState,
  type ThumbnailState,
  type TimeSliderState,
  type TimeState,
  type TooltipPlacement,
  type TooltipPlacementAlign,
  type TooltipPlacementSide,
  type VolumeSliderState,
} from 'vidstack/exports/components.ts';

// Primitives
export * from './components/primitives/instances';

// Core
export type { PlayerSrc } from './source';
export { type MediaPlayerProps, MediaPlayer } from './components/player';
export { type MediaAnnouncerProps, MediaAnnouncer } from './components/announcer';
export { type MediaProviderProps, MediaProvider } from './components/provider';
export { type IconProps, Icon, type IconComponent } from './icon';
export { Track, type TrackProps } from './components/text-track';

// Controls
export * as Controls from './components/ui/controls';
export type {
  RootProps as ControlsProps,
  GroupProps as ControlsGroupProps,
} from './components/ui/controls';

// Tooltip
export * as Tooltip from './components/ui/tooltip';
export type {
  RootProps as TooltipProps,
  TriggerProps as TooltipTriggerProps,
  ContentProps as TooltipContentProps,
} from './components/ui/tooltip';

// Buttons
export { type ToggleButtonProps, ToggleButton } from './components/ui/buttons/toggle-button';
export { type AirPlayButtonProps, AirPlayButton } from './components/ui/buttons/airplay-button';
export {
  type GoogleCastButtonProps,
  GoogleCastButton,
} from './components/ui/buttons/google-cast-button';
export { type PlayButtonProps, PlayButton } from './components/ui/buttons/play-button';
export { type CaptionButtonProps, CaptionButton } from './components/ui/buttons/caption-button';
export {
  type FullscreenButtonProps,
  FullscreenButton,
} from './components/ui/buttons/fullscreen-button';
export { type MuteButtonProps, MuteButton } from './components/ui/buttons/mute-button';
export { type PIPButtonProps, PIPButton } from './components/ui/buttons/pip-button';
export { type SeekButtonProps, SeekButton } from './components/ui/buttons/seek-button';
export { type LiveButtonProps, LiveButton } from './components/ui/buttons/live-button';

// Slider
export * as Slider from './components/ui/sliders/slider';
export * as VolumeSlider from './components/ui/sliders/volume-slider';
export * as QualitySlider from './components/ui/sliders/quality-slider';
export * as AudioGainSlider from './components/ui/sliders/audio-gain-slider';
export * as SpeedSlider from './components/ui/sliders/speed-slider';
export * as TimeSlider from './components/ui/sliders/time-slider';
export type {
  RootProps as SliderProps,
  ValueProps as SliderValueProps,
  PreviewProps as SliderPreviewProps,
  StepsProps as SliderStepsProps,
} from './components/ui/sliders/slider';
export type { RootProps as VolumeSliderProps } from './components/ui/sliders/volume-slider';
export type { RootProps as AudioGainSliderProps } from './components/ui/sliders/audio-gain-slider';
export type { RootProps as SpeedSliderProps } from './components/ui/sliders/speed-slider';
export type { RootProps as QualitySliderProps } from './components/ui/sliders/quality-slider';
export type {
  RootProps as TimeSliderProps,
  ChaptersProps as SliderChapterProps,
  ChapterTitleProps as SliderChapterTitleProps,
  ThumbnailProps as SliderThumbnailProps,
  ThumbnailImgProps as SliderThumbnailImgProps,
  VideoProps as SliderVideoProps,
} from './components/ui/sliders/time-slider';

// Radio
export * as RadioGroup from './components/ui/radio-group';
export type {
  RootProps as RadioGroupProps,
  ItemProps as RadioProps,
} from './components/ui/radio-group';

// Menu
export * as Menu from './components/ui/menu';
export type {
  RootProps as MenuProps,
  ButtonProps as MenuButtonProps,
  PortalProps as MenuPortalProps,
  ItemsProps as MenuItemsProps,
  ContentProps as MenuContentProps,
  ItemProps as MenuItemProps,
  RadioGroupProps as MenuRadioGroupProps,
  RadioProps as MenuRadioProps,
} from './components/ui/menu';

// Display
export { Title, type TitleProps } from './components/ui/title';
export { ChapterTitle, type ChapterTitleProps } from './components/ui/chapter-title';
export { type GestureProps, Gesture } from './components/ui/gesture';
export { Captions, type CaptionsProps } from './components/ui/captions';
export { type PosterProps, Poster } from './components/ui/poster';
export { type TimeProps, Time } from './components/ui/time';

// Caption
export * as Caption from './components/ui/caption';
export type {
  RootProps as CaptionProps,
  TextProps as CaptionTextProps,
} from './components/ui/caption';

// Thumbnail
export * as Thumbnail from './components/ui/thumbnail';
export type {
  RootProps as ThumbnailProps,
  ImgProps as ThumbnailImgProps,
} from './components/ui/thumbnail';

// Spinner
export * as Spinner from './components/ui/spinner';
export type {
  RootProps as SpinnerProps,
  TrackProps as SpinnerTrackProps,
  TrackFillProps as SpinnerTrackFillProps,
} from './components/ui/spinner';

// Hooks
export * from './hooks/use-state';
export * from './hooks/use-media-context';
export * from './hooks/use-media-player';
export * from './hooks/use-media-provider';
export * from './hooks/use-media-remote';
export * from './hooks/use-media-state';
export * from './hooks/use-thumbnails';
export * from './hooks/use-slider-state';
export * from './hooks/use-slider-preview';
export * from './hooks/use-text-cues';
export * from './hooks/use-active-text-cues';
export * from './hooks/use-active-text-track';
export * from './hooks/use-chapter-title';
export * from './hooks/create-text-track';
export * from './hooks/options/use-audio-gain-options';
export * from './hooks/options/use-audio-options';
export * from './hooks/options/use-caption-options';
export * from './hooks/options/use-chapter-options';
export * from './hooks/options/use-video-quality-options';
export * from './hooks/options/use-playback-rate-options';

// Layouts
export type { DefaultLayoutProps } from './components/layouts/default';
export type { PlyrLayoutProps } from './components/layouts/plyr';
</file>

<file path="providers/remotion/index.ts">
export { type RemotionThumbnailProps, default as RemotionThumbnail } from './ui/thumbnail';
export { type RemotionPosterProps, default as RemotionPoster } from './ui/poster';
export {
  type RemotionSliderThumbnailProps,
  default as RemotionSliderThumbnail,
} from './ui/slider-thumbnail';
export { RemotionProviderLoader } from './loader';
export type { RemotionProvider } from './provider';
export type * from './types';
export { isRemotionProvider, isRemotionSrc as isRemotionSource, isRemotionSrc } from './type-check';
</file>

<file path="providers/remotion/layout-engine.ts">
import { animationFrameThrottle, createDisposalBin } from 'maverick.js/std';

import type { RemotionSrc } from './types';

export class RemotionLayoutEngine {
  #src: RemotionSrc | null = null;
  #viewport: HTMLElement | null = null;
  #canvas: HTMLElement | null = null;
  #container: HTMLElement | null = null;
  #disposal = createDisposalBin();

  constructor() {}

  setSrc(src: RemotionSrc | null) {
    this.#src = src;
    this.setContainer(this.#container);
  }

  setContainer(container: HTMLElement | null) {
    if (__SERVER__) return;

    this.#disposal.empty();

    this.#container = container;
    this.#canvas = container?.parentElement ?? null;
    this.#viewport = this.#canvas?.parentElement ?? null;

    if (this.#src && this.#viewport) {
      const onResize = animationFrameThrottle(this.#onResize.bind(this));

      onResize();
      const observer = new ResizeObserver(onResize);
      observer.observe(this.#viewport);

      this.#disposal.add(() => observer.disconnect());
    }
  }

  destroy() {
    this.#disposal.empty();
  }

  #onResize(entries?: ResizeObserverEntry[]) {
    if (!this.#viewport || !this.#src) return;

    const rect = this.#getRect(this.#viewport, entries?.[0]),
      scale = this.#calcScale(rect),
      transform = this.#calcTransform(rect, scale);

    Object.assign(this.#canvas!.style, {
      width: this.#src.compositionWidth! * scale + 'px',
      height: this.#src.compositionHeight! * scale + 'px',
      display: 'flex',
      flexDirection: 'column',
      position: 'absolute',
      left: transform.centerX,
      top: transform.centerY,
      overflow: 'hidden',
    });

    Object.assign(this.#container!.style, {
      position: 'absolute',
      width: this.#src.compositionWidth + 'px',
      height: this.#src.compositionHeight + 'px',
      display: 'flex',
      transform: `scale(${scale})`,
      marginLeft: transform.x,
      marginTop: transform.y,
      overflow: 'hidden',
    });
  }

  #getRect(el: HTMLElement, entry?: ResizeObserverEntry): LayoutRect {
    const rect = el.getBoundingClientRect();
    if (!entry) return rect;

    const { contentRect, target } = entry,
      newSize = target.getClientRects();

    if (!newSize?.[0]) return rect;

    const scale = contentRect.width === 0 ? 1 : newSize[0].width / contentRect.width,
      width = newSize[0].width * (1 / scale),
      height = newSize[0].height * (1 / scale);

    return {
      width,
      height,
      top: newSize[0].y,
      left: newSize[0].x,
    };
  }

  #calcScale(rect: LayoutRect) {
    if (!this.#src) return 0;

    const heightRatio = rect.height / this.#src.compositionHeight!,
      widthRatio = rect.width / this.#src.compositionWidth!;

    return Math.min(heightRatio || 0, widthRatio || 0);
  }

  #calcTransform(rect: LayoutRect, scale: number) {
    if (!this.#src) return {};

    const correction = 0 - (1 - scale) / 2,
      x = correction * this.#src.compositionWidth!,
      y = correction * this.#src.compositionHeight!,
      width = this.#src.compositionWidth! * scale,
      height = this.#src.compositionHeight! * scale,
      centerX = rect.width / 2 - width / 2,
      centerY = rect.height / 2 - height / 2;

    return { x, y, centerX, centerY };
  }
}

interface LayoutRect {
  width: number;
  height: number;
  top: number;
  left: number;
}
</file>

<file path="providers/remotion/loader.ts">
import * as React from 'react';

import type {
  MediaContext,
  MediaProviderAdapter,
  MediaProviderLoader,
  MediaType,
  Src,
} from 'vidstack';

import * as UI from '../../components/layouts/remotion-ui';

export class RemotionProviderLoader implements MediaProviderLoader {
  readonly name = 'remotion';

  target!: HTMLElement;

  constructor() {
    UI.RemotionThumbnail.set(React.lazy(() => import('./ui/thumbnail')));
    UI.RemotionSliderThumbnail.set(React.lazy(() => import('./ui/slider-thumbnail')));
    UI.RemotionPoster.set(React.lazy(() => import('./ui/poster')));
  }

  canPlay(src: Src): boolean {
    return src.type === 'video/remotion';
  }

  mediaType(): MediaType {
    return 'video';
  }

  async load(ctx: MediaContext): Promise<MediaProviderAdapter> {
    return new (await import('./provider')).RemotionProvider(this.target, ctx);
  }
}
</file>

<file path="providers/remotion/playback-engine.ts">
import { createDisposalBin, listenEvent } from 'maverick.js/std';

import type { RemotionSrc } from './types';

export class RemotionPlaybackEngine {
  #src: RemotionSrc;
  #onFrameChange: (frame: number) => void;
  #onEnd: () => void;
  #disposal = createDisposalBin();
  #frame = 0;
  #framesAdvanced = 0;
  #playbackRate = 1;
  #playing = false;
  #rafId = -1;
  #timerId = -1;
  #startedAt = 0;
  #isRunningInBackground = false;

  get frame() {
    return this.#frame;
  }

  set frame(frame) {
    this.#frame = frame;
    this.#onFrameChange(frame);
  }

  constructor(src: RemotionSrc, onFrameChange: (frame: number) => void, onEnd: () => void) {
    this.#src = src;
    this.#onFrameChange = onFrameChange;
    this.#onEnd = onEnd;
    this.#frame = src.initialFrame ?? 0;
    this.#disposal.add(
      listenEvent(document, 'visibilitychange' as any, this.#onVisibilityChange.bind(this)),
    );
  }

  play() {
    this.#framesAdvanced = 0;
    this.#playing = true;
    this.#startedAt = performance.now();
    this.#tick();
  }

  stop() {
    this.#playing = false;

    if (this.#rafId >= 0) {
      cancelAnimationFrame(this.#rafId);
      this.#rafId = -1;
    }

    if (this.#timerId >= 0) {
      clearTimeout(this.#timerId);
      this.#timerId = -1;
    }
  }

  setPlaybackRate(rate: number) {
    this.#playbackRate = rate;
  }

  destroy() {
    this.#disposal.empty();
    this.stop();
  }

  #update() {
    const { nextFrame, framesToAdvance, ended } = this.#calculateNextFrame();
    this.#framesAdvanced += framesToAdvance;

    if (nextFrame !== this.#frame) {
      this.#onFrameChange(nextFrame);
      this.#frame = nextFrame;
    }

    if (ended) {
      this.#frame = this.#src.outFrame!;
      this.stop();
      this.#onEnd();
    }
  }

  #tick = () => {
    this.#update();
    if (this.#playing) {
      this.#queueNextFrame(this.#tick);
    }
  };

  #queueNextFrame(callback: () => void) {
    if (this.#isRunningInBackground) {
      this.#timerId = window.setTimeout(callback, 1000 / this.#src.fps!);
    } else {
      this.#rafId = requestAnimationFrame(callback);
    }
  }

  #calculateNextFrame() {
    const round = this.#playbackRate < 0 ? Math.ceil : Math.floor,
      time = performance.now() - this.#startedAt,
      framesToAdvance =
        round((time * this.#playbackRate) / (1000 / this.#src.fps!)) - this.#framesAdvanced,
      nextFrame = framesToAdvance + this.#frame,
      isCurrentFrameOutOfBounds =
        this.#frame > this.#src.outFrame! || this.#frame < this.#src.inFrame!,
      isNextFrameOutOfBounds = nextFrame > this.#src.outFrame! || nextFrame < this.#src.inFrame!,
      ended = isNextFrameOutOfBounds && !isCurrentFrameOutOfBounds;

    if (this.#playbackRate > 0 && !ended) {
      // Play forwards
      if (isNextFrameOutOfBounds) {
        return {
          nextFrame: this.#src.inFrame!,
          framesToAdvance,
          ended,
        };
      }

      return { nextFrame, framesToAdvance, ended };
    }

    // Reverse playback
    if (isNextFrameOutOfBounds) {
      return {
        nextFrame: this.#src.outFrame!,
        framesToAdvance,
        ended,
      };
    }

    return { nextFrame, framesToAdvance, ended };
  }

  #onVisibilityChange() {
    this.#isRunningInBackground = document.visibilityState === 'hidden';
    if (this.#playing) {
      this.stop();
      this.play();
    }
  }
}
</file>

<file path="providers/remotion/provider.tsx">
import * as React from 'react';

import { createScope, effect, peek, signal, tick } from 'maverick.js';
import { useSignal } from 'maverick.js/react';
import { deferredPromise, isFunction, listenEvent, type DeferredPromise } from 'maverick.js/std';
import {
  Internals,
  type MediaVolumeContextValue,
  type PlayableMediaTag,
  type SetMediaVolumeContextValue,
  type SetTimelineContextValue,
  type TimelineContextValue,
} from 'remotion';
import { TimeRange, type MediaContext, type MediaProviderAdapter, type Src } from 'vidstack';

import { RemotionLayoutEngine } from './layout-engine';
import { RemotionPlaybackEngine } from './playback-engine';
import { isRemotionSrc } from './type-check';
import type { RemotionSrc } from './types';
import { REMOTION_PROVIDER_ID, RemotionContextProvider } from './ui/context';
import { ErrorBoundary } from './ui/error-boundary';
import { validatePlaybackRate, validateRemotionResource } from './validate';

export class RemotionProvider implements MediaProviderAdapter {
  protected readonly $$PROVIDER_TYPE = 'REMOTION';

  readonly scope = createScope();

  #src = signal<RemotionSrc | null>(null);
  #setup = false;
  #loadStart = false;
  #audio: any = null;
  #waiting = signal(false);
  #waitingPromise: DeferredPromise<void, string> | null = null;
  #mediaTags = signal<PlayableMediaTag[]>([]);
  #mediaElements = signal<HTMLMediaElement[]>([]);
  #bufferingElements = new Set<HTMLMediaElement>();
  #timeline: TimelineContextValue | null = null;
  #frame = signal<Record<string, number>>({ [REMOTION_PROVIDER_ID]: 0 });

  #layoutEngine = new RemotionLayoutEngine();
  #playbackEngine: RemotionPlaybackEngine | null = null;

  readonly #container: HTMLElement;
  readonly #ctx: MediaContext;

  #setTimeline: SetTimelineContextValue;

  #setMediaVolume: SetMediaVolumeContextValue = {
    setMediaMuted: this.setMuted.bind(this),
    setMediaVolume: this.setVolume.bind(this),
  };

  get type() {
    return 'remotion';
  }

  get currentSrc() {
    return peek(this.#src);
  }

  get frame() {
    return this.#frame();
  }

  constructor(container: HTMLElement, ctx: MediaContext) {
    this.#container = container;
    this.#ctx = ctx;
    this.#setTimeline = {
      setFrame: this.#setFrame.bind(this),
      setPlaying: this.#setPlaying.bind(this),
    };
    this.#layoutEngine.setContainer(container);
  }

  setup() {
    effect(this.#watchWaiting.bind(this));
    effect(this.#watchMediaTags.bind(this));
    effect(this.#watchMediaElements.bind(this));
  }

  #watchMediaTags() {
    this.#mediaTags();
    this.#discoverMediaElements();
  }

  #discoverMediaElements() {
    const elements = [...this.#container.querySelectorAll<HTMLMediaElement>('audio,video')];
    this.#mediaElements.set(elements);
  }

  #watchMediaElements() {
    const elements = this.#mediaElements();

    for (const tag of elements) {
      const onWait = this.#onWaitFor.bind(this, tag),
        onStopWaiting = this.#onStopWaitingFor.bind(this, tag);

      if (tag.currentSrc && tag.readyState < 4) {
        this.#onWaitFor(tag);
        listenEvent(tag, 'canplay', onStopWaiting);
      }

      listenEvent(tag, 'waiting', onWait);
      listenEvent(tag, 'playing', onStopWaiting);
    }

    // User might have seeked to a new position, old media elements are removed.
    for (const el of this.#bufferingElements) {
      if (!elements.includes(el)) this.#onStopWaitingFor(el);
    }
  }

  #onFrameChange(frame: number) {
    const { inFrame, fps } = this.#src()!,
      { seeking } = this.#ctx.$state,
      time = Math.max(0, frame - inFrame!) / fps!;

    this.#frame.set((record) => ({
      ...record,
      [REMOTION_PROVIDER_ID]: frame,
    }));

    this.#ctx.notify('time-change', time);

    if (seeking()) {
      tick();
      this.#ctx.notify('seeked', time);
    }
  }

  #onFrameEnd() {
    this.pause();
    this.#ctx.notify('end');
  }

  async play() {
    const { ended } = this.#ctx.$state;

    if (peek(ended)) {
      this.#setFrame({ [REMOTION_PROVIDER_ID]: 0 });
    }

    try {
      const mediaElements = peek(this.#mediaElements);
      if (mediaElements.length) {
        await Promise.all(mediaElements.map((media) => media.play()));
      }

      this.#ctx.notify('play');
      tick();

      if (this.#waitingPromise) {
        this.#ctx.notify('waiting');
        return this.#waitingPromise.promise;
      } else {
        this.#playbackEngine?.play();
        this.#ctx.notify('playing');
      }
    } catch (error) {
      throw error;
    }
  }

  async pause() {
    const { paused } = this.#ctx.$state;
    this.#playbackEngine?.stop();
    this.#ctx.notify('pause');
  }

  setMuted(value: React.SetStateAction<boolean>) {
    if (!this.#ctx) return;

    const { muted, volume } = this.#ctx.$state;

    if (isFunction(value)) {
      this.setMuted(value(muted()));
      return;
    }

    this.#ctx.notify('volume-change', {
      volume: peek(volume),
      muted: value,
    });
  }

  setCurrentTime(time: number) {
    const { fps } = this.#src()!,
      frame = time * fps!;

    this.#ctx.notify('seeking', time);
    this.#setFrame({ [REMOTION_PROVIDER_ID]: frame });
  }

  setVolume(value: React.SetStateAction<number>) {
    if (!this.#ctx) return;

    const { volume, muted } = this.#ctx.$state;

    if (isFunction(value)) {
      this.setVolume(value(volume()));
      return;
    }

    this.#ctx.notify('volume-change', {
      volume: value,
      muted: peek(muted),
    });
  }

  setPlaybackRate(rate: React.SetStateAction<number>) {
    if (isFunction(rate)) {
      const { playbackRate } = this.#ctx.$state;
      this.setPlaybackRate(rate(peek(playbackRate)));
      return;
    }

    if (__DEV__) validatePlaybackRate(rate);
    this.#playbackEngine?.setPlaybackRate(rate);
    this.#ctx.notify('rate-change', rate);
  }

  async loadSource(src: Src) {
    if (!isRemotionSrc(src)) return;

    const onUserError = src.onError,
      resolvedSrc: RemotionSrc = {
        compositionWidth: 1920,
        compositionHeight: 1080,
        fps: 30,
        initialFrame: 0,
        inFrame: 0,
        outFrame: src.durationInFrames,
        numberOfSharedAudioTags: 5,
        inputProps: {},
        ...src,
        onError: (error) => {
          if (__DEV__) {
            this.#ctx.logger
              ?.errorGroup(`[vidstack] ${error.message}`)
              .labelledLog('Source', peek(this.#src))
              .labelledLog('Error', error)
              .dispatch();
          }

          this.pause();
          this.#ctx.notify('error', {
            message: error.message,
            code: 1,
          });

          onUserError?.(error);
        },
      };

    this.#src.set(resolvedSrc);

    // Copy initialized props over to main src object.
    for (const prop of Object.keys(resolvedSrc)) {
      src[prop] = resolvedSrc[prop];
    }

    this.changeSrc(resolvedSrc);
  }

  destroy() {
    this.changeSrc(null);
  }

  changeSrc(src: RemotionSrc | null) {
    this.#playbackEngine?.destroy();

    this.#waiting.set(false);
    this.#waitingPromise?.reject('src changed');
    this.#waitingPromise = null;
    this.#audio = null;
    this.#timeline = null;
    this.#playbackEngine = null;
    this.#mediaTags.set([]);
    this.#bufferingElements.clear();
    this.#frame.set({ [REMOTION_PROVIDER_ID]: 0 });

    this.#layoutEngine.setSrc(src);

    if (src) {
      this.#timeline = this.#createTimelineContextValue();
      this.#playbackEngine = new RemotionPlaybackEngine(
        src,
        this.#onFrameChange.bind(this),
        this.#onFrameEnd.bind(this),
      );
    }
  }

  render = (): React.ReactNode => {
    const $src = useSignal(this.#src);

    if (!$src) {
      throw Error(
        __DEV__
          ? '[vidstack] attempting to render remotion provider without src'
          : '[vidstack] no src',
      );
    }

    React.useEffect(() => {
      if (!isRemotionSrc($src)) return;
      validateRemotionResource($src);

      const rafId = requestAnimationFrame(() => {
        if (!this.#setup) {
          this.#ctx.notify('provider-setup', this);
          this.#setup = true;
        }

        if (!this.#loadStart) {
          this.#ctx.notify('load-start');
          this.#loadStart = true;
        }

        this.#discoverMediaElements();
        tick();
        if (!this.#waiting()) this.#ready($src);
      });

      return () => {
        cancelAnimationFrame(rafId);
        this.#loadStart = false;
      };
    }, [$src]);

    const Component = Internals.useLazyComponent({
      component: $src.src,
    }) as React.LazyExoticComponent<React.ComponentType<unknown>>;

    const { $state } = this.#ctx,
      $volume = useSignal($state.volume),
      $isMuted = useSignal($state.muted);

    const mediaVolume = React.useMemo((): MediaVolumeContextValue => {
      const { muted, volume } = this.#ctx.$state;
      return { mediaMuted: muted(), mediaVolume: volume() };
    }, [$isMuted, $volume]);

    return (
      <RemotionContextProvider
        src={$src}
        component={Component}
        timeline={this.#timeline!}
        mediaVolume={mediaVolume}
        setMediaVolume={this.#setMediaVolume}
      >
        <Internals.Timeline.SetTimelineContext.Provider value={this.#setTimeline}>
          {React.createElement(this.renderVideo, { src: $src })}
        </Internals.Timeline.SetTimelineContext.Provider>
      </RemotionContextProvider>
    );
  };

  renderVideo = ({ src }: { src: RemotionSrc }): React.ReactNode => {
    const video = Internals.useVideo(),
      Video = video ? video.component : null,
      audioContext = React.useContext(Internals.SharedAudioContext);

    const { $state } = this.#ctx;

    useSignal(this.#frame);
    useSignal($state.playing);
    useSignal($state.playbackRate);

    React.useEffect(() => {
      this.#audio = audioContext;
      return () => {
        this.#audio = null;
      };
    }, [audioContext]);

    const LoadingContent = React.useMemo(() => src.renderLoading?.(), [src]);

    const Content = Video ? (
      <ErrorBoundary fallback={src.errorFallback} onError={src.onError!}>
        <Internals.ClipComposition>
          <Video {...video?.props} {...src.inputProps} />
        </Internals.ClipComposition>
      </ErrorBoundary>
    ) : null;

    return <React.Suspense fallback={LoadingContent}>{Content}</React.Suspense>;
  };

  #ready(src: RemotionSrc | null) {
    if (!src) return;

    const { outFrame, inFrame, fps } = src,
      duration = (outFrame! - inFrame!) / fps!;

    this.#ctx.notify('loaded-metadata');
    this.#ctx.notify('loaded-data');

    this.#ctx.delegate.ready({
      duration,
      seekable: new TimeRange(0, duration),
      buffered: new TimeRange(0, duration),
    });

    if (src.initialFrame) {
      this.#setFrame({
        [REMOTION_PROVIDER_ID]: src.initialFrame,
      });
    }
  }

  #onWaitFor(el: HTMLMediaElement) {
    this.#bufferingElements.add(el);
    this.#waiting.set(true);
    if (!this.#waitingPromise) {
      this.#waitingPromise = deferredPromise();
    }
  }

  #onStopWaitingFor(el: HTMLMediaElement) {
    this.#bufferingElements.delete(el);

    // There's still elements we're waiting on.
    if (this.#bufferingElements.size) return;

    this.#waiting.set(false);
    this.#waitingPromise?.resolve();
    this.#waitingPromise = null;

    const { canPlay } = this.#ctx.$state;
    if (!peek(canPlay)) {
      this.#ready(peek(this.#src));
    }
  }

  #watchWaiting() {
    this.#waiting(); // subscribe

    const { paused } = this.#ctx.$state;
    if (peek(paused)) return;

    if (this.#waiting()) {
      this.#playbackEngine?.stop();
      this.#ctx.notify('waiting');
    } else {
      this.#playbackEngine?.play();
      this.#ctx.notify('playing');
    }
  }

  #setFrame(value: React.SetStateAction<Record<string, number>>) {
    if (isFunction(value)) {
      this.#setFrame(value(this.#frame()));
      return;
    }

    this.#frame.set((record) => ({ ...record, ...value }));

    const nextFrame = value[REMOTION_PROVIDER_ID];
    if (this.#playbackEngine && this.#playbackEngine.frame !== nextFrame) {
      this.#playbackEngine.frame = nextFrame;
    }
  }

  #setPlaying(value: React.SetStateAction<boolean>) {
    const { playing } = this.#ctx.$state;

    if (isFunction(value)) {
      this.#setPlaying(value(playing()));
      return;
    }

    if (value) {
      this.play();
    } else if (!value) {
      this.pause();
    }
  }

  #createTimelineContextValue(): TimelineContextValue {
    const { playing, playbackRate } = this.#ctx.$state,
      frame = this.#frame,
      mediaTags = this.#mediaTags,
      setPlaybackRate = this.setPlaybackRate.bind(this);

    return {
      rootId: REMOTION_PROVIDER_ID,
      get frame() {
        return frame();
      },
      get playing() {
        return playing();
      },
      get playbackRate() {
        return playbackRate();
      },
      imperativePlaying: {
        get current() {
          return playing();
        },
      },
      setPlaybackRate,
      audioAndVideoTags: {
        get current() {
          return mediaTags();
        },
        set current(tags) {
          mediaTags.set(tags);
        },
      },
    };
  }
}
</file>

<file path="providers/remotion/type-check.ts">
import type { Src } from 'vidstack';

import type { RemotionProvider } from './provider';
import type { RemotionSrc } from './types';

/** @see {@link https://www.vidstack.io/docs/player/providers/remotion} */
export function isRemotionProvider(provider: any): provider is RemotionProvider {
  return provider?.$$PROVIDER_TYPE === 'REMOTION';
}

export function isRemotionSrc(src?: Src | null): src is RemotionSrc {
  return src?.type === 'video/remotion';
}
</file>

<file path="providers/remotion/types.ts">
import type * as React from 'react';

export interface RemotionSrc<InputProps extends RemotionInputProps = RemotionInputProps> {
  /** React component which is generally a Remotion video. */
  src: React.ComponentType;
  /** Remotion source type. */
  type: 'video/remotion';
  /**
   * Pass props to the component that you have specified using the component prop.
   */
  inputProps?: InputProps;
  /**
   * The width of the composition.
   *
   * @defaultValue 1920
   */
  compositionWidth?: number;
  /**
   * The height of the composition.
   *
   * @defaultValue 1080
   */
  compositionHeight?: number;
  /**
   * The frame rate of the video per second.
   *
   * @defaultValue 30
   */
  fps?: number;
  /**
   * The duration of the video in frames. Must be an integer and greater than 0.
   */
  durationInFrames: number;
  /**
   * Start the playback from a specific frame.
   *
   * @defaultValue 0
   */
  initialFrame?: number;
  /**
   * Limit playback to only play after a certain frame. The video will start from this frame and
   * move to this position once it has ended. Must be an integer, not smaller than 0, not bigger
   * than `outFrame` and not bigger than `durationInFrames - 1`.
   *
   * @defaultValue 0
   */
  inFrame?: number | null;
  /**
   * Limit playback to only play before a certain frame. The video will end at this frame
   * and move to the beginning once it has ended. Must be an integer, not smaller than 1, not
   * smaller than `inFrame` and not bigger than `durationInFrames`.
   *
   * @defaultValue `durationInFrames`
   */
  outFrame?: number;
  /**
   * If you use an `<Audio />` tag, it might not play in some browsers (specifically iOS Safari)
   * due to browser autoplay policies. This is why the player pre-mounts a set of audio tags with
   * silent audio that get played upon user interaction. These audio tags can then be used to play
   * real audio later and will not be subject to the autoplay policy of the browser.
   *
   * This option controls how many audio tags are being rendered, the default is 5. If you mount
   * more audio tags than shared audio tags are available, then an error will be thrown.
   *
   * If you'd like to opt out of this behavior, you can pass 0 to mount native audio tags
   * simultaneously as you mount Remotion's <Audio /> tags.
   *
   * @defaultValue 5
   */
  numberOfSharedAudioTags?: number;
  /**
   * A callback function that allows you to return a custom UI that gets displayed while the
   * provider is loading.
   */
  renderLoading?: RemotionLoadingRenderer;
  /**
   * A callback for rendering a custom error message.
   */
  errorFallback?: RemotionErrorRenderer;
  /**
   * Called when an error or uncaught exception has happened in the video.
   */
  onError?(error: Error): void;
}

export interface RemotionInputProps extends Record<string, unknown> {}

export interface RemotionLoadingRenderer {
  (): React.ReactNode;
}

export interface RemotionErrorRenderer {
  (error: Error): React.ReactNode;
}
</file>

<file path="providers/remotion/ui/context.tsx">
import * as React from 'react';

import { noop } from 'maverick.js/std';
import {
  Internals,
  type CompositionManagerContext,
  type MediaVolumeContextValue,
  type SetMediaVolumeContextValue,
  type TimelineContextValue,
} from 'remotion';

import type { RemotionSrc } from '../types';

export const REMOTION_PROVIDER_ID = 'vds-remotion-provider';

export interface RemotionContextProviderProps {
  src: RemotionSrc;
  component: React.LazyExoticComponent<React.ComponentType<unknown>>;
  timeline: TimelineContextValue;
  mediaVolume: MediaVolumeContextValue;
  setMediaVolume: SetMediaVolumeContextValue;
  children: React.ReactNode;
  numberOfSharedAudioTags?: number;
}

export function RemotionContextProvider({
  src: {
    compositionWidth: width,
    compositionHeight: height,
    fps,
    durationInFrames,
    numberOfSharedAudioTags,
  },
  component,
  timeline,
  mediaVolume,
  setMediaVolume,
  children,
  numberOfSharedAudioTags: providedNumberOfAudioTags,
}: RemotionContextProviderProps) {
  const compositionManager = React.useMemo<CompositionManagerContext>(() => {
    return {
      compositions: [
        {
          id: REMOTION_PROVIDER_ID,
          component: component as React.LazyExoticComponent<React.ComponentType<unknown>>,
          durationInFrames,
          width,
          height,
          fps,
          nonce: 777,
          folderName: null,
          parentFolderName: null,
          schema: null,
          calculateMetadata: null,
        },
      ],
      folders: [],
      registerFolder: () => undefined,
      unregisterFolder: () => undefined,
      registerComposition: () => undefined,
      unregisterComposition: () => undefined,
      updateCompositionDefaultProps: noop,
      currentCompositionMetadata: null,
      setCurrentCompositionMetadata: () => undefined,
      canvasContent: { type: 'composition', compositionId: REMOTION_PROVIDER_ID },
      setCanvasContent: () => undefined,
    };
  }, [component, width, height, fps, durationInFrames]);

  const sequenceManager = React.useMemo(() => {
    let sequences: any[] = [];
    return {
      get sequences() {
        return sequences;
      },
      registerSequence(sequence) {
        sequences = [...sequences, sequence];
      },
      unregisterSequence(sequence) {
        sequences = sequences.filter((s) => s.id !== sequence);
      },
    };
  }, []);

  return (
    <Internals.IsPlayerContextProvider>
      <Internals.CanUseRemotionHooksProvider>
        <Internals.Timeline.TimelineContext.Provider value={timeline}>
          <Internals.CompositionManager.Provider value={compositionManager}>
            <Internals.SequenceManager.Provider value={sequenceManager}>
              <Internals.ResolveCompositionConfig>
                <Internals.PrefetchProvider>
                  <Internals.DurationsContextProvider>
                    <Internals.MediaVolumeContext.Provider value={mediaVolume}>
                      <Internals.NativeLayersProvider>
                        <Internals.SetMediaVolumeContext.Provider value={setMediaVolume}>
                          <Internals.SharedAudioContextProvider
                            numberOfAudioTags={
                              providedNumberOfAudioTags ?? numberOfSharedAudioTags!
                            }
                            component={component}
                          >
                            {children}
                          </Internals.SharedAudioContextProvider>
                        </Internals.SetMediaVolumeContext.Provider>
                      </Internals.NativeLayersProvider>
                    </Internals.MediaVolumeContext.Provider>
                  </Internals.DurationsContextProvider>
                </Internals.PrefetchProvider>
              </Internals.ResolveCompositionConfig>
            </Internals.SequenceManager.Provider>
          </Internals.CompositionManager.Provider>
        </Internals.Timeline.TimelineContext.Provider>
      </Internals.CanUseRemotionHooksProvider>
    </Internals.IsPlayerContextProvider>
  );
}

RemotionContextProvider.displayName = 'RemotionContextProvider';
</file>

<file path="providers/remotion/ui/error-boundary.tsx">
import * as React from 'react';

const errorStyle: React.CSSProperties = __DEV__
  ? {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      color: '	#ff3333',
      padding: '24px',
      position: 'absolute',
      inset: '0',
      width: '100%',
      height: '100%',
    }
  : {};

export interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: (error: Error) => React.ReactNode;
  onError?: (error: Error) => void;
}

interface ErrorBoundaryState {
  hasError: Error | null;
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  static displayName = 'ErrorBoundary';

  override state: { hasError: Error | null } = { hasError: null };

  static getDerivedStateFromError(hasError: Error) {
    return { hasError };
  }

  override componentDidCatch(error: Error) {
    this.props.onError?.(error);
  }

  override render() {
    const error = this.state.hasError;

    if (error) {
      return (
        <div style={errorStyle}>
          {this.props.fallback?.(error) ?? (
            <div style={{ fontWeight: 'bold' }}>
              An error has occurred, see console for more information.
            </div>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}
</file>

<file path="providers/remotion/ui/poster.tsx">
import * as React from 'react';

import { useMediaState } from '../../../hooks/use-media-state';
import RemotionThumbnail, { type RemotionThumbnailProps } from './thumbnail';

export interface RemotionPosterProps extends RemotionThumbnailProps {}

/**
 * @attr data-visible - Whether poster should be shown.
 * @docs {@link https://www.vidstack.io/docs/player/components/remotion/remotion-poster}
 * @example
 * ```tsx
 * <MediaPlayer>
 *   <MediaProvider>
 *     <RemotionPoster frame={100} />
 *   </MediaProvider>
 * </MediaPlayer>
 * ```
 */
const RemotionPoster = React.forwardRef<HTMLElement, RemotionPosterProps>((props, ref) => {
  const $isVisible = !useMediaState('started');
  return (
    <RemotionThumbnail
      {...props}
      ref={ref}
      data-remotion-poster
      data-visible={$isVisible || null}
    />
  );
});

RemotionPoster.displayName = 'RemotionPoster';
export default RemotionPoster;
</file>

<file path="providers/remotion/ui/slider-thumbnail.tsx">
import * as React from 'react';

import { useMediaState } from '../../../hooks/use-media-state';
import { useSliderState } from '../../../hooks/use-slider-state';
import { isRemotionSrc } from '../type-check';
import RemotionThumbnail, { type RemotionThumbnailProps } from './thumbnail';

export interface RemotionSliderThumbnailProps extends Omit<RemotionThumbnailProps, 'frame'> {}

/**
 * @docs {@link https://www.vidstack.io/docs/player/components/remotion/remotion-slider-thumbnail}
 * @example
 * ```tsx
 * <TimeSlider.Root>
 *   <TimeSlider.Preview>
 *     <RemotionSliderThumbnail />
 *   </TimeSlider.Preview>
 * </TimeSlider.Root>
 * ```
 */
const RemotionSliderThumbnail = React.forwardRef<HTMLElement, RemotionSliderThumbnailProps>(
  (props, ref) => {
    const $src = useMediaState('currentSrc'),
      $percent = useSliderState('pointerPercent');

    if (!isRemotionSrc($src)) return null;

    return (
      <RemotionThumbnail
        {...props}
        frame={$src.durationInFrames * ($percent / 100)}
        ref={ref}
        data-remotion-slider-thumbnail
      />
    );
  },
);

RemotionSliderThumbnail.displayName = 'RemotionSliderThumbnail';

export default RemotionSliderThumbnail;
</file>

<file path="providers/remotion/ui/thumbnail.tsx">
import * as React from 'react';

import { noop } from 'maverick.js/std';
import { Internals, random, type TimelineContextValue } from 'remotion';

import { Primitive, type PrimitivePropsWithRef } from '../../../components/primitives/nodes';
import { useMediaState } from '../../../hooks/use-media-state';
import { RemotionLayoutEngine } from '../layout-engine';
import { isRemotionSrc } from '../type-check';
import type { RemotionErrorRenderer, RemotionLoadingRenderer, RemotionSrc } from '../types';
import { REMOTION_PROVIDER_ID, RemotionContextProvider } from './context';
import { ErrorBoundary } from './error-boundary';

export interface RemotionThumbnailProps
  extends Omit<PrimitivePropsWithRef<'div'>, 'children' | 'onError'> {
  /** The video frame to display. */
  frame: number;
  /**
   * A callback function that allows you to return a custom UI that gets displayed while the
   * thumbnail is loading. If this prop is not provided it will default to the loading renderer
   * given to the player source.
   */
  renderLoading?: RemotionLoadingRenderer;
  /**
   * A callback for rendering a custom error message. If this prop is not provided it will default
   * to the error renderer given to the player source.
   */
  errorFallback?: RemotionErrorRenderer;
  /**
   * Called when an error or uncaught exception has happened in the video. If this prop is not
   * provided it will default to the error callback given to the player source.
   */
  onError?(error: Error): void;
}

/**
 * @docs {@link https://www.vidstack.io/docs/player/components/remotion/remotion-thumbnail}
 * @example
 * ```tsx
 * <RemotionThumbnail frame={100} />
 * ```
 */
const RemotionThumbnail = React.forwardRef<HTMLElement, RemotionThumbnailProps>(
  ({ frame, renderLoading, errorFallback, onError, ...props }, ref) => {
    let $src = useMediaState('currentSrc'),
      layoutEngine = React.useMemo(() => new RemotionLayoutEngine(), []);

    // Initialize defaults.
    if (isRemotionSrc($src) && !$src.compositionWidth) {
      $src = {
        compositionWidth: 1920,
        compositionHeight: 1080,
        fps: 30,
        ...$src,
      };
    }

    React.useEffect(() => {
      layoutEngine.setSrc(isRemotionSrc($src) ? $src : null);
      return () => void layoutEngine.setSrc(null);
    }, [$src]);

    const Component = Internals.useLazyComponent({
      component: $src.src as RemotionSrc['src'],
    }) as React.LazyExoticComponent<React.ComponentType<unknown>>;

    const thumbnailId = React.useMemo(() => String(random(null)), []),
      baseTimeline = React.useMemo<TimelineContextValue>(
        () => ({
          rootId: thumbnailId,
          frame: { [REMOTION_PROVIDER_ID]: frame },
          playing: false,
          playbackRate: 1,
          setPlaybackRate: noop,
          audioAndVideoTags: { current: [] },
          imperativePlaying: { current: false },
        }),
        [thumbnailId],
      ),
      timeline = React.useMemo(
        () => ({
          ...baseTimeline,
          frame: { [REMOTION_PROVIDER_ID]: frame },
        }),
        [baseTimeline, frame],
      ),
      volume = React.useMemo(
        () => ({
          mediaMuted: true,
          mediaVolume: 0,
          setMediaMuted: noop,
          setMediaVolume: noop,
        }),
        [],
      );

    const [, update] = React.useState(0);
    React.useEffect(() => {
      update(1);
    }, []);

    if (!isRemotionSrc($src)) return null;

    return (
      <RemotionContextProvider
        src={$src}
        component={Component}
        timeline={timeline}
        mediaVolume={volume}
        setMediaVolume={volume}
        numberOfSharedAudioTags={0}
      >
        <Primitive.div {...props} ref={ref as any} data-remotion-thumbnail>
          <div data-remotion-canvas>
            <div
              data-remotion-container
              ref={(el) => {
                layoutEngine.setContainer(el);
              }}
            >
              <RemotionThumbnailUI
                inputProps={$src.inputProps}
                renderLoading={renderLoading ?? $src.renderLoading}
                errorFallback={errorFallback ?? $src.errorFallback}
                onError={onError ?? $src.onError}
              />
            </div>
          </div>
        </Primitive.div>
      </RemotionContextProvider>
    );
  },
);

RemotionThumbnail.displayName = 'RemotionThumbnail';
export default RemotionThumbnail;

interface RemotionThumbnailUIProps
  extends Pick<RemotionThumbnailProps, 'renderLoading' | 'errorFallback' | 'onError'> {
  inputProps?: RemotionSrc['inputProps'];
}

function RemotionThumbnailUI({
  inputProps,
  renderLoading,
  errorFallback,
  onError,
}: RemotionThumbnailUIProps) {
  const video = Internals.useVideo(),
    Video = video ? video.component : null,
    LoadingContent = React.useMemo(() => renderLoading?.(), [renderLoading]);

  return (
    <React.Suspense fallback={LoadingContent}>
      {Video ? (
        <ErrorBoundary fallback={errorFallback} onError={onError!}>
          <Internals.ClipComposition>
            <Video {...video?.props} {...inputProps} />
          </Internals.ClipComposition>
        </ErrorBoundary>
      ) : null}
    </React.Suspense>
  );
}

RemotionThumbnailUI.displayName = 'RemotionThumbnailUI';
</file>

<file path="providers/remotion/validate.ts">
import { isNil, isNull, isNumber, isUndefined } from 'maverick.js/std';
import { Composition } from 'remotion';
import { NoReactInternals } from 'remotion/no-react';

import type { RemotionSrc } from './types';

export function validateRemotionResource({
  src,
  compositionWidth: width,
  compositionHeight: height,
  fps,
  durationInFrames,
  initialFrame,
  inFrame,
  outFrame,
  numberOfSharedAudioTags,
}: RemotionSrc) {
  if (!__DEV__) return;

  validateComponent(src);
  validateInitialFrame(initialFrame, durationInFrames);

  validateDimension(width, 'compositionWidth', 'of the remotion source');
  validateDimension(height, 'compositionHeight', 'of the remotion source');

  validateDurationInFrames(durationInFrames, {
    component: 'of the remotion source',
    allowFloats: false,
  });

  validateFps(fps, 'of the remotion source', false);

  validateInOutFrames(inFrame, outFrame, durationInFrames);
  validateSharedNumberOfAudioTags(numberOfSharedAudioTags);
}

export const validateFps: typeof NoReactInternals.validateFps = NoReactInternals.validateFps;

export const validateDimension: typeof NoReactInternals.validateDimension =
  NoReactInternals.validateDimension;

export const validateDurationInFrames: typeof NoReactInternals.validateDurationInFrames =
  NoReactInternals.validateDurationInFrames;

export function validateInitialFrame(initialFrame: number | undefined, frames: number) {
  if (!__DEV__) return;

  if (!isNumber(frames)) {
    throw new Error(
      `[vidstack] \`durationInFrames\` must be a number, but is ${JSON.stringify(frames)}`,
    );
  }

  if (isUndefined(initialFrame)) {
    return;
  }

  if (!isNumber(initialFrame)) {
    throw new Error(
      `[vidstack] \`initialFrame\` must be a number, but is ${JSON.stringify(initialFrame)}`,
    );
  }

  if (Number.isNaN(initialFrame)) {
    throw new Error(`[vidstack] \`initialFrame\` must be a number, but is NaN`);
  }

  if (!Number.isFinite(initialFrame)) {
    throw new Error(`[vidstack] \`initialFrame\` must be a number, but is Infinity`);
  }

  if (initialFrame % 1 !== 0) {
    throw new Error(
      `[vidstack] \`initialFrame\` must be an integer, but is ${JSON.stringify(initialFrame)}`,
    );
  }

  if (initialFrame > frames - 1) {
    throw new Error(
      `[vidstack] \`initialFrame\` must be less or equal than \`durationInFrames - 1\`, but is ${JSON.stringify(
        initialFrame,
      )}`,
    );
  }
}

export function validateSingleFrame(frame: unknown, variableName: string): number | null {
  if (!__DEV__) return frame as number;

  if (isNil(frame)) {
    return frame ?? null;
  }

  if (!isNumber(frame)) {
    throw new TypeError(
      `[vidstack] \`${variableName}\` must be a number, but is ${JSON.stringify(frame)}`,
    );
  }

  if (Number.isNaN(frame)) {
    throw new TypeError(
      `[vidstack] \`${variableName}\` must not be NaN, but is ${JSON.stringify(frame)}`,
    );
  }

  if (!Number.isFinite(frame)) {
    throw new TypeError(
      `[vidstack] \`${variableName}\` must be finite, but is ${JSON.stringify(frame)}`,
    );
  }

  if (frame % 1 !== 0) {
    throw new TypeError(
      `[vidstack] \`${variableName}\` must be an integer, but is ${JSON.stringify(frame)}`,
    );
  }

  return frame;
}

export function validateInOutFrames(
  inFrame: number | undefined | null,
  outFrame: number | undefined | null,
  frames: number,
) {
  if (!__DEV__) return;

  const validatedInFrame = validateSingleFrame(inFrame, 'inFrame'),
    validatedOutFrame = validateSingleFrame(outFrame, 'outFrame');

  if (isNull(validatedInFrame) && isNull(validatedOutFrame)) {
    return;
  }

  // Must not be over the duration
  if (!isNull(validatedInFrame) && validatedInFrame > frames - 1) {
    throw new Error(
      `[vidstack] \`inFrame\` must be less than (durationInFrames - 1), but is \`${validatedInFrame}\``,
    );
  }

  if (!isNull(validatedOutFrame) && validatedOutFrame > frames) {
    throw new Error(
      `[vidstack] \`outFrame\` must be less than (durationInFrames), but is \`${validatedOutFrame}\``,
    );
  }

  // Must not be under 0
  if (!isNull(validatedInFrame) && validatedInFrame < 0) {
    throw new Error(
      `[vidstack] \`inFrame\` must be greater than 0, but is \`${validatedInFrame}\``,
    );
  }

  if (!isNull(validatedOutFrame) && validatedOutFrame <= 0) {
    throw new Error(
      `[vidstack] \`outFrame\` must be greater than 0, but is \`${validatedOutFrame}\`. If you want to render a single frame, use \`<RemotionThumbnail />\` instead.`,
    );
  }

  if (
    !isNull(validatedOutFrame) &&
    !isNull(validatedInFrame) &&
    validatedOutFrame <= validatedInFrame
  ) {
    throw new Error(
      '[vidstack] `outFrame` must be greater than `inFrame`, but is ' +
        validatedOutFrame +
        ' <= ' +
        validatedInFrame,
    );
  }
}

export function validateSharedNumberOfAudioTags(tags: number | undefined) {
  if (!__DEV__ || isUndefined(tags)) return;

  if (tags % 1 !== 0 || !Number.isFinite(tags) || Number.isNaN(tags) || tags < 0) {
    throw new TypeError(
      `[vidstack] \`numberOfSharedAudioTags\` must be an integer but got \`${tags}\` instead`,
    );
  }
}

export function validatePlaybackRate(playbackRate: number) {
  if (!__DEV__) return;

  if (playbackRate > 4) {
    throw new Error(
      `[vidstack] The highest possible playback rate with Remotion is 4. You passed: ${playbackRate}`,
    );
  }

  if (playbackRate < -4) {
    throw new Error(
      `[vidstack] The lowest possible playback rate with Remotion is -4. You passed: ${playbackRate}`,
    );
  }

  if (playbackRate === 0) {
    throw new Error(`[vidstack] A playback rate of 0 is not supported.`);
  }
}

export function validateComponent(src: RemotionSrc['src']) {
  if (!__DEV__) return;

  // @ts-expect-error
  if (src.type === Composition) {
    throw new TypeError(
      `[vidstack] \`src\` should not be an instance of \`<Composition/>\`. Pass the React component directly, and set the duration, fps and dimensions as source props.`,
    );
  }

  if (src === Composition) {
    throw new TypeError(
      `[vidstack] \`src\` must not be the \`Composition\` component. Pass your own React component directly, and set the duration, fps and dimensions as source props.`,
    );
  }
}
</file>

<file path="source.ts">
import type { PlayerSrc as BasePlayerSrc } from 'vidstack';

import type { RemotionSrc } from './providers/remotion/types';

export type PlayerSrc = BasePlayerSrc | RemotionSrc;
</file>

<file path="utils.ts">
import { noop } from 'maverick.js/std';
import type { VTTCue } from 'media-captions';

export function createVTTCue(startTime = 0, endTime = 0, text = ''): VTTCue {
  if (__SERVER__) {
    return {
      startTime,
      endTime,
      text,
      addEventListener: noop,
      removeEventListener: noop,
      dispatchEvent: noop,
    } as VTTCue;
  }

  return new window.VTTCue(startTime, endTime, text);
}

export function appendParamsToURL(baseUrl: string, params: Record<string, any>) {
  const url = new URL(baseUrl);

  for (const key of Object.keys(params)) {
    url.searchParams.set(key, params[key] + '');
  }

  return url.toString();
}
</file>

</repository_files>
